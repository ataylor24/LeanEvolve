{
  "Mathlib.Algebra.Squarefree.Basic": {
    "prime_power_factorization": "Replace a square-free conclusion with one asserting that if pᵏ ∣ n (k ≥ 2) then p does not divide the complementary factor, forcing a contradiction with unique factorisation.",
    "radical_squarefree_equiv": "Transform the goal Squarefree n into radical n = n inside ℤ, linking square-free integers to radicals.",
    "introduce_mobius_sum": "Add a statement about the Möbius function μ evaluated on divisors of n squared, forcing cancellation in ∑₍d∣n²₎ μ d.",
    "polynomial_squarefree_lift": "Lift an integer square-free lemma to polynomials by asserting Squarefree (C n * X + 1) under suitable n ≠ 0.",
    "squarefree_prime_product_bound": "Strengthen results to products of distinct primes p₁⋯pₖ, showing any proper divisor has at most k − 1 prime factors.",
    "minimal_prime_divisor_uniqueness": "Assert that the minimal prime dividing a non-unit square-free integer appears with exponent exactly one and is unique.",
    "squarefree_power_divisor_bound": "Prove that if n is square-free then every divisor of nᵏ is of the form d·m² with d ∣ n.",
    "gcd_squarefree_cancellation": "Introduce a hypothesis Squarefree n and conclude gcd n m = 1 → Squarefree (n * m).",
    "unit_associated_normalisation": "Replace equalities up to units by explicit ∃ u : Units ℤ, u • x = y, linking square-free factors through units.",
    "radical_divides_squarefree_power": "State that radical n ∣ nᵏ with equality iff n is square-free, relating radicals to arbitrary powers.",
    "missing": "No mutation operator was provided",
    "<gcd_squarefree_cancellation>": "From Squarefree n and gcd n m = 1 deduce Squarefree (n * m).",
    "<symmetrize_indices>": "Swaps the roles of the two indexed variables throughout the statement.",
    "<<gcd_squarefree_cancellation>>": "From Squarefree n and gcd n m = 1 we infer Squarefree (n * m).",
    "symmetrize_indices": "Swap the roles of the distinguished variables to obtain an equivalent, index–symmetrised statement"
  },
  "Mathlib.Analysis.Complex.Arg": {
    "arg_monodromy_loop": "Replace an equality with a statement that analytic continuation of arg around a simple closed loop changes by 2π·k, k ≠ 0.",
    "arg_continuous_branch_cut": "Add the difficult claim that on a simply-connected open set avoiding 0 and the negative real axis, arg admits a continuous lift to ℝ.",
    "winding_number_integral": "Relate ∮₀¹ (d / dt) arg γ(t) dt to the integer winding number of a closed curve γ not hitting 0.",
    "arg_log_equivalence_branch": "Assert that for a chosen branch Log, arg z = im (Log z) and deduce uniqueness of branches on star-shaped domains.",
    "arg_conformal_map_invariance": "State that for a conformal f with f(0) ≠ 0 the increment of arg along f∘γ equals that of γ, modulo its winding number.",
    "arg_maximum_principle_variant": "Strengthen an arg bound to show that if arg of a holomorphic function attains a local interior extremum then the function is constant.",
    "arg_triangle_strict": "Upgrade |arg(z w) − arg z − arg w| ≤ π to a strict inequality with ε > 0 under non-collinearity conditions.",
    "arg_branch_derivative": "Introduce the claim that the derivative of a smooth branch of arg equals Im (z⁻¹) on its domain.",
    "arg_winding_number_path_lift": "Assert the existence of a continuous lift of arg to ℝ along any path avoiding 0 and relate its endpoints to winding number.",
    "arg_monotone_homotopy": "Given a homotopy H between two loops avoiding 0, prove their arg increments differ by 2πk with the same k.",
    "strip_zero_cases": "Eliminates the trivial zero-terms from an equivalence by adding hypotheses x≠0 and y≠0, thereby isolating the non-trivial branch.",
    "common_scalar_rescale": "Multiply every occurrence of the variables by one arbitrary non-zero scalar, exploiting the homogeneity of the norms and arguments.",
    "<strip_zero_cases>": "Eliminate the x = 0 ∨ y = 0 branches by assuming x ≠ 0 and y ≠ 0.",
    "<arg_winding_number_path_lift>": "Lift Complex.arg continuously to ℝ along a path avoiding 0 and relate the endpoints to a winding number",
    "<<arg_winding_number_path_lift>>": "Lift Complex.arg continuously to ℝ along a path avoiding 0 and relate the endpoints via a winding number",
    "<symmetrize_indices>": "Swap the main arguments of the parent statement to create symmetrical variants.",
    "<arg_monodromy_loop>": "Replace an equality of arguments by a statement that analytic continuation of arg around a closed loop differs by 2π·k, k ≠ 0.",
    "symmetrize_indices": "Swap the main arguments in the original lemma to obtain its symmetric counterpart."
  },
  "Mathlib.SetTheory.Cardinal.Arithmetic": {
    "strong_limit_power_bound": "Replace κ⁺ < 2^κ with the harder ≤ bound for strong-limit cardinals and discuss failure under SCH.",
    "beth_fixed_point_existence": "State that for every κ there exists λ > κ with beth_λ = λ, yielding fixed points of the beth hierarchy.",
    "singular_strong_limit_exponent": "Claim that if κ is singular strong-limit then 2^κ = κ⁺⁺ under GCH and investigate consistency otherwise.",
    "pcf_theoretic_bound": "Introduce the pcf-bound κ^{cf κ} < maxpcf(κ) for regular κ and relate it to Shelah's Strong Hypothesis.",
    "silver_dichotomy_colouring": "State a variant of Silver's theorem showing that any colouring of [κ]² into < cf κ colours has a homogeneous set of size κ.",
    "eastons_function_extension": "Assert that a given normal monotone Easton function on regulars extends to the full power-set function consistently.",
    "stationary_set_reflection_bound": "Relate failure of stationary reflection at κ to lower bounds on 2^κ, yielding inequalities beyond GCH.",
    "square_principle_cardinality": "Assuming ◻_κ, derive a strict inequality between κ⁺ and the least cardinal λ with a special Aronszajn tree.",
    "cofinality_splitting_number": "Introduce the splitting number s_κ and relate κ < s_κ ≤ 2^κ, yielding new lower bounds on 2^κ.",
    "singular_cub_filter_bound": "Show that the existence of a CUB-filter on κ^{++} for singular κ forces 2^κ ≥ κ^{+ω}.",
    "<cofinality_splitting_number>": "Introduce the splitting number s_κ and relate κ < s_κ ≤ 2^κ",
    "<symmetrize_indices>": "Swaps the roles of the indexed variables x and y throughout the statement."
  },
  "Mathlib.LinearAlgebra.Matrix.Symmetric": {
    "eigenvalue_interlace_principle": "Replace a basic eigenvalue bound with the full Cauchy interlacing inequalities for principal submatrices.",
    "weyl_inequality_sum": "Strengthen a trace equality to Weyl's inequalities relating eigenvalues of A, B, A + B.",
    "courant_fischer_minmax": "Introduce the min–max characterisation of kth eigenvalues via subspace optimisation problems.",
    "loewner_order_transitivity": "Assert that if 0 ≤ A ≤ B and 0 ≤ B ≤ C then A ≤ C, with equality characterisation via kernels.",
    "spectral_radius_norm_bound": "Relate spectral radius ρ(A) to operator norm ‖A‖ and give strict inequality for indefinite A.",
    "trace_log_det_inequality": "State the Golden-Thompson–type inequality tr exp(A + B) ≤ tr exp A exp B for symmetric A,B.",
    "psd_sequence_convergence": "Introduce monotone convergence of quadratic forms xᵀAₙx ↑ xᵀAx implying strong operator convergence.",
    "symmetric_congruence_invariance": "Assert that A ≅ B via PᵀAP = B preserves inertia and eigenvalue multiplicities.",
    "determinant_lower_bound_psd": "Strengthen determinant equality to Hadamard-type lower bounds det A ≥ ∏ diag Aᵢᵢ for PSD A.",
    "matrix_function_calculus": "Replace an equality with a statement that a polynomial p satisfies p(A) ≥ 0 for all eigenvalues λᵢ ≥ 0.",
    "<courant_fischer_minmax>": "Introduce min–max style eigenvalue characterisations involving optimisation over subspaces."
  }
}