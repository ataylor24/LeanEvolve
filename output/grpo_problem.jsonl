{"problem": "import Mathlib\nimport Aesop\n\n\n\n\n\ntheorem commutatorElement_inv_left_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u2046 = g\u2081\u207b\u00b9 * g\u2082 * g\u2081 * g\u2082\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_right_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u207b\u00b9\u2046 = g\u2081 * g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_both_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u207b\u00b9\u2046 = g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2081 * g\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081 * g\u2082, g\u2083\u2046 = g\u2081 * g\u2082 * g\u2083 * g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2083\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_right_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081, g\u2082 * g\u2083\u2046 = g\u2081 * (g\u2082 * g\u2083) * g\u2081\u207b\u00b9 * g\u2083\u207b\u00b9 * g\u2082\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_left_alt_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u2046 = g\u2082 * g\u2081 * g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_right_alt_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u207b\u00b9\u2046 = g\u2082\u207b\u00b9 * g\u2081 * g\u2082 * g\u2081\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_both_alt_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u207b\u00b9\u2046 = g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2082 * g\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_alt_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081 * g\u2082, g\u2083\u2046 = g\u2082 * g\u2081 * g\u2083 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2083\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_right_alt_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081, g\u2082 * g\u2083\u2046 = g\u2081 * (g\u2082 * g\u2083) * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2083\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_left_alt2_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u2046 = g\u2082 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_left_reverse_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u2046 = (g\u2081\u207b\u00b9 * g\u2082) * (g\u2081 * g\u2082\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_right_alt2_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u207b\u00b9\u2046 = g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2082 * g\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_both_alt2_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u207b\u00b9\u2046 = g\u2082\u207b\u00b9 * g\u2081 * g\u2082 * g\u2081\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_right_square_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u207b\u00b9 * g\u2082\u207b\u00b9\u2046 = g\u2081 * (g\u2082\u207b\u00b9 * g\u2082\u207b\u00b9) * g\u2081\u207b\u00b9 * g\u2082 * g\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_assoc_def {G : Type*} [Group G] (h\u2081 h\u2082 h\u2083 : G) :\n    \u2045h\u2081 * h\u2082, h\u2083\u2046 = h\u2082 * h\u2081 * h\u2083 * h\u2082\u207b\u00b9 * h\u2081\u207b\u00b9 * h\u2083\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_left_comm_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u2046 = g\u2081\u207b\u00b9 * g\u2082 * g\u2082\u207b\u00b9 * g\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_right_comm_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u207b\u00b9\u2046 = g\u2082\u207b\u00b9 * g\u2081 * g\u2081\u207b\u00b9 * g\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_both_comm_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u207b\u00b9\u2046 = g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2082 * g\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_comm_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081 * g\u2082, g\u2083\u2046 = g\u2081 * g\u2082 * g\u2083 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2083\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_right_comm_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081, g\u2082 * g\u2083\u2046 = g\u2081 * g\u2082 * g\u2083 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2083\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_inv_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081 * g\u2082\u207b\u00b9, g\u2083\u2046 = g\u2081 * g\u2082\u207b\u00b9 * g\u2083 * g\u2082 * g\u2081\u207b\u00b9 * g\u2083\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_right_inv_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081, g\u2082 * g\u2083\u207b\u00b9\u2046 = g\u2081 * (g\u2082 * g\u2083\u207b\u00b9) * g\u2081\u207b\u00b9 * g\u2083 * g\u2082\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_right_double_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, (g\u2082 * g\u2082)\u207b\u00b9\u2046 = g\u2081 * (g\u2082 * g\u2082)\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2082 * g\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_product_right_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081, (g\u2082 * g\u2083)\u207b\u00b9\u2046 = g\u2081 * (g\u2082 * g\u2083)\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2082 * g\u2083 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_mul_left_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9 * g\u2082, g\u2082\u2046 = g\u2081\u207b\u00b9 * g\u2082 * g\u2082 * g\u2082\u207b\u00b9 * g\u2081 * g\u2082\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_mul_right_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082 * g\u2081\u207b\u00b9\u2046 = g\u2081 * (g\u2082 * g\u2081\u207b\u00b9) * g\u2081\u207b\u00b9 * g\u2081 * g\u2082\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt3_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u2046 = (g\u2081 * g\u2082) * (g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_product_left_def {G : Type*} [Group G] (h\u2081 h\u2082 h\u2083 : G) :\n    \u2045h\u2081 * h\u2082, h\u2083 * h\u2082\u2046 = h\u2081 * h\u2082 * h\u2083 * h\u2082 * h\u2082\u207b\u00b9 * h\u2081\u207b\u00b9 * (h\u2083 * h\u2082)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_mul_left_alt_def2 {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9, g\u2082\u2046 = g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2082 * g\u2082\u207b\u00b9 * g\u2081 * g\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_mul_right_alt_def2 {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082 * g\u2081 * g\u2082\u207b\u00b9\u2046 = g\u2081 * (g\u2082 * g\u2081 * g\u2082\u207b\u00b9) * g\u2081\u207b\u00b9 * g\u2082 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_triple_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081 * g\u2082, g\u2082 * g\u2083\u2046 = g\u2081 * g\u2082 * g\u2082 * g\u2083 * g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2083\u207b\u00b9 * g\u2082\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_triple_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081\u207b\u00b9 * g\u2082, g\u2083\u207b\u00b9 * g\u2082\u207b\u00b9\u2046 = g\u2081\u207b\u00b9 * g\u2082 * g\u2083\u207b\u00b9 * g\u2082\u207b\u00b9 * g\u2082 * g\u2081 * g\u2082 * g\u2083 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_cubed_right_def {G : Type*} [Group G] (a b : G) :\n    \u2045a, b * b * b\u2046 = a * (b * b * b) * a\u207b\u00b9 * b\u207b\u00b9 * b\u207b\u00b9 * b\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_cubed_left_def {G : Type*} [Group G] (a b : G) :\n    \u2045a * a * a, b\u2046 = a * a * a * b * a\u207b\u00b9 * a\u207b\u00b9 * a\u207b\u00b9 * b\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_reverse_inv_def {G : Type*} [Group G] (x y : G) :\n    \u2045x\u207b\u00b9, y\u207b\u00b9\u2046 = (x\u207b\u00b9 * y\u207b\u00b9) * (x * y) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_double_product_def {G : Type*} [Group G] (x y z : G) :\n    \u2045x * y, z * y\u2046 = x * y * z * y * y\u207b\u00b9 * x\u207b\u00b9 * y\u207b\u00b9 * z\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_left_conjugate_def {G : Type*} [Group G] (g h k : G) :\n    \u2045h * g * h\u207b\u00b9, k\u2046 = h * g * h\u207b\u00b9 * k * h * g\u207b\u00b9 * h\u207b\u00b9 * k\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_right_conjugate_def {G : Type*} [Group G] (g h k : G) :\n    \u2045g, h * k * h\u207b\u00b9\u2046 = g * (h * k * h\u207b\u00b9) * g\u207b\u00b9 * h * k\u207b\u00b9 * h\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_comm_swap_def {G : Type*} [Group G] (a b : G) :\n    \u2045a, b\u2046 = (b * a) * (b\u207b\u00b9 * a\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_four_product_def {G : Type*} [Group G] (a b c d : G) :\n    \u2045a * b, c * d\u2046 = a * b * c * d * b\u207b\u00b9 * a\u207b\u00b9 * d\u207b\u00b9 * c\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt_product_def {G : Type*} [Group G] (x y z : G) :\n    \u2045x, y * z * y\u207b\u00b9\u2046 = x * (y * z * y\u207b\u00b9) * x\u207b\u00b9 * y * z\u207b\u00b9 * y\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_central_def {G : Type*} [Group G] (c g : G) (h : CommGroup G) :\n    \u2045c, g\u2046 = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_assoc_variation_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p * (q * r), r\u2046 = p * q * r * r * q\u207b\u00b9 * p\u207b\u00b9 * r\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_reverse_order_def {G : Type*} [Group G] (u v : G) :\n    \u2045u, v\u2046 = (u * v) * (v\u207b\u00b9 * u\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_conj_left_def {G : Type*} [Group G] (g h : G) :\n    \u2045h * g * h\u207b\u00b9, g\u2046 = h * g * h\u207b\u00b9 * g * h * g\u207b\u00b9 * h\u207b\u00b9 * g\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_conj_right_def {G : Type*} [Group G] (g h : G) :\n    \u2045g, h * g * h\u207b\u00b9\u2046 = g * (h * g * h\u207b\u00b9) * g\u207b\u00b9 * h * g\u207b\u00b9 * h\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_prod_inv_def {G : Type*} [Group G] (a b : G) :\n    \u2045a * b, (a * b)\u207b\u00b9\u2046 = a * b * (a * b)\u207b\u00b9 * (a * b) * (a * b)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_quadruple_def {G : Type*} [Group G] (a b c d : G) :\n    \u2045a * b, c * d\u2046 = a * b * c * d * b\u207b\u00b9 * a\u207b\u00b9 * d\u207b\u00b9 * c\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_double_comm_def {G : Type*} [Group G] (x y : G) :\n    \u2045x * y, y * x\u2046 = x * y * y * x * y\u207b\u00b9 * x\u207b\u00b9 * x\u207b\u00b9 * y\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_three_way_def {G : Type*} [Group G] (a b c : G) :\n    \u2045a * b, b * c * a\u2046 = a * b * b * c * a * b\u207b\u00b9 * a\u207b\u00b9 * c\u207b\u00b9 * b\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_four_product_alt_def {G : Type*} [Group G] (a b c d : G) :\n    \u2045a, b * c * d\u2046 = a * (b * c * d) * a\u207b\u00b9 * d\u207b\u00b9 * c\u207b\u00b9 * b\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_two_inv_left_def {G : Type*} [Group G] (g h : G) :\n    \u2045g\u207b\u00b9 * g\u207b\u00b9, h\u2046 = g\u207b\u00b9 * g\u207b\u00b9 * h * g * g * h\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_left_variant_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u2046 = (g\u2081\u207b\u00b9 * g\u2082) * (g\u2082\u207b\u00b9 * g\u2081) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_right_variant_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u207b\u00b9\u2046 = (g\u2081 * g\u2082\u207b\u00b9) * (g\u2082 * g\u2081\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_both_inv_mirrored_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081\u207b\u00b9, g\u2082\u207b\u00b9\u2046 = (g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9) * (g\u2082 * g\u2081) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_variant_def {G : Type*} [Group G] (a b c : G) :\n    \u2045a * b, c\u2046 = a * b * c * (b * a)\u207b\u00b9 * c\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_right_variant_def {G : Type*} [Group G] (a b c : G) :\n    \u2045a, b * c\u2046 = a * (b * c) * a\u207b\u00b9 * (c * b)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt_symmetric_def {G : Type*} [Group G] (x y : G) :\n    \u2045x, y\u2046 = (x * y) * (y * x)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_comm_swap_variant_def {G : Type*} [Group G] (u v : G) :\n    \u2045u, v\u2046 = (v * u) * (u * v)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_double_inv_left_def {G : Type*} [Group G] (g h : G) :\n    \u2045g\u207b\u00b9 * g\u207b\u00b9, h\u2046 = g\u207b\u00b9 * g\u207b\u00b9 * h * (g * g)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_double_product_variant_def {G : Type*} [Group G] (x y z : G) :\n    \u2045x * y, z * x\u2046 = x * y * z * x * (y * x * z)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_left_conjugate_variant_def {G : Type*} [Group G] (g h k : G) :\n    \u2045h * g * h\u207b\u00b9, k\u2046 = h * g * h\u207b\u00b9 * k * (h * g * h\u207b\u00b9 * k)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_right_conjugate_variant_def {G : Type*} [Group G] (g h k : G) :\n    \u2045g, h * k * h\u207b\u00b9\u2046 = g * (h * k * h\u207b\u00b9) * g\u207b\u00b9 * (h * k * h\u207b\u00b9 * g)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_product_inv_variant_def {G : Type*} [Group G] (a b : G) :\n    \u2045a * b, (a * b)\u207b\u00b9\u2046 = a * b * (a * b)\u207b\u00b9 * (b * a) * (b * a)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_quadruple_variant_def {G : Type*} [Group G] (a b c d : G) :\n    \u2045a * b, c * d\u2046 = a * b * c * d * (b * a)\u207b\u00b9 * (d * c)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_three_way_variant_def {G : Type*} [Group G] (a b c : G) :\n    \u2045a * b, c * a * b\u2046 = a * b * c * a * b * (b\u207b\u00b9 * a\u207b\u00b9 * c\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_reverse_inv_variant_def {G : Type*} [Group G] (x y : G) :\n    \u2045x\u207b\u00b9, y\u207b\u00b9\u2046 = (y\u207b\u00b9 * x\u207b\u00b9) * (y * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt4_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u2046 = g\u2081 * g\u2082 * g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_triple_variant_def {G : Type*} [Group G] (g\u2081 g\u2082 g\u2083 : G) :\n    \u2045g\u2081 * g\u2082, g\u2083 * g\u2081\u2046 = g\u2081 * g\u2082 * g\u2083 * g\u2081 * g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 * g\u2083\u207b\u00b9 * g\u2081\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_assoc_variation_def2 {G : Type*} [Group G] (p q r : G) :\n    \u2045p * q * r, r\u2046 = p * q * r * r * q\u207b\u00b9 * p\u207b\u00b9 * r\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_reverse_order_variant_def {G : Type*} [Group G] (u v : G) :\n    \u2045u, v\u2046 = (v * u) * (u\u207b\u00b9 * v\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_quadruple_alt_def {G : Type*} [Group G] (a b c d : G) :\n    \u2045a * b, c * d\u2046 = a * b * c * d * (d * c)\u207b\u00b9 * (b * a)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt_product_swap_def {G : Type*} [Group G] (x y z : G) :\n    \u2045x, y\u207b\u00b9 * z * y\u2046 = x * (y\u207b\u00b9 * z * y) * x\u207b\u00b9 * y\u207b\u00b9 * z\u207b\u00b9 * y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_prod_inv_alt_def {G : Type*} [Group G] (a b : G) :\n    \u2045a * b, (b * a)\u207b\u00b9\u2046 = a * b * (b * a)\u207b\u00b9 * (b * a) * (a * b)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_three_way_swap_def {G : Type*} [Group G] (a b c : G) :\n    \u2045b * a, c * b * a\u2046 = b * a * c * b * a * a\u207b\u00b9 * b\u207b\u00b9 * c\u207b\u00b9 * a\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_double_inv_right_def {G : Type*} [Group G] (g h : G) :\n    \u2045g, h\u207b\u00b9 * h\u207b\u00b9\u2046 = g * (h\u207b\u00b9 * h\u207b\u00b9) * g\u207b\u00b9 * (h * h) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_left_conjugate_variant2_def {G : Type*} [Group G] (g h k : G) :\n    \u2045h * g * h\u207b\u00b9, k\u2046 = h * g * h\u207b\u00b9 * k * (k * h * g * h\u207b\u00b9)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_product_inv_variant2_def {G : Type*} [Group G] (a b : G) :\n    \u2045a * b, (b * a)\u207b\u00b9\u2046 = a * b * (b * a)\u207b\u00b9 * (a * b) * (a * b)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_three_way_variant2_def {G : Type*} [Group G] (a b c : G) :\n    \u2045b * a, a * c * b\u2046 = b * a * a * c * b * (c\u207b\u00b9 * a\u207b\u00b9 * b\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_assoc_variation_alt2_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p * q * r, q\u2046 = p * q * r * q * q\u207b\u00b9 * p\u207b\u00b9 * r\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_reverse_brackets_def {G : Type*} [Group G] (x y : G) :\n    \u2045x, y\u2046 = y * x * y\u207b\u00b9 * x\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt_product_swap_def {G : Type*} [Group G] (x y z : G) :\n    \u2045x, y\u207b\u00b9 * z * y\u2046 = x * (y\u207b\u00b9 * z * y) * x\u207b\u00b9 * y\u207b\u00b9 * z\u207b\u00b9 * y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_pow_two_def {G : Type*} [Group G] (g h : G) :\n    \u2045g\u207b\u00b9, h * h\u2046 = g\u207b\u00b9 * (h * h) * g * h\u207b\u00b9 * h\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_left_conjugate_simple_def {G : Type*} [Group G] (g h k : G) :\n    \u2045h * g * h\u207b\u00b9, k\u2046 = h * g * h\u207b\u00b9 * k * g\u207b\u00b9 * h\u207b\u00b9 * k\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_right_conjugate_simple_def {G : Type*} [Group G] (g h k : G) :\n    \u2045g, h * k * h\u207b\u00b9\u2046 = g * (h * k * h\u207b\u00b9) * g\u207b\u00b9 * k\u207b\u00b9 * h\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_assoc_variation_alt_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p * (q * r), q\u2046 = p * q * r * q * q\u207b\u00b9 * p\u207b\u00b9 * r\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_double_product_variant_def {G : Type*} [Group G] (x y z : G) :\n    \u2045x * y, z * x\u2046 = x * y * z * x * (y * x * z)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt4_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u2046 = g\u2081 * g\u2082 * g\u2082\u207b\u00b9 * g\u2081\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_short_def {G : Type*} [Group G] (a b c : G) :\n    \u2045a * b, c\u2046 = a * b * c * (b * a)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_three_way_swap_def {G : Type*} [Group G] (a b c : G) :\n    \u2045b * a, c * b * a\u2046 = b * a * c * b * a * a\u207b\u00b9 * b\u207b\u00b9 * c\u207b\u00b9 * a\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_assoc_variation_alt_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p * (q * r), q\u2046 = p * q * r * q * q\u207b\u00b9 * p\u207b\u00b9 * r\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_reverse_brackets_def {G : Type*} [Group G] (x y : G) :\n    \u2045x, y\u2046 = y * x * y\u207b\u00b9 * x\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_inv_pow_two_def {G : Type*} [Group G] (g h : G) :\n    \u2045g\u207b\u00b9, h * h\u2046 = g\u207b\u00b9 * (h * h) * g * h\u207b\u00b9 * h\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_twist_right_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p, q * (r * p)\u2046 = p * (q * (r * p)) * p\u207b\u00b9 * (p\u207b\u00b9 * r\u207b\u00b9 * q\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_flip_def {G : Type*} [Group G] (a b c : G) :\n    \u2045a * b, c\u2046 = a * b * c * (a * b)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_alt5_def {G : Type*} [Group G] (x y : G) :\n    \u2045x, y\u2046 = (x * y) * (x\u207b\u00b9 * y)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_conj_left_short_def {G : Type*} [Group G] (g h k : G) :\n    \u2045h * g * h\u207b\u00b9, k\u2046 = h * g * h\u207b\u00b9 * k * (h * g)\u207b\u00b9 * k\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_conj_right_short_def {G : Type*} [Group G] (g h k : G) :\n    \u2045g, h * k * h\u207b\u00b9\u2046 = g * (h * k * h\u207b\u00b9) * g\u207b\u00b9 * (k * h)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_triple_swap_def {G : Type*} [Group G] (a b c : G) :\n    \u2045a * b, c * b * a\u2046 = a * b * c * b * a * (b * a)\u207b\u00b9 * c\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_reverse_pair_def {G : Type*} [Group G] (x y : G) :\n    \u2045x, y\u2046 = y * x * (y * x)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_twist_left_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p * (q * r), p\u2046 = p * (q * r) * p\u207b\u00b9 * (r\u207b\u00b9 * q\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mirrored_conj_def {G : Type*} [Group G] (g h : G) :\n    \u2045h * g * h\u207b\u00b9, g\u2046 = h * g * h\u207b\u00b9 * g * (h * g)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_mul_left_flip_def {G : Type*} [Group G] (a b c : G) :\n    \u2045b * a, c\u2046 = b * a * c * a\u207b\u00b9 * b\u207b\u00b9 * c\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_twist_left_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p * (q * r), p\u2046 = p * (q * r) * p\u207b\u00b9 * r\u207b\u00b9 * q\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_twist_right_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p, q * (r * p)\u2046 = p * (q * (r * p)) * p\u207b\u00b9 * p\u207b\u00b9 * r\u207b\u00b9 * q\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_twist_variant_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p * q, r * p\u2046 = p * q * r * p * p\u207b\u00b9 * r\u207b\u00b9 * q\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem commutatorElement_twist_mix_def {G : Type*} [Group G] (p q r : G) :\n    \u2045p, q * (r * p)\u2046 = p * (q * (r * p)) * p\u207b\u00b9 * r\u207b\u00b9 * q\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem squarefree_mul_comm_imp_relprime [CommMonoid R] {m n : R} (h : Squarefree (n * m)) : IsRelPrime m n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem IsUnit.squarefree_pow [CommMonoid R] {x : R} (h : IsUnit x) (n : \u2115) : Squarefree (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem squarefree_one_mul [CommMonoid R] : Squarefree ((1 : R) * 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem Irreducible.squarefree_pow [CommMonoid R] {x : R} (h : Irreducible x) (n : \u2115) : Squarefree (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem Prime.squarefree_pow [CancelCommMonoidWithZero R] {x : R} (h : Prime x) (n : \u2115) : Squarefree (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem Squarefree.mul_left_iff_unit [CommMonoid R] {m n : R} (hu : IsUnit m) : Squarefree (m * n) \u2194 Squarefree n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem Squarefree.of_dvd' [Monoid R] {x y : R} (hdvd : x \u2223 y) : Squarefree y \u2192 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem Squarefree.pow_two_imp_unit [Monoid R] {x : R} (h : Squarefree (x ^ 2)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem Squarefree.pow_succ_dvd_imp_dvd [Monoid R] {x y : R} {n : \u2115} (hx : Squarefree y) (h : x ^ (n + 1) \u2223 y) : x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem squarefree_iff_emultiplicity_lt_two [CommMonoid R] (r : R) : Squarefree r \u2194 \u2200 x : R, emultiplicity x r < 2 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem squarefree_iff_no_irreducible_sq_dvd {x : R} (hx\u2080 : x \u2260 0) : Squarefree x \u2194 \u2200 p, Irreducible p \u2192 \u00ac (p ^ 2 \u2223 x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem irreducible_sq_not_dvd_or_squarefree (r : R) : (\u2200 x : R, Irreducible x \u2192 \u00ac x ^ 2 \u2223 r) \u2194 (r = 0 \u2228 Squarefree r) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem squarefree_iff_irreducible_sq_not_dvd_nonzero {r : R} (hr : r \u2260 0) : Squarefree r \u2194 \u2200 x : R, Irreducible x \u2192 \u00ac x ^ 2 \u2223 r := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem squarefree_iff_irreducible_sq_not_dvd_exists {r : R} (hr : \u2203 x : R, Irreducible x) : Squarefree r \u2194 \u2200 x : R, Irreducible x \u2192 \u00ac x ^ 2 \u2223 r := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem Squarefree.dvd_pow_iff_dvd' {x y : R} {n : \u2115} (hsq : Squarefree x) (h0 : 1 \u2264 n) : x \u2223 y ^ n \u2194 x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem IsRadical.squarefree_of_ne_zero' (h0 : x \u2260 0) (h : IsRadical x) : Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem pow_two_dvd_of_squarefree_mul_right (hx : Squarefree x) (hp : Prime p) (h : p ^ 2 \u2223 x * y) : p \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem pow_two_dvd_of_squarefree_mul_left (hy : Squarefree y) (hp : Prime p) (h : p ^ 2 \u2223 x * y) : p \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem prime_sq_dvd_mul_right_of_squarefree (hx : Squarefree x) (hp : Prime p) (h : p * p \u2223 x * y) : p \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem prime_sq_dvd_mul_left_of_squarefree (hy : Squarefree y) (hp : Prime p) (h : p * p \u2223 x * y) : p \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem squarefree_mul_comm_iff : Squarefree (x * y) \u2194 IsRelPrime y x \u2227 Squarefree y \u2227 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem isRadical_imp_squarefree_or_zero (h : IsRadical x) : Squarefree x \u2228 x = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem isRadical_iff_squarefree_nonzero (h : x \u2260 0) : IsRadical x \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\n\ntheorem _root_.exists_squarefree_dvd_pow_succ_of_ne_zero {x : R} (hx : x \u2260 0) : \u2203 y : R, \u2203 n : \u2115, Squarefree y \u2227 y \u2223 x \u2227 x \u2223 y ^ (n + 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.of_squarefree_mul_comm [CommMonoid R] {a b : R} (h : Squarefree (b * a)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_three_imp_unit [Monoid R] {x : R} (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_of_pow_succ_succ_dvd [Monoid R] {x y : R} {n : \u2115} (hx : Squarefree y) (h : x ^ (n + 2) \u2223 y) : x ^ (n + 1) \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_dvd_left [Monoid R] {x y : R} (hxy : y \u2223 x) (hsq : Squarefree x) : Squarefree y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_succ [CommMonoid R] {x : R} (h : IsUnit x) (n : \u2115) : Squarefree (x ^ (n + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_three [CommMonoid R] {x : R} (h : Irreducible x) : Squarefree (x ^ 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_succ [CancelCommMonoidWithZero R] {x : R} (h : Prime x) (n : \u2115) : Squarefree (x ^ (n + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_right_iff_unit [CommMonoid R] {m n : R} (hu : IsUnit n) : Squarefree (m * n) \u2194 Squarefree m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_two_iff_unit [Monoid R] {x : R} : Squarefree (x ^ 2) \u2194 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp_unit_or_dvd [Monoid R] {x y : R} {n : \u2115} (hx : Squarefree y) (h : x ^ (n + 2) \u2223 y) : IsUnit x \u2228 x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_eq_zero_or_one [CommMonoid R] (r : R) : Squarefree r \u2194 \u2200 x : R, emultiplicity x r = 0 \u2228 emultiplicity x r = 1 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRadical.squarefree_or_zero (h : IsRadical x) : x = 0 \u2228 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_of_relprime [CommMonoid R] {a b : R} (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) : Squarefree (a * b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.isRelPrime_pow_mul [CommMonoid R] {a b : R} {n : \u2115} (h : Squarefree (a ^ n * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_pow_mul_left [Monoid R] {a b : R} {n : \u2115} (hsq : Squarefree (a ^ n * b)) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_iff [CommMonoid R] {u x : R} (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree [CancelCommMonoidWithZero R] {p x : R} (hp : Prime p) (hx : Squarefree x) : \u00ac p * p \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_iff [Monoid R] {a b : R} {k : \u2115} (ha : Squarefree a) (hk : k \u2260 0) : a \u2223 b ^ k \u2194 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.eq_unit_of_cube_squarefree [CommMonoid R] {x : R} (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.squarefree_of_pow_dvd [Monoid R] {x y : R} {n : \u2115} (hxy : x \u2223 y ^ n) (hsq : Squarefree y) : Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_mul_left_iff [CommMonoid R] {a b c : R} (hsq : Squarefree a) : a \u2223 b * c \u2194 a \u2223 b \u2228 a \u2223 c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_or_not_square [Monoid R] {x : R} (hsq : Squarefree x) : \u2200 y : R, y * y \u2223 x \u2192 IsUnit y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.squarefree_mul [CommMonoid R] {a b : R} (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) : Squarefree (a * b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self [Monoid R] {x : R} {k : \u2115} (hsq : Squarefree x) : x ^ k \u2223 x \u2194 k = 0 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.is_unit_or_small_pow [Monoid R] {x : R} {n : \u2115} (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_two_dvd_of_mul [Monoid R] {x y : R} (hx : Squarefree x) (h : y * y \u2223 x * y) : y \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_mul_unit [CommMonoid R] {u x : R} (hu : IsUnit u) (hx : Irreducible x) : Squarefree (u * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.of_squarefree_mul_comm [CommMonoid R] {a b : R} (h : Squarefree (a * b)) :\n    IsRelPrime b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_mul [CommMonoid R] {u x : R} (hu : IsUnit u) : Squarefree (u * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_one_mul_one [CommMonoid R] : Squarefree ((1 : R) * 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_comm [CommMonoid R] {x y : R} (h : Squarefree (x * y)) :\n    Squarefree (y * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_unit_mul [CommMonoid R] {u x : R} (hu : IsUnit u) (h : Squarefree (u * x)) :\n    Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_pow [CommMonoid R] {u : R} (hu : IsUnit u) (n : \u2115) :\n    Squarefree (u ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_succ [CommMonoid R] {x : R} (h : Irreducible x) (n : \u2115) :\n    Squarefree (x ^ (n + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_two [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) :\n    Squarefree (p ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_divides_right [Monoid R] {a b : R} (h : b \u2223 a) (hsq : Squarefree a) :\n    Squarefree b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_two_imp_unit' [Monoid R] {x : R} (h : Squarefree (x ^ 2)) :\n    IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.isUnit_or_small_pow [Monoid R] {x : R} {n : \u2115} (h : Squarefree (x ^ n)) :\n    IsUnit x \u2228 n \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit [CommMonoid R] {u x : R} (hu : IsUnit u) :\n    Squarefree (u * x) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_imp_dvd [Monoid R] {a b : R} {k : \u2115} (ha : Squarefree a) (hk : 0 < k) :\n    a \u2223 b ^ k \u2192 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.squarefree_of_pow_dvd [Monoid R] {a b : R} {k : \u2115} (h : a \u2223 b ^ k)\n    (hsq : Squarefree b) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_iff [Monoid R] {x : R} {k : \u2115} (h : Squarefree x) :\n    (x ^ k \u2223 x) \u2194 (k = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_of_relprime [CommMonoid R] {a b : R}\n    (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) : Squarefree (a * b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.relprime_of_squarefree_mul_pow [CommMonoid R] {a b : R} {n : \u2115}\n    (h : Squarefree (a * b ^ n)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree' [CancelCommMonoidWithZero R] {p x : R}\n    (hp : Prime p) (hx : Squarefree x) : \u00ac p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_mul_left_imp [CommMonoid R] {a b c : R}\n    (hsq : Squarefree a) (h : a \u2223 b * c) : a \u2223 b \u2228 a \u2223 c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_or_not_square [Monoid R] {x y : R} (h : Squarefree x)\n    (hdvd : y ^ 2 \u2223 x) : IsUnit y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.squarefree_mul' [CommMonoid R] {a b : R}\n    (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) : Squarefree (b * a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_le_two [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 x : R, emultiplicity x r \u2264 2 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.eq_zero_or_one_of_pow_three_of_not_isUnit [Monoid R] {x : R} {n : \u2115}\n    (h : Squarefree (x ^ n)) (hunit : \u00ac IsUnit x) : n = 0 \u2228 n \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_three_dvd_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_two [CommMonoid R] {x : R} (h : IsUnit x) :\n    Squarefree (x ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_dvd_mul_left_of_squarefree' [CancelCommMonoidWithZero R] {p x y : R}\n    (hp : Prime p) (hy : Squarefree y) (h : p ^ 2 \u2223 x * y) : p \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_succ_iff [Monoid R] {x y : R} {n : \u2115}\n    (hsq : Squarefree y) (hpos : 0 < n) : x \u2223 y \u2192 x ^ n \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.of_squarefree_mul_left [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_one_pow [CommMonoid R] {x : R}\n    (h : IsUnit x) : Squarefree (x ^ 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_one_mul_one [CommMonoid R] :\n    Squarefree ((1 : R) * 1 * 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_two [CommMonoid R] {x : R} (h : Irreducible x) :\n    Squarefree (x ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_three [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) :\n    Squarefree (p ^ 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_iff_unit_left [CommMonoid R] {u v : R} (hu : IsUnit u) :\n    Squarefree (u * v) \u2194 Squarefree v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_dvd_left' [Monoid R] {m n : R} (h : m \u2223 n) (hs : Squarefree n) :\n    Squarefree m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_two_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 2)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp [Monoid R] {x y : R} {k : \u2115}\n    (hs : Squarefree y) (h : x ^ (k.succ) \u2223 y) : x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_lt_two' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 z : R, emultiplicity z r < 2 \u2228 IsUnit z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_no_irreducible_sq_dvd' {x : R} (hx : x \u2260 0) :\n    Squarefree x \u2194 \u2200 p, Irreducible p \u2192 \u00ac p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem irreducible_sq_not_dvd_or_squarefree' (r : R) :\n    (\u2200 z : R, Irreducible z \u2192 \u00ac z ^ 2 \u2223 r) \u2194 (r = 0 \u2228 Squarefree r) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRadical.squarefree_nonzero' (hx : x \u2260 0) (h : IsRadical x) :\n    Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem pow_two_dvd_of_squarefree_mul_right' (hx : Squarefree x) {p y : R}\n    (hp : Prime p) (h : p ^ 2 \u2223 x * y) : p \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem pow_two_dvd_of_squarefree_mul_left' (hy : Squarefree y) {p x : R}\n    (hp : Prime p) (h : p ^ 2 \u2223 x * y) : p \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_comm_iff' :\n    Squarefree (x * y) \u2194 IsRelPrime x y \u2227 Squarefree x \u2227 Squarefree y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem isRadical_imp_squarefree_or_zero' (h : IsRadical x) :\n    Squarefree x \u2228 x = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem exists_squarefree_dvd_pow_succ_of_ne_zero' {z : R} (hz : z \u2260 0) :\n    \u2203 y : R, \u2203 n : \u2115, Squarefree y \u2227 y \u2223 z \u2227 z \u2223 y ^ (n.succ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_three_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_of_pow_succ_succ_dvd' [Monoid R] {x y : R} {n : \u2115}\n    (hs : Squarefree y) (h : x ^ (n + 2) \u2223 y) : x ^ (n + 1) \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_succ' [CommMonoid R] {x : R} (hu : IsUnit x) (k : \u2115) :\n    Squarefree (x ^ (k + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_succ' [CancelCommMonoidWithZero R] {p : R}\n    (hp : Prime p) (n : \u2115) : Squarefree (p ^ (n + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_two_iff_unit' [Monoid R] {x : R} :\n    Squarefree (x ^ 2) \u2194 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.is_unit_or_le_one_pow [Monoid R] {x : R} {n : \u2115}\n    (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_two_dvd_of_mul' [Monoid R] {x y : R}\n    (hs : Squarefree x) (h : y ^ 2 \u2223 x * y) : y \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.squarefree_mul' [CommMonoid R] {a b : R}\n    (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) :\n    Squarefree (a * b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self' [Monoid R] {x : R} {k : \u2115}\n    (hs : Squarefree x) : x ^ k \u2223 x \u2194 (k = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_or_not_square' [Monoid R] {x : R}\n    (hs : Squarefree x) (y : R) (h : y ^ 2 \u2223 x) : IsUnit y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_of_relprime' [CommMonoid R] {a b : R}\n    (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) :\n    Squarefree (a * b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.isRelPrime_pow_mul' [CommMonoid R] {a b : R} {n : \u2115}\n    (hs : Squarefree (a ^ n * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_pow_mul_left' [Monoid R] {a b : R} {n : \u2115}\n    (hs : Squarefree (a ^ n * b)) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_iff' [CommMonoid R] {u x : R} (hu : IsUnit u) :\n    Squarefree (u * x) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree' [CancelCommMonoidWithZero R] {p x : R}\n    (hp : Prime p) (hs : Squarefree x) : \u00ac p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_iff' [Monoid R] {a b : R} {k : \u2115}\n    (ha : Squarefree a) (hk : k \u2260 0) : a \u2223 b ^ k \u2194 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.eq_unit_of_cube_squarefree' [CommMonoid R] {x : R}\n    (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.squarefree_of_pow_dvd' [Monoid R] {m n : R} {k : \u2115}\n    (h : m \u2223 n ^ k) (hs : Squarefree n) : Squarefree m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_mul_left_iff' [CommMonoid R] {a b c : R}\n    (hs : Squarefree a) : a \u2223 b * c \u2194 (a \u2223 b \u2228 a \u2223 c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_eq_zero_or_one' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 z : R, emultiplicity z r = 0 \u2228 emultiplicity z r = 1 \u2228 IsUnit z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRadical.squarefree_or_zero' (h : IsRadical x) :\n    x = 0 \u2228 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.relprime_of_squarefree_mul_pow' [CommMonoid R] {a b : R} {n : \u2115}\n    (hs : Squarefree (a * b ^ n)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree'' [CancelCommMonoidWithZero R] {p x : R}\n    (hp : Prime p) (hs : Squarefree x) : \u00ac p * p \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_iff' [Monoid R] {x : R} {j : \u2115}\n    (hs : Squarefree x) : (x ^ j \u2223 x) \u2194 (j = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_three_dvd_imp_unit' [Monoid R] {x : R}\n    (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_two' [CommMonoid R] {x : R} (hu : IsUnit x) :\n    Squarefree (x ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_succ_iff' [Monoid R] {x y : R} {n : \u2115}\n    (hs : Squarefree y) (hpos : 0 < n) : x \u2223 y \u2192 x ^ n \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.of_squarefree_mul_comm' [CommMonoid R] {u v : R}\n    (h : Squarefree (u * v)) : IsRelPrime v u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_comm' [CommMonoid R] {x y : R}\n    (hs : Squarefree (x * y)) : Squarefree (y * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_pow' [CommMonoid R] {u : R} (hu : IsUnit u) (n : \u2115) :\n    Squarefree (u ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_two' [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) :\n    Squarefree (p ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_divides_right' [Monoid R] {a b : R} (h : b \u2223 a) (hs : Squarefree a) :\n    Squarefree b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_of_pow_succ_dvd' [Monoid R] {x y : R} {k : \u2115}\n    (hs : Squarefree y) (h : x ^ (k + 1) \u2223 y) : x ^ k \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_of_relprime'' [CommMonoid R] {a b : R}\n    (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) :\n    Squarefree (b * a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_le_one' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 z : R, emultiplicity z r \u2264 1 \u2228 IsUnit z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.eq_unit_of_fourth_power_squarefree [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp_unit_or_dvd' [Monoid R] {x y : R} {n : \u2115}\n    (hs : Squarefree y) (h : x ^ (n + 2) \u2223 y) : IsUnit x \u2228 x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.squarefree_of_pow_dvd'' [Monoid R] {m n : R} {k : \u2115}\n    (h : m \u2223 n ^ k) (hs : Squarefree n) : Squarefree m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_mul_unit' [CommMonoid R] {u x : R}\n    (hu : IsUnit u) (hx : Irreducible x) : Squarefree (x * u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_unit_mul_comm [CommMonoid R] {u x : R} (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree (x * u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_four_imp_unit [Monoid R] {x : R} (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_relprime_swap [CommMonoid R] {a b : R} (h : Squarefree (a * b)) : IsRelPrime b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_or_unit [Monoid R] {x : R} {n : \u2115} (hx : Squarefree x) : x ^ n \u2223 x \u2192 (n = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_comm_iff_left [CommMonoid R] {x y : R} : Squarefree (x * y) \u2194 Squarefree (y * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_four [CommMonoid R] {x : R} (h : Irreducible x) : Squarefree (x ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_three [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) : Squarefree (p ^ 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_imp [Monoid R] {a b : R} {k : \u2115} (ha : Squarefree a) (hk : k \u2260 0) : a \u2223 b ^ k \u2192 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.isUnit_or_le_two_pow [Monoid R] {x : R} {n : \u2115} (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_three [CommMonoid R] {x : R} (hx : IsUnit x) : Squarefree (x ^ 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_pow_mul_right [Monoid R] {a b : R} {n : \u2115} (h : Squarefree (a * b ^ n)) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_iff_left [CommMonoid R] {u x : R} (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp_dvd' [Monoid R] {x y : R} {n : \u2115} (hsq : Squarefree y) (h : x ^ (n.succ) \u2223 y) : x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_le_two' [CommMonoid R] (r : R) : Squarefree r \u2194 \u2200 x : R, emultiplicity x r \u2264 2 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_or_not_sq [Monoid R] {x y : R} (h : Squarefree x) (hy : y * y \u2223 x) : IsUnit y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_le [Monoid R] {x : R} {k : \u2115} (hx : Squarefree x) (h : x ^ k \u2223 x) : k = 0 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_left_unit_iff [CommMonoid R] {u v : R} (hu : IsUnit u) : Squarefree (u * v) \u2194 Squarefree v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_four [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) : Squarefree (p ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_symm_imp_relprime [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_imp [CommMonoid R] {u x : R} (hu : IsUnit u)\n    (h : Squarefree (u * x)) : Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem unit_squarefree_pow [CommMonoid R] {x : R} (hx : IsUnit x) {n : \u2115}\n    : Squarefree (x ^ (n + 2)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_one_mul_one' [CommMonoid R] : Squarefree ((1 : R) * 1 * 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_zero_false' [MonoidWithZero R] [Nontrivial R] : Squarefree (0 : R) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem irreducible_squarefree_pow_four [CommMonoid R] {x : R} (hx : Irreducible x)\n    : Squarefree (x ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_squarefree_pow_four [CancelCommMonoidWithZero R] {p : R} (hp : Prime p)\n    : Squarefree (p ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_iff_right [CommMonoid R] {u x : R} (hu : IsUnit u)\n    : Squarefree (x * u) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_of_relprime' [CommMonoid R] {a b : R}\n    (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) : Squarefree (b * a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_two_iff_unit'' [Monoid R] {x : R}\n    : Squarefree (x ^ 2) \u2194 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_three_imp_unit' [Monoid R] {x : R}\n    (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_four_imp_unit' [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_dvd_pow_imp' [Monoid R] {a b : R} {k : \u2115}\n    (ha : Squarefree a) (hk : 0 < k) : (a \u2223 b ^ k) \u2192 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_dvd_self_or_unit [Monoid R] {x : R} {n : \u2115}\n    (hx : Squarefree x) : (x ^ n \u2223 x) \u2192 (n = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_dvd_mul_left_or_right [CommMonoid R] {a b c : R}\n    (ha : Squarefree a) : a \u2223 b * c \u2192 (a \u2223 b \u2228 a \u2223 c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem emultiplicity_squarefree_lt_two [CommMonoid R] (r : R)\n    : Squarefree r \u2194 \u2200 x : R, emultiplicity x r < 2 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem emultiplicity_squarefree_le_one [CommMonoid R] (r : R)\n    : Squarefree r \u2194 \u2200 x : R, emultiplicity x r \u2264 1 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_isRadical_or_zero [CommMonoidWithZero R]\n    (h : IsRadical x) : Squarefree x \u2228 x = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem radical_squarefree_of_ne_zero [CommMonoidWithZero R]\n    (hx : x \u2260 0) (h : IsRadical x) : Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_unit_pow_any [CommMonoid R] {u : R} (hu : IsUnit u) (n : \u2115)\n    : Squarefree (u ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_comm_iff' [CommMonoid R] {x y : R}\n    : Squarefree (y * x) \u2194 IsRelPrime x y \u2227 Squarefree x \u2227 Squarefree y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_of_pow_mul_right [Monoid R] {a b : R} {n : \u2115}\n    (h : Squarefree (a * b ^ n)) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_relprime_pow_mul [CommMonoid R] {a b : R} {n : \u2115}\n    (h : Squarefree (a ^ n * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree'' [CancelCommMonoidWithZero R]\n    {p x : R} (hp : Prime p) (hx : Squarefree x) : \u00ac p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_unit_or_small_pow' [Monoid R] {x : R} {n : \u2115}\n    (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_succ_dvd_imp [Monoid R] {x y : R} {n : \u2115}\n    (hsq : Squarefree y) (h : x ^ (n.succ) \u2223 y) : x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_iff_left [CommMonoid R] {u x : R} (hu : IsUnit u)\n    : Squarefree (u * x) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_of_divides_left [Monoid R] {a b : R}\n    (h : b \u2223 a) (hsq : Squarefree a) : Squarefree b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_unit_pow_two [CommMonoid R] {x : R} (hx : IsUnit x)\n    : Squarefree (x ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_flip_imp_relprime [CommMonoid R] {m n : R} (h : Squarefree (m * n)) : IsRelPrime n m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_zero [CommMonoid R] {x : R} (h : IsUnit x) : Squarefree (x ^ 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_unit_left_iff' [CommMonoid R] {u v : R} (hu : IsUnit u) : Squarefree (u * v) \u2194 Squarefree v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_four_dvd_imp_unit [Monoid R] {x : R} (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_five_imp_unit [Monoid R] {x : R} (h : Squarefree (x ^ 5)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_comm_iff [CommMonoid R] {u x : R} (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree (x * u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_of_relprime'' [CommMonoid R] {a b : R} (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) : Squarefree (b * a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_or_unit' [Monoid R] {x : R} {n : \u2115} (hx : Squarefree x) : x ^ n \u2223 x \u2192 (n = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.is_unit_or_le_two_pow [Monoid R] {x : R} {n : \u2115} (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_two_mul_imp_unit' [CommMonoid R] {x : R} (h : Squarefree (x * x)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_six_imp_unit [Monoid R] {x : R} (h : Squarefree (x ^ 6)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_mul_left_imp' [CommMonoid R] {a b c : R} (hsq : Squarefree a) (h : a \u2223 b * c) : a \u2223 b \u2228 a \u2223 c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_comm_iff_right [CommMonoid R] {x y : R} : Squarefree (y * x) \u2194 IsRelPrime x y \u2227 Squarefree x \u2227 Squarefree y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.of_squarefree_mul_flip [CommMonoid R] {a b : R} (h : Squarefree (a * b)) : IsRelPrime b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_three_imp_unit'' [Monoid R] {x : R} (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp_dvd'' [Monoid R] {x y : R} {n : \u2115} (hq : Squarefree y) (h : x ^ (n.succ) \u2223 y) : x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_pow_any [CommMonoid R] {u : R} (hu : IsUnit u) (n : \u2115) : Squarefree (u ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree''' [CancelCommMonoidWithZero R] {p x : R} (hp : Prime p) (hx : Squarefree x) : \u00ac p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_dvd_pow_imp'' [Monoid R] {a b : R} {k : \u2115} (ha : Squarefree a) (hk : 0 < k) : a \u2223 b ^ k \u2192 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_seven_imp_unit [Monoid R] {x : R} (h : Squarefree (x ^ 7)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_imp_relprime_left [CommMonoid R] {m n : R}\n    (h : Squarefree (m * n)) : IsRelPrime m n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_succ [CommMonoid R] {x : R} (h : IsUnit x) (k : \u2115) :\n    Squarefree (x ^ (k + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_one [CommMonoid R] : Squarefree (1 * (1 : R)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_zero_false' [MonoidWithZero R] [Nontrivial R] :\n    Squarefree (0 : R) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_succ [CommMonoid R] {x : R} (h : Irreducible x) (n : \u2115) :\n    Squarefree (x ^ (n.succ)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_two [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) :\n    Squarefree (p ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_right_iff_unit [CommMonoid R] {m n : R} (hu : IsUnit n) :\n    Squarefree (m * n) \u2194 Squarefree m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_dvd_left [Monoid R] {x y : R} (hxy : y \u2223 x) :\n    Squarefree x \u2192 Squarefree y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_three_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp_unit_or_dvd [Monoid R] {x y : R} {n : \u2115}\n    (hsq : Squarefree y) (h : x ^ (n.succ.succ) \u2223 y) : IsUnit x \u2228 x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_lt_two' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 x : R, emultiplicity x r < 2 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_no_irreducible_sq_dvd' {x : R} (hx : x \u2260 0) :\n    Squarefree x \u2194 \u2200 p, Irreducible p \u2192 \u00ac (p ^ 2 \u2223 x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_iff_dvd_succ {x y : R} {n : \u2115}\n    (hsq : Squarefree x) (h : 0 < n) : x \u2223 y ^ n \u2194 x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self [Monoid R] {x : R} {k : \u2115}\n    (hsq : Squarefree x) : x ^ k \u2223 x \u2192 (k = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_comm_iff_left [CommMonoid R] {x y : R} :\n    Squarefree (x * y) \u2194 Squarefree (y * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree [CancelCommMonoidWithZero R] {p x : R}\n    (hp : Prime p) (hx : Squarefree x) : \u00ac p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.relprime_of_squarefree_mul_pow [CommMonoid R] {a b : R} {n : \u2115}\n    (h : Squarefree (a * b ^ n)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_pow [CommMonoid R] {u : R} (hu : IsUnit u) (n : \u2115) :\n    Squarefree (u ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_mul_left_iff' [CommMonoid R] {a b c : R} (hsq : Squarefree a) :\n    a \u2223 b * c \u2194 a \u2223 b \u2228 a \u2223 c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_flip_imp_relprime [CommMonoid R] {m n : R}\n    (h : Squarefree (m * n)) : IsRelPrime n m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_zero [CommMonoid R] {x : R}\n    (h : IsUnit x) : Squarefree (x ^ 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_unit_mul_left [CommMonoid R] {u x : R}\n    (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_mul_unit_left [CommMonoid R] {u x : R}\n    (hu : IsUnit u) (h : Squarefree (u * x)) : Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_self_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x * x)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_succ_imp [Monoid R] {x y : R} {n : \u2115}\n    (hsq : Squarefree y) (h : x ^ (n + 1) \u2223 y) : x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.isUnit_or_le_two_pow [Monoid R] {x : R} {n : \u2115}\n    (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_comm_iff [CommMonoid R] {u x : R}\n    (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree (x * u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_four_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_swap_imp_relprime [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_zero [CommMonoid R] {x : R}\n    (h : IsUnit x) : Squarefree (x ^ 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_succ' [CommMonoid R] {x : R} (h : Irreducible x) (n : \u2115) :\n    Squarefree (x ^ (n.succ)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_succ' [CancelCommMonoidWithZero R] {p : R} (h : Prime p) (n : \u2115) :\n    Squarefree (p ^ (n.succ)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_iff_unit_right [CommMonoid R] {m n : R} (hu : IsUnit n) :\n    Squarefree (m * n) \u2194 Squarefree m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.squarefree_of_dvd_left [Monoid R] {x y : R}\n    (hdvd : y \u2223 x) (h : Squarefree x) : Squarefree y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_four_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp_dvd_left [Monoid R] {x y : R} {n : \u2115}\n    (hs : Squarefree y) (h : x ^ (n.succ) \u2223 y) : x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_le_one' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 x : R, emultiplicity x r \u2264 1 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_no_irreducible_pow_two_dvd [CommMonoidWithZero R] {x : R}\n    (hx : x \u2260 0) : Squarefree x \u2194 \u2200 p, Irreducible p \u2192 \u00ac (p ^ 2 \u2223 x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem irreducible_pow_two_not_dvd_or_squarefree [CommMonoidWithZero R] (r : R) :\n    (\u2200 x : R, Irreducible x \u2192 \u00ac x ^ 2 \u2223 r) \u2228 Squarefree r := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_succ_iff_dvd [Monoid R] {a b : R} {n : \u2115}\n    (ha : Squarefree a) (hn : n \u2260 0) : a \u2223 b ^ n \u2194 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_five_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 5)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_of_pow_succ_dvd [Monoid R] {x y : R} {n : \u2115}\n    (hxy : x ^ (n.succ) \u2223 y) (hsq : Squarefree y) : x ^ n \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_twiceSucc [CommMonoid R] {x : R} (h : IsUnit x) (n : \u2115) :\n    Squarefree (x ^ (n.succ.succ)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_twiceSucc [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) (n : \u2115) :\n    Squarefree (p ^ (n.succ.succ)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_iff' [Monoid R] {x : R} {k : \u2115}\n    (hsq : Squarefree x) : (x ^ k \u2223 x) \u2194 (k = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.is_unit_or_pow_le_one [Monoid R] {x : R} {n : \u2115}\n    (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_left_imp_relprime [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_right_imp_relprime [CommMonoid R] {a b : R}\n    (h : Squarefree (b * a)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_zero [CommMonoid R] {x : R}\n    (h : IsUnit x) : Squarefree (x ^ 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_four [CommMonoid R] {x : R}\n    (h : IsUnit x) : Squarefree (x ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_two [CommMonoid R] {x : R}\n    (h : Irreducible x) : Squarefree (x ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_four_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_five_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 5)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_four [CancelCommMonoidWithZero R] {p : R}\n    (hp : Prime p) : Squarefree (p ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_one_mul_one [CommMonoid R] :\n    Squarefree ((1 : R) * 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_dvd_left [Monoid R] {a b : R}\n    (hab : b \u2223 a) (h : Squarefree a) : Squarefree b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_two_dvd_of_mul_right [Monoid R] {x y : R}\n    (hx : Squarefree x) (h : y ^ 2 \u2223 x * y) : y \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.is_unit_or_small_pow [Monoid R] {x : R} {n : \u2115}\n    (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_imp_relprime_comm [CommMonoid R] {m n : R}\n    (h : Squarefree (m * n)) : IsRelPrime m n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_symmetric [CommMonoid R] {x : R} (h : IsUnit x) (k : \u2115) :\n    Squarefree (x ^ k.succ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_zero_false' [MonoidWithZero R] [Nontrivial R] : (Squarefree (0 : R)) = False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Irreducible.squarefree_pow_pred [CommMonoid R] {x : R} (h : Irreducible x) (n : \u2115) :\n    Squarefree (x ^ (n + 2)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_pred [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) (n : \u2115) :\n    Squarefree (p ^ (n + 2)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_left_unit_iff' [CommMonoid R] {u v : R} (hu : IsUnit u) :\n    Squarefree (u * v) \u2194 Squarefree v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_dvd_right [Monoid R] {x y : R} (hdvd : y \u2223 x) :\n    Squarefree x \u2192 Squarefree y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_two_unit'' [Monoid R] {x : R} (h : Squarefree (x ^ 2)) :\n    IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_succ_dvd_imp_relprime [Monoid R] {x y : R} {n : \u2115}\n    (hsq : Squarefree y) (h : x ^ (n + 2) \u2223 y) : IsUnit x \u2228 x \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_le_one'' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 a : R, emultiplicity a r \u2264 1 \u2228 IsUnit a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_no_irreducible_sq_dvd'' {x : R} (hx : x \u2260 0) :\n    Squarefree x \u2194 \u2200 p, Irreducible p \u2192 \u00ac (p ^ 2 \u2223 x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_equiv [Monoid R] {a b : R} {n : \u2115}\n    (ha : Squarefree a) (hn : n \u2260 0) : a \u2223 b ^ n \u2194 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRadical.squarefree_or_zero'' (h : IsRadical x) : Squarefree x \u2228 x = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_of_relprime'' [CommMonoid R] {a b : R}\n    (hrel : IsRelPrime a b) (ha : Squarefree a) (hb : Squarefree b) :\n    Squarefree (a * b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.isRelPrime_pow_mul'' [CommMonoid R] {a b : R} {k : \u2115}\n    (h : Squarefree (a ^ (k + 1) * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_or_unit'' [Monoid R] {x : R} {n : \u2115}\n    (hx : Squarefree x) : x ^ n \u2223 x \u2192 (n = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_or_not_square'' [Monoid R] {x y : R}\n    (hsq : Squarefree x) (h : y ^ 2 \u2223 x) : IsUnit y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_two'' [CancelCommMonoidWithZero R] {p : R} (hp : Prime p) :\n    Squarefree (p ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.eq_unit_of_fourth_power_squarefree'' [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_imp_relprime_left' [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_imp_relprime_right' [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_zero' [CommMonoid R] {x : R}\n    (hx : IsUnit x) : Squarefree (x ^ 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_two'' [CommMonoid R] {x : R}\n    (hx : IsUnit x) : Squarefree (x ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_three'' [CommMonoid R] {x : R}\n    (hx : IsUnit x) : Squarefree (x ^ 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_four_dvd_self [Monoid R] {x : R}\n    (hsq : Squarefree x) : x ^ 4 \u2223 x \u2194 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_five_imp_unit'' [Monoid R] {x : R}\n    (h : Squarefree (x ^ 5)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_six_imp_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 6)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_seven_imp_unit'' [Monoid R] {x : R}\n    (h : Squarefree (x ^ 7)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_unit_left_iff [CommMonoid R] {u v : R}\n    (hu : IsUnit u) : Squarefree (u * v) \u2194 Squarefree v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_unit_right_iff [CommMonoid R] {u v : R}\n    (hu : IsUnit u) : Squarefree (v * u) \u2194 Squarefree v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_comm_iff_left' [CommMonoid R] {x y : R} :\n    Squarefree (x * y) \u2194 Squarefree (y * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_iff_dvd_two [Monoid R] {a b : R}\n    (ha : Squarefree a) : a \u2223 b ^ 2 \u2194 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_pow_two_imp_dvd [Monoid R] {a b : R}\n    (ha : Squarefree a) : a \u2223 b ^ 2 \u2192 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem prime_sq_not_dvd_squarefree''' [CancelCommMonoidWithZero R] {p x : R}\n    (hp : Prime p) (hx : Squarefree x) : \u00ac p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_dvd_pow [Monoid R] {a b : R} {n : \u2115}\n    (h : a \u2223 b ^ n) (hsq : Squarefree b) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_zero_or_unit [Monoid R] {x : R} {n : \u2115}\n    (hsq : Squarefree x) : x ^ n \u2223 x \u2192 (n = 0 \u2228 IsUnit x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_or_small_pow' [Monoid R] {x : R} {n : \u2115}\n    (h : Squarefree (x ^ n)) : IsUnit x \u2228 n \u2264 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_mul_imp [CommMonoid R] {a b c : R}\n    (hsq : Squarefree a) : a \u2223 b * c \u2192 a \u2223 b \u2228 a \u2223 c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_le_one'' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 x : R, emultiplicity x r \u2264 1 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_lt_two'' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 x : R, emultiplicity x r < 2 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_of_pow_succ_dvd'' [Monoid R] {x y : R} {n : \u2115}\n    (h : x ^ (n + 1) \u2223 y) (hsq : Squarefree y) : x ^ n \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.eq_unit_of_fourth_power_squarefree'' [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.relprime_of_mul_squarefree [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.squarefree_mul_comm [CommMonoid R] {x y : R}\n    (h : Squarefree (x * y)) : Squarefree (y * x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_imp_relprime_left' [CommMonoid R] {a b : R}\n    (hsq : Squarefree (a * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_unit_mul_left_iff [CommMonoid R] {u x : R}\n    (hu : IsUnit u) : Squarefree (x * u) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_two_implies_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 2)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_of_pow_mul_right' [Monoid R] {a b : R} {n : \u2115}\n    (h : Squarefree (a * b ^ n)) : Squarefree b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem isRelPrime_of_squarefree_mul_pow [CommMonoid R] {a b : R} {k : \u2115}\n    (h : Squarefree (a ^ k.succ * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_unit_comm_iff' [CommMonoid R] {u x : R}\n    (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree (x * u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_pow_three_implies_unit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 3)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_of_dvd_pow' [Monoid R] {a b : R} {n : \u2115}\n    (hdvd : a \u2223 b ^ n) (h : Squarefree b) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_mul_iff_relprime_and_factors [CommMonoid R] {a b : R}\n    : Squarefree (a * b) \u2194 IsRelPrime a b \u2227 Squarefree a \u2227 Squarefree b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem squarefree_iff_emultiplicity_le_one' [CommMonoid R] (r : R) :\n    Squarefree r \u2194 \u2200 x : R, emultiplicity x r \u2264 1 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_mul_comm_left [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : Squarefree (b * a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.mul_left_cancel [CommMonoid R] {a b c : R}\n    (h : Squarefree (a * b * c)) : Squarefree (b * c * a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_four_imp_isUnit [Monoid R] {x : R}\n    (h : Squarefree (x ^ 4)) : IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsUnit.squarefree_pow_any [CommMonoid R] {x : R}\n    (h : IsUnit x) (n : \u2115) : Squarefree (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.dvd_mul_iff_left [CommMonoid R] {a b c : R}\n    (hsq : Squarefree a) : a \u2223 b * c \u2194 a \u2223 b \u2228 a \u2223 c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.pow_dvd_self_only_unit [Monoid R] {x : R} {k : \u2115}\n    (h : Squarefree x) (hk : x ^ k \u2223 x) : k = 0 \u2228 IsUnit x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem IsRelPrime.of_squarefree_mul_left [CommMonoid R] {a b : R}\n    (h : Squarefree (a * b)) : IsRelPrime a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Prime.squarefree_pow_one [CancelCommMonoidWithZero R] {p : R}\n    (hp : Prime p) : Squarefree p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.unit_mul_iff [CommMonoid R] {u x : R}\n    (hu : IsUnit u) : Squarefree (u * x) \u2194 Squarefree x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R : Type*}\nvariable {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\nvariable [CommMonoidWithZero R] [WfDvdMonoid R]\nvariable [CommMonoidWithZero R] [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] {x y p d : R}\nvariable [DecompositionMonoid R]\nvariable [CancelCommMonoidWithZero R] [UniqueFactorizationMonoid R]\n\n\ntheorem Squarefree.of_pow_mul_right [Monoid R] {a b : R} {n : \u2115}\n    (h : Squarefree (a * b ^ n)) : Squarefree a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem map_prime {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    {G : Type*} [FunLike G N M] [MulHomClass G N M]\n    (f : F) (g : G) {p : M}\n    (hinv : \u2200 a : M, g (f a) = a) (hp : Prime p) : Prime (f p) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem Prime.left_dvd_or_dvd_right_of_dvd_mul' [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) : a \u2223 b * p \u2192 p \u2223 a \u2228 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem Prime.pow_succ_dvd_of_dvd_mul_left [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) (n : \u2115) (h : \u00ac p \u2223 a) (h' : p ^ (n + 1) \u2223 a * b) :\n    p ^ (n + 1) \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem Prime.pow_succ_dvd_of_dvd_mul_right [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) (n : \u2115) (h : \u00ac p \u2223 b) (h' : p ^ (n + 1) \u2223 a * b) :\n    p ^ (n + 1) \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem Prime.dvd_of_pow_succ_dvd_pow_mul_pow_of_not_square_left [CancelCommMonoidWithZero M]\n    {p a b : M} {n : \u2115} (hp : Prime p)\n    (hpow : p ^ (n + 2) \u2223 a ^ (n + 1) * b ^ (n + 1)) (ha : \u00ac p ^ 2 \u2223 a) : p \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem prime_pow_two_dvd_mul {M : Type*} [CancelCommMonoidWithZero M] {p x y : M} (h : Prime p)\n    {i : \u2115} (hxy : p ^ (i + 2) \u2223 x * y) : p ^ (i + 2) \u2223 x \u2228 p ^ 2 \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem not_irreducible_pow_of_two_le {M} [Monoid M] {x : M} {n : \u2115} (hn : 2 \u2264 n) :\n    \u00ac Irreducible (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem irreducible_units_mul_units [Monoid M] (a b : M\u02e3) (c : M) :\n    Irreducible (\u2191a * c * \u2191b) \u2194 Irreducible c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem Irreducible.not_cube [CommMonoid M] {a : M} (ha : Irreducible a) :\n    \u00ac \u2203 b : M, a = b ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem IsSquare.not_prime' [CancelCommMonoidWithZero M] {a : M} (ha : IsSquare a) :\n    \u00ac Prime a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem succ_dvd_or_succ_dvd_of_sum_succ_dvd_mul [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) {k l : \u2115} :\n    p ^ k \u2223 a \u2192 p ^ l \u2223 b \u2192 p ^ (k + l + 2) \u2223 a * b \u2192\n    p ^ (k + 2) \u2223 a \u2228 p ^ (l + 2) \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem Prime.not_cube [CancelCommMonoidWithZero M] {p : M} (hp : Prime p) :\n    \u00ac \u2203 b : M, p = b ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem not_prime_pow_two_or_more [CancelCommMonoidWithZero M] {a : M} {n : \u2115} (hn : 2 \u2264 n) :\n    \u00ac Prime (a ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem DvdNotUnit.isUnit_of_irreducible_left [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) (hp : Irreducible p) : IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem not_irreducible_of_not_unit_dvdNotUnit_left [CommMonoidWithZero M] {p q : M}\n    (hq : \u00ac IsUnit q) (h : DvdNotUnit p q) : \u00ac Irreducible p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem DvdNotUnit.not_unit_left [CommMonoidWithZero M] {p q : M} (hp : DvdNotUnit p q) :\n    \u00ac IsUnit p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem DvdNotUnit.ne' [CancelCommMonoidWithZero M] {p q : M} (h : DvdNotUnit p q) :\n    q \u2260 p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem pow_injective_of_not_isUnit' [CancelCommMonoidWithZero M] {q : M} (hq : \u00ac IsUnit q)\n    (hq0 : q \u2260 0) : Function.Injective fun n : \u2115 => q ^ (n.succ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\n\ntheorem pow_eq_iff_of_not_isUnit [CancelCommMonoidWithZero M] {q : M} (hq : \u00ac IsUnit q)\n    (hq0 : q \u2260 0) {m n : \u2115} : q ^ (m + 1) = q ^ (n + 1) \u2194 m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem comap_irreducible {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    {G : Type*} [FunLike G N M] [MulHomClass G N M]\n    (f : F) (g : G) {p : M}\n    (hinv : \u2200 a : M, g (f a) = a) (hp : Irreducible (f p)) : Irreducible p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_of_pow_succ_dvd_pow_mul_pow_of_not_square_right [CancelCommMonoidWithZero M]\n    {p a b : M} {n : \u2115} (hp : Prime p)\n    (hpow : p ^ (n + 2) \u2223 a ^ (n + 1) * b ^ (n + 1)) (hb : \u00ac p ^ 2 \u2223 b) :\n    p \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem prime_pow_three_dvd_mul {M : Type*} [CancelCommMonoidWithZero M] {p x y : M}\n    (h : Prime p) {i : \u2115} (hxy : p ^ (i + 3) \u2223 x * y) :\n    p ^ (i + 3) \u2223 x \u2228 p ^ 3 \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_pow_of_three_le [Monoid M] {x : M} {n : \u2115}\n    (hn : 3 \u2264 n) : \u00ac Irreducible (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_units_mul_units' [Monoid M] (a b : M\u02e3) (c d : M) :\n    Irreducible (\u2191a * c * d * \u2191b) \u2194 Irreducible (c * d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_fourth_power [CommMonoid M] {a : M}\n    (ha : Irreducible a) : \u00ac \u2203 b : M, a = b ^ 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem succ_dvd_or_succ_dvd_of_sum_succ_succ_dvd_mul [CancelCommMonoidWithZero M]\n    {p a b : M} (hp : Prime p) {k l : \u2115} :\n    p ^ k \u2223 a \u2192 p ^ l \u2223 b \u2192 p ^ (k + l + 3) \u2223 a * b \u2192\n    p ^ (k + 3) \u2223 a \u2228 p ^ (l + 3) \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_fourth_power [CancelCommMonoidWithZero M] {p : M}\n    (hp : Prime p) : \u00ac \u2203 b : M, p = b ^ 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_prime_pow_three_or_more [CancelCommMonoidWithZero M] {a : M} {n : \u2115}\n    (hn : 3 \u2264 n) : \u00ac Prime (a ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_injective_of_not_isUnit'' [CancelCommMonoidWithZero M] {q : M}\n    (hq : \u00ac IsUnit q) (hq0 : q \u2260 0) :\n    Function.Injective fun n : \u2115 => q ^ (n + 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_eq_iff_of_not_isUnit' [CancelCommMonoidWithZero M] {q : M}\n    (hq : \u00ac IsUnit q) (hq0 : q \u2260 0) {m n : \u2115} :\n    q ^ (m + 2) = q ^ (n + 2) \u2194 m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem map_prime_rev {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    {G : Type*} [FunLike G N M] [MulHomClass G N M]\n    (f : F) (g : G) {q : N}\n    (hinv : \u2200 a : N, f (g a) = a) (hq : Prime q) : Prime (g q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.left_dvd_or_dvd_left_of_dvd_mul [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) : a \u2223 b * p \u2192 p \u2223 b \u2228 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_of_pow_succ_dvd_pow_mul_pow_of_not_square_left' [CancelCommMonoidWithZero M]\n    {p a b : M} {n : \u2115} (hp : Prime p)\n    (hpow : p ^ (n + 3) \u2223 a ^ (n + 2) * b ^ (n + 1)) (ha : \u00ac p ^ 2 \u2223 a) : p \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem prime_pow_three_dvd_mul {M : Type*} [CancelCommMonoidWithZero M] {p x y : M} (h : Prime p)\n    {i : \u2115} (hxy : p ^ (i + 3) \u2223 x * y) : p ^ (i + 3) \u2223 x \u2228 p ^ 3 \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_units_mul_units_left [Monoid M] (a b : M\u02e3) (c : M) :\n    Irreducible (\u2191a * \u2191b * c) \u2194 Irreducible c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem succ_dvd_or_succ_dvd_of_sum_succ_dvd_mul' [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) {k l : \u2115} :\n    p ^ k \u2223 a \u2192 p ^ l \u2223 b \u2192 p ^ (k + l + 2) \u2223 a * b \u2192\n    p ^ (k + 1) \u2223 a \u2228 p ^ (l + 1) \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem prime_pow_four_dvd_mul {M : Type*} [CancelCommMonoidWithZero M] {p x y : M}\n    (h : Prime p) {i : \u2115} (hxy : p ^ (i + 4) \u2223 x * y) :\n    p ^ (i + 4) \u2223 x \u2228 p ^ 4 \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_units_mul_units'' [Monoid M] (a b : M\u02e3) (c d : M) :\n    Irreducible (\u2191a * c * \u2191b * d) \u2194 Irreducible (c * d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem succ_dvd_or_succ_dvd_of_sum_succ_succ_dvd_mul' [CancelCommMonoidWithZero M]\n    {p a b : M} (hp : Prime p) {k l : \u2115} :\n    p ^ k \u2223 a \u2192 p ^ l \u2223 b \u2192 p ^ (k + l + 3) \u2223 a * b \u2192\n    p ^ (k + 2) \u2223 a \u2228 p ^ (l + 2) \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_injective_of_not_isUnit_add_two [CancelCommMonoidWithZero M] {q : M}\n    (hq : \u00ac IsUnit q) (hq0 : q \u2260 0) : Function.Injective fun n : \u2115 => q ^ (n + 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_eq_iff_of_not_isUnit_add_two [CancelCommMonoidWithZero M] {q : M}\n    (hq : \u00ac IsUnit q) (hq0 : q \u2260 0) {m n : \u2115} :\n    q ^ (m + 3) = q ^ (n + 3) \u2194 m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem map_prime_comp {M N P : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    [CommMonoidWithZero P] {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    {G : Type*} [FunLike G N P] [MonoidWithZeroHomClass G N P] {H : Type*}\n    [FunLike H P M] [MulHomClass H P M] (f : F) (g : G) (h : H) {p : M}\n    (hinv : \u2200 a : M, h (g (f a)) = a) (hp : Prime p) : Prime (g (f p)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_units_mul_units_left [Monoid M] (u v : M\u02e3) (c : M) :\n    Irreducible (\u2191u * \u2191v * c) \u2194 Irreducible c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_fifth_power [CommMonoid M] {a : M}\n    (ha : Irreducible a) : \u00ac \u2203 b : M, a = b ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_fifth_power [CancelCommMonoidWithZero M] {p : M} (hp : Prime p) :\n    \u00ac \u2203 b : M, p = b ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_prime_pow_four_or_more [CancelCommMonoidWithZero M] {a : M} {n : \u2115}\n    (hn : 4 \u2264 n) : \u00ac Prime (a ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.isUnit_of_irreducible_both [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) (hp : Irreducible p) (hq : Irreducible q) : IsUnit p \u2227 IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_of_not_unit_dvdNotUnit_right [CommMonoidWithZero M] {p q : M}\n    (hp : \u00ac IsUnit p) (h : DvdNotUnit p q) : \u00ac Irreducible q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem comap_irreducible_rev {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    {G : Type*} [FunLike G N M] [MulHomClass G N M] (f : F) (g : G) {p : M}\n    (hinv : \u2200 a : N, f (g a) = a) (hp : Irreducible p) : Irreducible (f p) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_pow_of_four_le [Monoid M] {x : M} {n : \u2115}\n    (hn : 4 \u2264 n) : \u00ac Irreducible (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_units_mul_units_right [Monoid M] (u v : M\u02e3) (c : M) :\n    Irreducible (c * \u2191u * \u2191v) \u2194 Irreducible c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_sixth_power [CommMonoid M] {a : M}\n    (ha : Irreducible a) : \u00ac \u2203 b : M, a = b ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem succ_dvd_or_succ_dvd_of_sum_succ_succ_succ_dvd_mul\n    [CancelCommMonoidWithZero M] {p a b : M} (hp : Prime p) {k l : \u2115} :\n    p ^ k \u2223 a \u2192 p ^ l \u2223 b \u2192 p ^ (k + l + 4) \u2223 a * b \u2192\n    p ^ (k + 4) \u2223 a \u2228 p ^ (l + 4) \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_sixth_power [CancelCommMonoidWithZero M] {p : M} (hp : Prime p) :\n    \u00ac \u2203 b : M, p = b ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_prime_pow_four_or_more' [CancelCommMonoidWithZero M] {a : M} {n : \u2115}\n    (hn : 4 \u2264 n) : \u00ac Prime (a ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.left_dvd_or_dvd_left_of_dvd_mul' [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) : a \u2223 p * b \u2192 p \u2223 a \u2228 p \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem prime_pow_five_dvd_mul {M : Type*} [CancelCommMonoidWithZero M] {p x y : M}\n    (hp : Prime p) {i : \u2115} (hxy : p ^ (i + 5) \u2223 x * y) :\n    p ^ (i + 5) \u2223 x \u2228 p ^ 5 \u2223 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_fifth_power [CommMonoid M] {a : M} (ha : Irreducible a) : \u00ac \u2203 b : M, a = b ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_injective_of_not_isUnit_add_three [CancelCommMonoidWithZero M] {q : M} (hq : \u00ac IsUnit q) (hq0 : q \u2260 0) : Function.Injective fun n : \u2115 => q ^ (n + 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_eq_iff_of_not_isUnit_add_three [CancelCommMonoidWithZero M] {q : M} (hq : \u00ac IsUnit q) (hq0 : q \u2260 0) {m n : \u2115} : q ^ (m + 4) = q ^ (n + 4) \u2194 m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem map_prime_comp' {M N P : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N] [CommMonoidWithZero P] {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N] {G : Type*} [FunLike G N P] [MonoidWithZeroHomClass G N P] (f : F) (g : G) {p : M} (hp : Prime p) : Prime (g (f p)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem comap_irreducible_rev' {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N] {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N] {G : Type*} [FunLike G N M] [MulHomClass G N M] (f : F) (g : G) {q : N} (hq : Irreducible q) (hfg : \u2200 b : N, f (g b) = b) : Irreducible (g q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_sixth_power [CommMonoid M] {a : M} (ha : Irreducible a) : \u00ac \u2203 b : M, a = b ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem map_prime_twice {M N P : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N] [CommMonoidWithZero P] {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N] {G : Type*} [FunLike G N P] [MonoidWithZeroHomClass G N P] {p : M} (f : F) (g : G) (hp : Prime p) : Prime (g (f p)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_left_or_dvd_right_of_dvd_mul [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) : a \u2223 p * b \u2192 p \u2223 a \u2228 a \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_square_of_prime [CancelCommMonoidWithZero M] {p : M}\n    (hp : Prime p) : \u00ac IsSquare p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_mul_unit_left [Monoid M] {a b : M} (h : IsUnit a) :\n    Irreducible (a * b) \u2194 Irreducible b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_mul_unit_right [Monoid M] {a b : M} (h : IsUnit b) :\n    Irreducible (a * b) \u2194 Irreducible a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_square' [CommMonoid M] {a : M} (ha : Irreducible a) :\n    \u00ac \u2203 b : M, a = b ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem IsSquare.not_irreducible' [CommMonoid M] {a : M} (ha : IsSquare a) :\n    \u00ac Irreducible a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_eq_of_not_unit [CancelCommMonoidWithZero M] {q : M} (hunit : \u00ac IsUnit q)\n    (h0 : q \u2260 0) {m n : \u2115} : q ^ m = q ^ n \u2192 m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_of_pow_dvd_mul_pow [CancelCommMonoidWithZero M] {p a b : M} {n : \u2115}\n    (hp : Prime p) (h : p ^ (n.succ) \u2223 a * b) : p ^ (n.succ) \u2223 a \u2228 p \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem succ_dvd_or_succ_dvd_of_sum_dvd_mul [CancelCommMonoidWithZero M] {p a b : M} {k l : \u2115}\n    (hp : Prime p) :\n    p ^ k \u2223 a \u2192 p ^ l \u2223 b \u2192 p ^ (k + l + 1) \u2223 a * b \u2192\n    p ^ (k + 1) \u2223 a \u2228 p ^ (l + 1) \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.not_unit_right [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) : \u00ac IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.pow_two_dvd_of_dvd_mul [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) (h : p ^ 2 \u2223 a * b) : p ^ 2 \u2223 a \u2228 p ^ 2 \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.right_dvd_or_dvd_left_of_dvd_mul [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) : a \u2223 b * p \u2192 p \u2223 b \u2228 a \u2223 p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_of_pow_succ_dvd_pow_mul_pow_of_not_square [CancelCommMonoidWithZero M]\n    {p a b : M} {n : \u2115} (hp : Prime p)\n    (hpow : p ^ (n + 3) \u2223 a ^ (n + 2) * b ^ (n + 1)) (hnb : \u00ac p ^ 2 \u2223 b) : p \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_unit_mul_units [Monoid M] (u : M\u02e3) (b : M) :\n    Irreducible (\u2191u * b) \u2194 Irreducible b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.isUnit_of_irreducible_both' [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) (hp : Irreducible p) (hq : Irreducible q) : IsUnit p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.not_unit_both [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) : \u00ac IsUnit p \u2227 \u00ac IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem map_prime_surjective {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    {G : Type*} [FunLike G N M] [MulHomClass G N M]\n    (f : F) (g : G) {p : M}\n    (hg : \u2200 b : N, f (g b) = b) (hp : Prime p) : Prime (g (f p)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem prime_pow_two_dvd_mul' {M : Type*} [CancelCommMonoidWithZero M] {p x y : M}\n    (hp : Prime p) {n : \u2115} (h : p ^ (n + 2) \u2223 x * y) :\n    p ^ (n + 2) \u2223 y \u2228 p ^ 2 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_pow_of_two_le' [Monoid M] {x : M} {n : \u2115} (h : 2 \u2264 n) :\n    Irreducible (x ^ n) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_cube'' [CommMonoid M] {a : M} (ha : Irreducible a) :\n    (\u2203 b : M, b ^ 3 = a) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem IsSquare.not_prime'' [CancelCommMonoidWithZero M] {a : M}\n    (hsq : IsSquare a) : Prime a \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_cube'' [CancelCommMonoidWithZero M] {p : M} (hp : Prime p) :\n    (\u2203 b : M, b ^ 3 = p) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_prime_pow_two_or_more'' [CancelCommMonoidWithZero M] {a : M} {n : \u2115}\n    (hn : 2 \u2264 n) : Prime (a ^ n) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_of_not_unit_dvdNotUnit_right [CommMonoidWithZero M] {p q : M}\n    (hp : \u00ac IsUnit p) (h : DvdNotUnit p q) : Irreducible q \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem prime_pow_three_dvd_mul' {M : Type*} [CancelCommMonoidWithZero M] {p x y : M}\n    (hp : Prime p) {k : \u2115} (h : p ^ (k + 3) \u2223 x * y) :\n    p ^ (k + 3) \u2223 y \u2228 p ^ 3 \u2223 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_pow_of_three_le'' [Monoid M] {x : M} {n : \u2115}\n    (hn : 3 \u2264 n) : Irreducible (x ^ n) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_fourth_power'' [CommMonoid M] {a : M} (ha : Irreducible a) :\n    (\u2203 b : M, b ^ 4 = a) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_fourth_power'' [CancelCommMonoidWithZero M] {p : M} (hp : Prime p) :\n    (\u2203 b : M, b ^ 4 = p) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_square'' [CommMonoid M] {a : M} (ha : Irreducible a) :\n    (\u2203 b : M, b ^ 2 = a) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_square_of_prime' [CancelCommMonoidWithZero M] {p : M}\n    (hp : Prime p) : IsSquare p \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem map_prime_alt {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    (f : F) {p : M} (hp : Prime p) : Prime (f p) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.left_dvd_or_dvd_right_of_dvd_mul_alt [CancelCommMonoidWithZero M]\n    {p a b : M} (hp : Prime p) : a \u2223 b * p \u2192 p \u2223 a \u2228 b \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_of_pow_succ_dvd_pow_mul_pow_alt [CancelCommMonoidWithZero M]\n    {p a b : M} {n : \u2115} (hp : Prime p)\n    (h : p ^ (n.succ.succ) \u2223 a ^ (n.succ) * b ^ n) : p \u2223 a \u2228 p \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_kth_power {M} [CommMonoid M] {a : M} {k : \u2115}\n    (hk : 2 \u2264 k) (ha : Irreducible a) : \u00ac \u2203 b : M, a = b ^ k := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_square_alt [CancelCommMonoidWithZero M] {p : M}\n    (hp : Prime p) : \u00ac \u2203 a : M, p = a ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_injective_of_nonunit [CancelCommMonoidWithZero M]\n    {q : M} (hnu : \u00ac IsUnit q) (hq0 : q \u2260 0) :\n    Function.Injective fun n : \u2115 => q ^ n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_eq_iff_of_nonunit [CancelCommMonoidWithZero M]\n    {q : M} (hnu : \u00ac IsUnit q) (hq0 : q \u2260 0) {m n : \u2115} :\n    q ^ m = q ^ n \u2194 m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem map_prime_surjective_alt {M N : Type*} [CommMonoidWithZero M] [CommMonoidWithZero N]\n    {F : Type*} [FunLike F M N] [MonoidWithZeroHomClass F M N]\n    (f : F) (h_surj : Function.Surjective f) {p : M} (hp : Prime p) :\n    Prime (f p) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_seventh_power [CommMonoid M] {a : M}\n    (ha : Irreducible a) : \u00ac \u2203 b : M, a = b ^ 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_seventh_power [CancelCommMonoidWithZero M] {p : M}\n    (hp : Prime p) : \u00ac \u2203 b : M, p = b ^ 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.isUnit_of_irreducible_right_alt [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) (hq : Irreducible q) : IsUnit p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_left_or_right_of_mul_dvd [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) : a * b \u2223 p \u2192 p \u2223 a \u2228 p \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.pow_two_dvd_of_mul_dvd_left [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) (h : a * b \u2223 p ^ 2) : a \u2223 p \u2228 b \u2223 p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_eq_of_not_unit' [CancelCommMonoidWithZero M] {q : M}\n    (hnu : \u00ac IsUnit q) (hq0 : q \u2260 0) {m n : \u2115}\n    (h : q ^ m.succ = q ^ n.succ) : m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.pow_three_dvd_of_mul_dvd [CancelCommMonoidWithZero M] {p a b : M} {n : \u2115}\n    (hp : Prime p) (h : a * b \u2223 p ^ (n + 3)) : p ^ 3 \u2223 a \u2228 p ^ 3 \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.unit_of_irreducibles [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) (hp : Irreducible p) (hq : Irreducible q) : IsUnit p \u2228 IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_left_or_dvd_right_of_dvd_mul_alt {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1]\n    {p a b : \u03b1} (hp : Prime p) : a \u2223 b * p \u2192 p \u2223 b \u2228 p \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.pow_three_dvd_of_dvd_mul_right {\u03b3 : Type*} [CancelCommMonoidWithZero \u03b3]\n    {p a b : \u03b3} (hp : Prime p) (h : p ^ 3 \u2223 a * b) : p ^ 3 \u2223 b \u2228 p \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_square_alt {M : Type*} [CommMonoid M] {x : M}\n    (hx : Irreducible x) : \u00ac \u2203 y : M, y ^ 2 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_pow_three_or_more {M : Type*} [Monoid M] {x : M} {n : \u2115}\n    (hn : 3 \u2264 n) : \u00ac Irreducible (x ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.isUnit_of_irreducible_left_alt {M : Type*} [CommMonoidWithZero M]\n    {p q : M} (h : DvdNotUnit p q) (hp : Irreducible p) : IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.isUnit_of_irreducible_right_alt {M : Type*} [CommMonoidWithZero M]\n    {p q : M} (h : DvdNotUnit p q) (hq : Irreducible q) : IsUnit p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.not_unit_alt {M : Type*} [CommMonoidWithZero M]\n    {p q : M} (h : DvdNotUnit p q) : \u00ac IsUnit p \u2227 \u00ac IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_cube_variant {M : Type*} [CommMonoid M] {x : M}\n    (hx : Irreducible x) : \u00ac \u2203 y : M, x = y ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_injective_of_nonunit {M : Type*} [CancelCommMonoidWithZero M]\n    {q : M} (hq : \u00ac IsUnit q) (hq0 : q \u2260 0) :\n    Function.Injective fun n : \u2115 => q ^ n.succ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_irreducible_high_pow {M : Type*} [Monoid M] {x : M} {k : \u2115}\n    (hk : 4 \u2264 k) : \u00ac Irreducible (x ^ k) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_cube_alt {M : Type*} [CancelCommMonoidWithZero M]\n    {p : M} (hp : Prime p) : \u00ac \u2203 t : M, p = t ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.not_unit_left_variant {M : Type*} [CommMonoidWithZero M]\n    {p q : M} (h : DvdNotUnit p q) : \u00ac IsUnit p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.not_fourth_power_alt {M : Type*} [CommMonoid M]\n    {x : M} (hx : Irreducible x) : \u00ac \u2203 y : M, y ^ 4 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.not_fifth_power_alt {M : Type*} [CancelCommMonoidWithZero M]\n    {p : M} (hp : Prime p) : \u00ac \u2203 y : M, p = y ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.right_dvd_or_dvd_left_of_mul_dvd {M : Type*}\n    [CancelCommMonoidWithZero M] {p a b : M} (hp : Prime p) :\n    b * p \u2223 a \u2192 p \u2223 a \u2228 p \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.pow_two_dvd_of_mul_pow_dvd {M : Type*} [CancelCommMonoidWithZero M]\n    {p a b : M} (hp : Prime p) {n : \u2115} (h : p ^ (n + 2) \u2223 a * b) :\n    p ^ 2 \u2223 a \u2228 p ^ 2 \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.unit_of_two_irreducibles {M : Type*} [CommMonoidWithZero M]\n    {p q : M} (h : DvdNotUnit p q) (hp : Irreducible p) (hq : Irreducible q) :\n    IsUnit p \u2228 IsUnit q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_or_unit_of_dvd_pow_mul [CancelCommMonoidWithZero M] {p a b : M}\n    (hp : Prime p) {n : \u2115} (h : p ^ (n + 1) \u2223 a * b) :\n    p ^ (n + 1) \u2223 a \u2228 IsUnit b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.pow_dvd_left_or_right [CancelCommMonoidWithZero M] {p a b : M} {n : \u2115}\n    (hp : Prime p) (h : p ^ (n + 2) \u2223 a * b) :\n    p ^ (n + 2) \u2223 a \u2228 p ^ 2 \u2223 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem pow_eq_of_nonunit_add_two {M : Type*} [CancelCommMonoidWithZero M]\n    {q : M} (hnu : \u00acIsUnit q) (hq0 : q \u2260 0) {m n : \u2115} :\n    q ^ (m + 2) = q ^ (n + 2) \u2192 m = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_of_pow_mul_pow [CancelCommMonoidWithZero M] {p a b : M} {n : \u2115}\n    (hp : Prime p) (h : p ^ (n + 1) \u2223 a * b) : p ^ (n + 1) \u2223 b \u2228 p \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.of_pow_not_unit {M : Type*} [Monoid M] {x : M} {n : \u2115}\n    (h : Irreducible (x ^ n.succ)) : Irreducible x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.pow_dvd_or_unit [CancelCommMonoidWithZero M] {p a : M} (hp : Prime p)\n    {n : \u2115} (h : p ^ (n.succ) \u2223 a) : p \u2223 a \u2228 IsUnit (p ^ n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem irreducible_mul_unit_both [Monoid M] {a b : M} (ha : IsUnit a) (hb : IsUnit b) :\n    Irreducible (a * b) \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_or_unit_of_mul [CancelCommMonoidWithZero M] {p a b : M} (hp : Prime p)\n    (h : a * b \u2223 p) : p \u2223 a \u2228 IsUnit b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem not_prime_pow_succ [CancelCommMonoidWithZero M] {a : M} {k : \u2115}\n    (hk : 1 < k) : \u00ac Prime (a ^ (k + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Irreducible.map_units {M N : Type*} [Monoid M] [Monoid N]\n    {F : Type*} [FunLike F M N] [MonoidHomClass F M N] {f : F} {u : M\u02e3}\n    (h : Irreducible (f (u : M))) : Irreducible u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.ne_of_not_unit [CancelCommMonoidWithZero M] {p a : M}\n    (hp : Prime p) (ha : \u00ac IsUnit a) : p \u2260 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem DvdNotUnit.of_pow [CommMonoidWithZero M] {p q : M} {n : \u2115}\n    (h : p ^ n \u2223 q) (hp : \u00ac IsUnit p) : DvdNotUnit p q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M N : Type*}\nvariable [CommMonoidWithZero M]\nvariable [CommMonoidWithZero N] {F : Type*} {G : Type*} [FunLike F M N]\nvariable [MonoidWithZeroHomClass F M N] [FunLike G N M] [MulHomClass G N M]\nvariable (f : F) (g : G) {p : M}\nvariable [Monoid M]\nvariable [Monoid N] {F : Type*} [EquivLike F M N] [MulEquivClass F M N] (f : F)\nvariable [CommMonoid M] {a : M}\nvariable [CancelCommMonoidWithZero M] {a p : M}\n\nopen MulEquiv\ntheorem Prime.dvd_of_square_dvd [CancelCommMonoidWithZero M] {p a : M}\n    (hp : Prime p) (h : p ^ 2 \u2223 a) : p \u2223 a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\n\ntheorem sameRay_iff_arg_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x = 0 \u2228 y = 0) \u2228 x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\n\ntheorem sameRay_of_arg_sub_eq_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\n\ntheorem norm_add_eq_of_arg_sub_eq_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\n\ntheorem norm_sub_eq_of_arg_sub_eq_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    \u2016x - y\u2016 = \u2016\u2016x\u2016 - \u2016y\u2016\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\n\ntheorem arg_eq_of_sameRay {x y : \u2102} (h : SameRay \u211d x y) (hx : x \u2260 0) (hy : y \u2260 0) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sub_eq_zero_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x.arg - y.arg = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_diff_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_sub_eq_zero {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 (x.arg - y.arg = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_arg_sub_eq_zero {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 (x.arg - y.arg = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_of_arg_sub_eq_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_of_arg_sub_eq_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_of_arg_sub_eq_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    \u2016x - y\u2016 = \u2016\u2016x\u2016 - \u2016y\u2016\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_or_zero_of_arg_eq {x y : \u2102} (h : x.arg = y.arg) :\n    x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_diff_eq_zero_of_norm_add_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016) :\n    x.arg - y.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_sub_eq_zero_of_sameRay_nonzero {x y : \u2102} (h : SameRay \u211d x y) (hx : x \u2260 0) (hy : y \u2260 0) :\n    x.arg - y.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_exists_nonneg_real {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 r : \u211d, 0 \u2264 r \u2227 x = r \u2022 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_norm_add_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_diff_eq_zero_of_norm_sub_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016|) :\n    x.arg - y.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_mod_two_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x.arg - y.arg) % (2 * \u03c0) = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_eq {x y : \u2102} (h : x.arg = y.arg) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_or_zero_symm {x y : \u2102} :\n    SameRay \u211d x y \u2194 (y = 0 \u2228 x = 0) \u2228 y.arg = x.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sub_eq_zero_or_zero_rev {x y : \u2102} :\n    SameRay \u211d x y \u2194 (y.arg - x.arg = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_exists_nonneg_real_smul {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 r : \u211d, 0 \u2264 r \u2227 y = r \u2022 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_diff_zero_of_norm_sub_eq' {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016|) :\n    y.arg - x.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_diff_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_sq_of_arg_eq {x y : \u2102} (h : x.arg = y.arg) :\n    \u2016x - y\u2016 ^ 2 = (|\u2016x\u2016 - \u2016y\u2016|) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_neg_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_add_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg + \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_neg_eq {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 x = 0 \u2228 y = 0 \u2228 (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_arg_neg_eq {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 x = 0 \u2228 y = 0 \u2228 (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x - y\u2016 = \u2016\u2016x\u2016 - \u2016y\u2016\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_sameRay_nonneg {x y : \u2102} (h : SameRay \u211d x y) (hx : 0 \u2264 \u2016x\u2016) (hy : 0 \u2264 \u2016y\u2016) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_diff_le_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| \u2264 \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_iff_arg_eq {x y : \u2102} :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_sq_eq_iff_arg_eq {x y : \u2102} :\n    \u2016x - y\u2016 ^ 2 = (\u2016x\u2016 - \u2016y\u2016) ^ 2 \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_or_zero_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_diff_mod_two_pi_zero {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 (x.arg - y.arg) % (2 * \u03c0) = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_neg_eq_of_norm_add_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016) :\n    (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_diff_eq_zero_abs {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_of_arg_diff_small {x y : \u2102} (h : |x.arg - y.arg| \u2264 \u03b5) :\n    \u2016x + y\u2016 \u2265 \u2016x\u2016 + \u2016y\u2016 - \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_zero_of_sameRay_unit {x : \u2102} (h : SameRay \u211d x 1) (hx : x \u2260 0) :\n    x.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sub_int_mul_two_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg = y.arg + (k : \u211d) * (2 * \u03c0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_arg_eq_add_pi {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg + \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_of_arg_eq_mod_pi {x y : \u2102} (h : (x.arg - y.arg) % \u03c0 = 0) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_or_abs_small {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 |x.arg - y.arg| < 1e-6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_norm_sub_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016|) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_sq_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x - y\u2016 ^ 2 = (\u2016\u2016x\u2016 - \u2016y\u2016\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_exists_pos_real_smul {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 r : \u211d, r > 0 \u2227 y = r \u2022 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_diff_le_eps_or_zero {x y : \u2102} (\u03b5 : \u211d) (h\u03b5 : 0 < \u03b5) :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| \u2264 \u03b5 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_neg_sub_eq_zero_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 ((-x).arg - y.arg = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_neg_diff_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 |(-x).arg - y.arg| = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_neg_sub_eq_zero {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 ((-x).arg - y.arg = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_arg_neg_sub_eq_zero {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 ((-x).arg - y.arg = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_diff_zero_of_norm_add_eq_rev {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016y + x\u2016 = \u2016y\u2016 + \u2016x\u2016) :\n    x.arg - y.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_diff_zero {x y : \u2102} (h : x.arg - y.arg = 0) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_sq_eq_of_arg_eq_alt {x y : \u2102} (h : y.arg = x.arg) :\n    \u2016x - y\u2016 ^ 2 = (\u2016\u2016x\u2016 - \u2016y\u2016\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_or_zero_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_neg_mod_two_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 ((-x).arg - y.arg) % (2 * \u03c0) = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_neg_diff_eq_zero_of_norm_sub_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016|) :\n    (-x).arg - y.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_add_eq {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg + y.arg = 2 * y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_mul_two_eq {x y : \u2102} :\n    SameRay \u211d x y \u2194 2 * x.arg = 2 * y.arg \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_norm_add_eq_alt {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : (\u2016x + y\u2016) ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_neg_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x = 0 \u2228 y = 0) \u2228 x.arg = (-y).arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_add_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x.arg + y.arg = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_diff_two_pi_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 (x.arg - y.arg) = 2 * \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sum_eq_twice_left {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg + y.arg = 2 * x.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_exists_pos_real_smul_left {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 r : \u211d, r > 0 \u2227 x = r \u2022 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_of_arg_add_eq_zero {x y : \u2102} (h : x.arg + y.arg = 0) :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_of_arg_add_eq_pi {x y : \u2102} (h : x.arg + y.arg = \u03c0) :\n    \u2016x - y\u2016 = \u2016\u2016x\u2016 - \u2016y\u2016\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_sum_eq_zero {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 x.arg + y.arg = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_arg_sum_eq_pi {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 x.arg + y.arg = \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_sameRay_nonzero_left {x y : \u2102} (h : SameRay \u211d x y) (hx : x \u2260 0) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_neg_eq_of_sameRay_nonzero_right {x y : \u2102} (h : SameRay \u211d x y) (hy : y \u2260 0) :\n    (-x).arg = (-y).arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_neg_diff_eq_zero_of_norm_sub_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016|) :\n    (-x).arg - y.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_sum_zero {x y : \u2102} (h : x.arg + y.arg = 0) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_sq_eq_of_arg_diff_pi {x y : \u2102} (h : x.arg - y.arg = \u03c0) :\n    \u2016x - y\u2016 ^ 2 = (\u2016\u2016x\u2016 - \u2016y\u2016\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_or_zero_of_arg_add_zero {x y : \u2102} (h : x.arg + y.arg = 0) :\n    x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_add_mod_two_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x.arg + y.arg) % (2 * \u03c0) = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_neg_diff_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 |(-x).arg - y.arg| = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_or_abs_small_eps {x y : \u2102} (\u03b5 : \u211d) (h\u03b5 : 0 < \u03b5) :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 |x.arg - y.arg| < \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_int_mul_two_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg = y.arg + (k : \u211d) * 2 * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x - y\u2016 = \u2016\u2016x\u2016 - \u2016y\u2016\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_of_arg_sum_eq_two_pi {x y : \u2102} (h : x.arg + y.arg = 2 * \u03c0) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_mod_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x.arg - y.arg) % \u03c0 = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_sq_eq_of_arg_neg_eq {x y : \u2102} (h : (-x).arg = y.arg) :\n    \u2016x - y\u2016 ^ 2 = (\u2016\u2016x\u2016 - \u2016y\u2016\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_add_pi_le_abs {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg + y.arg - \u03c0| \u2264 \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_exists_nonneg_real_mul_two {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 r : \u211d, 0 \u2264 r \u2227 y = (2 * r) \u2022 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_triple_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 3 * x.arg = 3 * y.arg \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_diff_zero_of_norm_sub_eq_twice {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : (\u2016x - y\u2016) ^ 2 = (|\u2016x\u2016 - \u2016y\u2016|) ^ 2) :\n    x.arg - y.arg = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_diff_lt_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| < \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_multiple_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 n : \u2124, x.arg = y.arg + (n : \u211d) * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_diff_eq_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg - y.arg = \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sum_eq_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x (-y) \u2194 x = 0 \u2228 y = 0 \u2228 x.arg + y.arg = \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_neg_self_or_zero {x : \u2102} :\n    SameRay \u211d x (-x) \u2194 x = 0 \u2228 x.arg = (-x).arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_double_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 2 * x.arg = 2 * y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_half_diff_eq_zero_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 (x.arg - y.arg) / 2 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_diff_eq_pi {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 x = 0 \u2228 y = 0 \u2228 x.arg - y.arg = \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_arg_sum_eq_pi {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 x = 0 \u2228 y = 0 \u2228 x.arg + y.arg = \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_of_arg_diff_eq_two_pi {x y : \u2102} (h : x.arg - y.arg = 2 * \u03c0) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_diff_pi {x y : \u2102} (h : x.arg - y.arg = \u03c0) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_diff_lt_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| < \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_exists_pos_real_smul_left {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 r : \u211d, r > 0 \u2227 x = r \u2022 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_neg_eq_add_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 (-x).arg = y.arg + \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_norm_sub_sq_eq {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x - y\u2016 ^ 2 = (\u2016\u2016x\u2016 - \u2016y\u2016\u2016) ^ 2) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_or_zero_of_arg_sum_eq_two_pi {x y : \u2102} (h : x.arg + y.arg = 2 * \u03c0) :\n    x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_triple_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 3 * x.arg = 3 * y.arg \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_diff_mod_two_pi {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 (x.arg - y.arg) % (2 * \u03c0) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_neg_diff_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 |(-x).arg - y.arg| = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_iff_arg_neg_eq {x y : \u2102} :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 \u2194 x = 0 \u2228 y = 0 \u2228 (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_double_sum_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 2 * (x.arg + y.arg) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_arg_eq_sub_pi {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg - \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_neg_mod_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 ((-x).arg - y.arg) % \u03c0 = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_abs_arg_le_pi : SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 |x.arg - y.arg| \u2264 \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_diff_lt_pi_div_two : SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 |x.arg - y.arg| < \u03c0 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.norm_add_eq_iff_arg_diff_small (\u03b5 : \u211d) (h\u03b5 : 0 < \u03b5) : \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 |x.arg - y.arg| \u2264 \u03b5 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.norm_sub_eq_iff_arg_sum_small (\u03b5 : \u211d) (h\u03b5 : 0 < \u03b5) : \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 |x.arg + y.arg| \u2264 \u03b5 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_or_zero_of_arg_neg_eq_pi (h : (-x).arg = y.arg + \u03c0) : x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_add_eq_two_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg + y.arg = 2 * \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_abs_arg_sum_le_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg + y.arg| \u2264 \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_double_diff_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 2 * (x.arg - y.arg) = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_of_arg_sum_eq_zero {x y : \u2102} (h : x.arg + y.arg = 0) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.norm_sub_eq_of_arg_diff_pi_div_two {x y : \u2102} (h : x.arg - y.arg = \u03c0 / 2) :\n    \u2016x - y\u2016 = \u221a((\u2016x\u2016 ^ 2) + (\u2016y\u2016 ^ 2)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.norm_add_sq_eq_of_abs_arg_small {x y : \u2102} (h : |x.arg - y.arg| \u2264 \u03c0 / 3) :\n    \u2016x + y\u2016 ^ 2 \u2265 (\u2016x\u2016 + \u2016y\u2016) ^ 2 / 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_diff_multiple_two_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg - y.arg = (k : \u211d) * 2 * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_or_zero_of_arg_neg_eq_pi {x y : \u2102} (h : (-x).arg = y.arg + \u03c0) :\n    x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_abs_arg_diff_lt_pi_div_two {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| < \u03c0 / 2 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.norm_sub_eq_iff_arg_diff_pi_or_zero {x y : \u2102} :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| \u2194 x.arg - y.arg = \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_triple_diff_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 3 * (x.arg - y.arg) = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sum_eq_zero_or_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 (x.arg + y.arg = 0 \u2228 x.arg + y.arg = \u03c0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_diff_multiple_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg - y.arg = (k : \u211d) * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_of_arg_diff_pi {x y : \u2102} (h : x.arg - y.arg = \u03c0) :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_or_zero_of_arg_sum_pi {x y : \u2102} (h : x.arg + y.arg = \u03c0) :\n    x = 0 \u2228 y = 0 \u2228 SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_eq_of_arg_eq {x y : \u2102} (h : x.arg = y.arg) :\n    \u2016x + y\u2016 ^ 2 = (\u2016x\u2016 + \u2016y\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sum_multiple_two_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg + y.arg = (k : \u211d) * 2 * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_sq_of_arg_eq {x y : \u2102} (h : x.arg = y.arg) :\n    \u2016x - y\u2016 ^ 2 = (|\u2016x\u2016 - \u2016y\u2016|) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_diff_lt_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| < \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_neg_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_neg_eq {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 x = 0 \u2228 y = 0 \u2228 (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_diff_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg - y.arg| = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_or_zero' {u v : \u2102} :\n    SameRay \u211d u v \u2194 (u = 0 \u2228 v = 0) \u2228 u.arg = -v.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_of_arg_add_eq_pi {u v : \u2102} (h : u.arg + v.arg = \u03c0) :\n    SameRay \u211d u (-v) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_eq_or_zero {u v : \u2102} :\n    \u2016u + v\u2016 = \u2016u\u2016 + \u2016v\u2016 \u2194 (u = 0 \u2228 v = 0) \u2228 u.arg = v.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_iff_abs_arg_pi {u v : \u2102} :\n    \u2016u - v\u2016 = |\u2016u\u2016 - \u2016v\u2016| \u2194 |u.arg - v.arg| = \u03c0 \u2228 u = 0 \u2228 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_or_zero_of_arg_eq_pi (u v : \u2102) (h : u.arg = v.arg + \u03c0) :\n    u = 0 \u2228 v = 0 \u2228 SameRay \u211d (-u) v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_sq_ge_of_small_arg {u v : \u2102} (h : |u.arg - v.arg| \u2264 \u03c0 / 4) :\n    \u2016u + v\u2016 ^ 2 \u2265 (\u2016u\u2016 + \u2016v\u2016) ^ 2 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_of_arg_add_pi {u v : \u2102} (h : u.arg + v.arg = \u03c0) :\n    \u2016u - (-v)\u2016 = |\u2016u\u2016 - \u2016v\u2016| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_half_eq_zero_or_zero {u v : \u2102} :\n    SameRay \u211d u v \u2194 ((u.arg - v.arg) / 2 = 0) \u2228 u = 0 \u2228 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_abs_arg_le_pi' {u v : \u2102} :\n    SameRay \u211d u v \u2194 (|u.arg - v.arg| \u2264 \u03c0) \u2228 u = 0 \u2228 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_neg_eq_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x = 0 \u2228 y = 0) \u2228 (-x).arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_abs_arg_sum_eq_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg + y.arg - \u03c0| = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_sum_multiple_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg + y.arg = (k : \u211d) * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_half_sum_eq_zero_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 ((x.arg + y.arg) / 2 = 0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_diff_eq_two_pi_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 (x.arg - y.arg = 2 * \u03c0) \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_neg_diff_multiple_two_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 n : \u2124, (-x).arg - y.arg = (n : \u211d) * 2 * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.norm_add_sq_eq_of_arg_diff_small {x y : \u2102} (h : |x.arg - y.arg| < \u03c0 / 3) :\n    \u2016x + y\u2016 ^ 2 \u2265 (\u2016x\u2016 + \u2016y\u2016) ^ 2 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_abs_arg_sum_lt_pi_div_two {x y : \u2102} :\n    SameRay \u211d x y \u2194 |x.arg + y.arg| < \u03c0 / 2 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_double_sum_eq_two_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 2 * (x.arg + y.arg) = 2 * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_abs_arg_neg_diff_le_pi_div_two {x y : \u2102} :\n    SameRay \u211d x y \u2194 |(-x).arg - y.arg| \u2264 \u03c0 / 2 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_iff_arg_quadriple_eq_zero_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 4 * (x.arg - y.arg) = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem Complex.sameRay_of_arg_sum_eq_multiple_pi {x y : \u2102} (k : \u2124) (h : x.arg + y.arg = (k : \u211d) * \u03c0) :\n    SameRay \u211d (Complex.ofReal (-1) * x) y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_eq_neg_or_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = -y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sum_eq_zero_or_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 x.arg + y.arg = 0 \u2228 x.arg + y.arg = \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_of_arg_sum_eq_two_pi {x y : \u2102} (h : x.arg + y.arg = 2 * \u03c0) :\n    SameRay \u211d x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_diff_multiple_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg - y.arg = (k : \u211d) * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_eq_of_arg_diff_pi {x y : \u2102} (h : x.arg - y.arg = \u03c0) :\n    \u2016x - y\u2016 = |\u2016x\u2016 - \u2016y\u2016| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_sum_multiple_two_pi {x y : \u2102} :\n    SameRay \u211d x y \u2194 \u2203 k : \u2124, x.arg + y.arg = (k : \u211d) * 2 * \u03c0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_iff_arg_eq_or_zero_alt {x y : \u2102} :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 \u2194 (x = 0 \u2228 y = 0) \u2228 x.arg = -y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_norm_add_eq_alt {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016) :\n    x.arg = -y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_sub_sq_eq_of_arg_eq_alt {x y : \u2102} (h : x.arg = -y.arg) :\n    \u2016x - y\u2016 ^ 2 = (\u2016\u2016x\u2016 - \u2016y\u2016\u2016) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_diff_eq_zero_of_norm_sub_eq_twice_alt {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0)\n    (h : (\u2016x - y\u2016) ^ 2 = (|\u2016x\u2016 - \u2016y\u2016|) ^ 2) :\n    x.arg - y.arg = \u03c0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem arg_eq_of_sameRay_nonneg_alt {x y : \u2102} (h : SameRay \u211d x y)\n    (hx : 0 < \u2016x\u2016) (hy : 0 < \u2016y\u2016) :\n    x.arg = y.arg := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem sameRay_iff_arg_add_pi_eq_zero {x y : \u2102} :\n    SameRay \u211d x y \u2194 x.arg + y.arg - \u03c0 = 0 \u2228 x = 0 \u2228 y = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y : \u2102}\n\n\ntheorem norm_add_eq_of_arg_neg_eq_alt {x y : \u2102} (h : x.arg = -y.arg) :\n    \u2016x + y\u2016 = \u2016x\u2016 + \u2016y\u2016 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\n\ntheorem mem_sets_imp {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\n\ntheorem principal_\u03c3_nonempty {\u03b1 : Type*} (s : Set \u03b1) :\n    Nonempty (Realizer.principal s).\u03c3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\n\ntheorem top_\u03c3_nonempty {\u03b1 : Type*} :\n    Nonempty (@Realizer.top \u03b1).\u03c3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\n\ntheorem bot_\u03c3_nonempty {\u03b1 : Type*} :\n    Nonempty (@Realizer.bot \u03b1).\u03c3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    A \u2286 B \u2192 A \u2208 f \u2192 \u2203 s, R.F s \u2286 B := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ofEquiv_\u03c3_nonempty {\u03b1 \u03c4 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) (E : R.\u03c3 \u2243 \u03c4) :\n    Nonempty (R.ofEquiv E).\u03c3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem le_iff_forall_sets {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    f \u2264 g \u2194 \u2200 a : F.\u03c3, \u2203 b : G.\u03c3, G.F b \u2286 F.F a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_iff_exists {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a5 \u2194 \u2203 a : R.\u03c3, (R.F a).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp' {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_mem {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2208 f \u2227 R.F s \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_top_iff_exists {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a4 \u2194 \u2203 a : R.\u03c3, R.F a \u2260 (Set.univ : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_iff_exists_superset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2194 \u2203 s, A \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_superset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    B \u2286 A \u2192 A \u2208 f \u2192 \u2203 s, B \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_iff_nonempty_set {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a5 \u2194 \u2203 a : R.\u03c3, R.F a \u2260 (\u2205 : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_mem_rev {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2208 f \u2227 A \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem subset_pt_toFilter {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    A \u2286 F F.pt \u2192 A \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_top_iff_exists_subset {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a4 \u2194 \u2203 a : R.\u03c3, R.F a \u2282 (Set.univ : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_has_superset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2286 R.F s \u2227 R.F s \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_superset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    B \u2286 A \u2192 A \u2208 f \u2192 \u2203 s, B \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ge_iff {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    g \u2264 f \u2194 \u2200 a : G.\u03c3, \u2203 b : F.\u03c3, G.F a \u2264 F.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem eq_bot_iff_empty {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f = \u22a5 \u2194 \u2200 a : R.\u03c3, R.F a = (\u2205 : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_nonempty {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, (R.F s \u2229 A).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_mem_alt {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2286 R.F s \u2227 R.F s \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem inter_pt_mem_toFilter {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    F F.pt \u2229 A \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem eq_top_iff_univ {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f = \u22a4 \u2194 \u2200 a : R.\u03c3, R.F a = (Set.univ : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_iff_exists_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2194 \u2203 s, R.F s \u2286 A \u2227 R.F s \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_inter {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2229 A \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_eq {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s = A \u2228 (R.F s \u2286 A \u2227 A \u2286 R.F s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_inter_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2229 A \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem exists_set_in_toFilter {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) :\n    \u2203 a : Set \u03b1, a \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_union_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u222a A \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ofEquiv_\u03c3_not_isEmpty {\u03b1 \u03c4 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) (E : R.\u03c3 \u2243 \u03c4) :\n    \u00ac IsEmpty (R.ofEquiv E).\u03c3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem le_imp_exists_subset {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    f \u2264 g \u2192 \u2200 b : G.\u03c3, \u2203 a : F.\u03c3, F.F a \u2286 G.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_imp_exists_nonempty {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f \u2260 \u22a5 \u2192 \u2203 a : R.\u03c3, (R.F a).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_exists_mem {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_top_imp_exists_set_not_univ {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f \u2260 \u22a4 \u2192 \u2203 a : R.\u03c3, R.F a \u2260 (Set.univ : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_iff_exists_subset_union {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2194 \u2203 s, R.F s \u2286 A \u222a R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_superset_union {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    B \u2286 A \u2192 A \u2208 f \u2192 \u2203 s, B \u2286 R.F s \u222a A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_imp_exists_set_nonempty {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f \u2260 \u22a5 \u2192 \u2203 a : R.\u03c3, R.F a \u2260 (\u2205 : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem subset_pt_toFilter_union {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    A \u2286 F F.pt \u2192 (F F.pt \u222a A) \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ge_iff_exists_union {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    g \u2264 f \u2194 \u2200 a : G.\u03c3, \u2203 b : F.\u03c3, G.F a \u222a F.F b = F.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem eq_bot_iff_subset_empty {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f = \u22a5 \u2194 \u2200 a : R.\u03c3, R.F a \u2286 (\u2205 : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_image_nonempty {\u03b1 \u03b2 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) (g : \u03b1 \u2192 \u03b2) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, (g '' (R.F s \u2229 A)).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_eq_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2286 R.F s \u2227 R.F s \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem union_pt_mem_toFilter {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    F F.pt \u222a A \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem eq_top_iff_subset_univ {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f = \u22a4 \u2194 \u2200 a : R.\u03c3, R.F a \u2286 (Set.univ : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_iff_exists_union_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2194 \u2203 s, R.F s \u222a A \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_singleton {\u03b1 : Type*} {f : Filter \u03b1} [Nonempty \u03b1]\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 x : \u03b1, x \u2208 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_eq_or_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s = A \u2228 R.F s \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_subset_eq {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    A = B \u2192 A \u2208 f \u2192 \u2203 s, R.F s \u2286 B := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_and_mem_imp {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2208 f \u2227 A \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_exists_subset_eq {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s = A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_iff_nonempty_inter {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f \u2260 \u22a5 \u2194 \u2200 a : R.\u03c3, (R.F a \u2229 Set.univ).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_has_superset_imp {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2286 R.F s \u2227 R.F s \u2286 Set.univ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_nonempty_imp {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, (R.F s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem exists_nonempty_set_in_toFilter {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) :\n    \u2203 A : Set \u03b1, A \u2208 F.toFilter \u2227 A.Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_imp_exists_nonempty_alt {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f \u2260 \u22a5 \u2192 \u2203 a : R.\u03c3, (R.F a).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_imp_exists_not_empty {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a5 \u2192 \u2203 a : R.\u03c3, R.F a \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_eq_or_subset_alt {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s = A \u2228 A \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_alt {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s t, R.F s \u2286 A \u2227 A \u2286 R.F t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_image_nonempty_alt {\u03b1 \u03b2 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) (g : \u03b1 \u2192 \u03b2) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, (g '' (R.F s)).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem top_\u03c3_nonempty_alt {\u03b1 : Type*} :\n    (\u00ac (@Realizer.top \u03b1).\u03c3 = PEmpty) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem pt_mem_toFilter_alt {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) :\n    \u2203 A, A \u2208 F.toFilter \u2227 F F.pt \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem le_iff_exists_image {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    f \u2264 g \u2194 \u2200 t : G.\u03c3, \u2203 s : F.\u03c3, image id (F.F s) \u2286 G.F t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_iff_nonempty_union {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a5 \u2194 \u2200 a : R.\u03c3, (R.F a \u222a \u2205).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_mem_alt2 {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2208 f \u2227 A \u2286 R.F s \u222a A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem pt_subset_toFilter_alt {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    F F.pt \u2286 A \u2192 (A \u222a F F.pt) \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_top_iff_exists_diff {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a4 \u2194 \u2203 a : R.\u03c3, (Set.univ \\ R.F a).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_iff_exists_inter {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2194 \u2203 s, A \u2286 R.F s \u2229 Set.univ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_union_left {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    A \u2286 B \u2192 B \u2208 f \u2192 \u2203 s, A \u222a R.F s \u2286 B := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_iff_nonempty_set_alt {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a5 \u2194 \u2200 a : R.\u03c3, R.F a \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem subset_pt_toFilter_alt {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    A \u2286 F F.pt \u2192 (A \u2229 F F.pt) \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_has_superset_alt {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2286 R.F s \u2227 A.Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_exists_nonempty {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, (A \u2229 R.F s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem inter_pt_mem_toFilter_alt {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    A \u2229 F F.pt \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem eq_top_iff_all_univ {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f = \u22a4 \u2194 \u2200 a : R.\u03c3, Set.univ \u2286 R.F a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem le_imp_exists_subset_alt {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    f \u2264 g \u2192 \u2200 b : G.\u03c3, \u2203 a : F.\u03c3, F.F a \u2286 G.F b \u2227 (F.F a).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ge_iff_exists_union_alt {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    g \u2264 f \u2194 \u2200 a : G.\u03c3, \u2203 b : F.\u03c3, G.F a \u222a F.F b \u2286 F.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_top_imp_exists_subset {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a4 \u2192 \u2203 a : R.\u03c3, R.F a \u2282 Set.univ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem exists_nonempty_set_in_toFilter_alt {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) :\n    \u2203 A, A \u2208 F.toFilter \u2227 (A \u2229 Set.univ).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_union_subset_alt {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2286 A \u2227 R.F s \u222a A = A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem eq_top_iff_univ_subset {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f = \u22a4 \u2194 \u2200 a : R.\u03c3, Set.univ \u2286 R.F a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_left {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2286 A \u2227 A.Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_mem_middle {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2208 f \u2227 A \u2286 R.F s \u2227 R.F s \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_imp_exists_ne_empty {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a5 \u2192 \u2203 a : R.\u03c3, R.F a \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem subset_pt_toFilter_left {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    A \u2286 F F.pt \u2192 (A \u222a F F.pt) \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_top_imp_exists_diff {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a4 \u2192 \u2203 a : R.\u03c3, (Set.univ \\ R.F a).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_top_imp_exists_proper_subset {\u03b1 : Type*} {f : Filter \u03b1} (R : f.Realizer) :\n    f \u2260 \u22a4 \u2192 \u2203 a : R.\u03c3, R.F a \u2282 Set.univ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_superset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_imp_exists_not_empty_set {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f \u2260 \u22a5 \u2192 \u2203 a : R.\u03c3, R.F a \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem principal_\u03c3_nonempty_alt {\u03b1 : Type*} (s : Set \u03b1) :\n    (Realizer.principal s).\u03c3 \u2260 PEmpty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_union_subset_right {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    B \u2286 A \u2192 A \u2208 f \u2192 \u2203 s, R.F s \u222a B \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_eq_or_subset_rev {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A = R.F s \u2228 A \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem pt_mem_toFilter_subset {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) :\n    \u2203 A, F F.pt \u2286 A \u2227 A \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_superset_imp {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A B : Set \u03b1} :\n    A \u2286 B \u2192 A \u2208 f \u2192 \u2203 s, B \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem subset_pt_toFilter_left {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) {A : Set \u03b1} :\n    A \u2286 F F.pt \u2192 A \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem bot_\u03c3_not_empty {\u03b1 : Type*} :\n    (@Realizer.bot \u03b1).\u03c3 \u2260 PEmpty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem tendsto_iff_image {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2)\n    {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (L\u2081 : l\u2081.Realizer)\n    (L\u2082 : l\u2082.Realizer) :\n    Tendsto f l\u2081 l\u2082 \u2194 \u2200 b, \u2203 a, f '' (L\u2081.F a) \u2286 L\u2082.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_and_eq_subset_symm {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, R.F s \u2286 A \u2227 A \u2286 R.F s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_inter_left {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2229 R.F s \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ne_bot_imp_exists_subset {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) :\n    f \u2260 \u22a5 \u2192 \u2203 a : R.\u03c3, R.F a \u2286 Set.univ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem le_imp_exists_subset_right {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    f \u2264 g \u2192 \u2200 b : G.\u03c3, \u2203 a : F.\u03c3, G.F b \u2286 F.F a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem ge_iff_exists_inter {\u03b1 : Type*} {f g : Filter \u03b1}\n    (F : f.Realizer) (G : g.Realizer) :\n    g \u2264 f \u2194 \u2200 a : G.\u03c3, \u2203 b : F.\u03c3, G.F a \u2229 F.F b = G.F a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_iff_exists_union {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2194 \u2203 s, A \u222a R.F s \u2208 f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem principal_\u03c3_nonempty_alt {\u03b1 : Type*} (s : Set \u03b1) :\n    (Realizer.principal s).\u03c3 \u2260 PEmpty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem pt_mem_toFilter_subset {\u03b1 \u03c3 : Type*} (F : CFilter (Set \u03b1) \u03c3) :\n    \u2200 {A : Set \u03b1}, F F.pt \u2286 A \u2192 A \u2208 F.toFilter := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable [PartialOrder \u03b1] (F : CFilter \u03b1 \u03c3)\n\nopen Filter Set\ntheorem mem_sets_imp_inter_subset_left {\u03b1 : Type*} {f : Filter \u03b1}\n    (R : f.Realizer) {A : Set \u03b1} :\n    A \u2208 f \u2192 \u2203 s, A \u2229 R.F s \u2286 A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_image {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsOpen (\u22c3 b, F.F (g b)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_converse {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    (\u2203 b, a \u2208 F.F b \u2227 F.F b \u2286 s) \u2192 a \u2208 interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, a \u2208 s \u2192 IsOpen s \u2192 \u2203 b, a \u2208 F b \u2227 F b \u2286 s) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_open {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 a, IsOpen (F a))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun b : \u03c3 => x \u2208 F b) fun b => F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_iff' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2}\n    (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, a \u2208 R.F t \u2192 \u2203 s, s \u2208 f \u2227 \u2200 x, x \u2208 s \u2192 m x \u2208 R.F t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.finite_intersections {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {F : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (R : LocallyFinite.Realizer F f) (x : \u03b1) :\n    Finite { i | (f i \u2229 F.F (R.bas x)).Nonempty } := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem locallyFinite_iff_exists_realizer' {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] (F : Ctop.Realizer \u03b1) {f : \u03b2 \u2192 Set \u03b1} :\n    LocallyFinite f \u2194 \u2203 R : LocallyFinite.Realizer F f, True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_converse' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2192 \u2203 b, a \u2208 F.F b \u2227 F.F b \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_triple_prime {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsOpen s \u2192 a \u2208 s \u2192 \u2203 b, a \u2208 F b \u2227 F b \u2286 s) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.finite_intersections' {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {F : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (R : LocallyFinite.Realizer F f) (x : \u03b1) :\n    Finite { i | (F.F (R.bas x) \u2229 f i).Nonempty } := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iUnion_interior {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} : IsOpen (\u22c3 b, interior (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_open_nhds {\u03b1 : Type*} [T : TopologicalSpace \u03b1] {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3} (hopen : \u2200 b, IsOpen (F b)) (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun _ : \u03c3 => True) fun b => F b) : F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_converse_subset {\u03b1 : Type*} [TopologicalSpace \u03b1] (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} : (\u2203 b, a \u2208 F.F b \u2227 F.F b \u2286 s) \u2192 a \u2208 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_converse_closure {\u03b1 : Type*} [TopologicalSpace \u03b1] (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} : a \u2208 interior s \u2192 \u2203 b, a \u2208 F.F b \u2227 closure (F.F b) \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime_extra {\u03b1 : Type*} [T : TopologicalSpace \u03b1] {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3} (H : \u2200 a s, a \u2208 s \u2192 IsOpen s \u2192 \u2203 b, a \u2208 F b \u2227 s \u2286 F b) : F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_open_extra {\u03b1 : Type*} [T : TopologicalSpace \u03b1] {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3} (hopen : \u2200 b, IsOpen (F b)) (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun _ : \u03c3 => True) fun b => interior (F b)) : F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_iff_cover {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2} (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} : Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, a \u2208 R.F t \u2192 (\u2200\u1da0 x in f, m x \u2208 R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_quadruple {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsClosed s \u2192 a \u2208 s \u2192 \u2203 b, a \u2208 F b \u2227 F b \u2286 s) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_closed {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hclosed : \u2200 a, IsClosed (F a))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun b : \u03c3 => x \u2208 F b) fun b => F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_fourth_prime {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsOpen s \u2192 a \u2208 s \u2192 \u2203 b, F b \u2286 s \u2227 a \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iInter_interior {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsOpen (\u22c2 b, interior (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_closed_nhds {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hclosed : \u2200 b, IsClosed (F b))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun _ : \u03c3 => True) fun b => F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_converse_closure'' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2192 \u2203 b, a \u2208 F.F b \u2227 closure (F.F b) \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime_rev {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, a \u2208 s \u2192 IsOpen s \u2192 \u2203 b, s \u2286 F b \u2227 a \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer_mem_interior_closure_converse {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    (\u2203 b, a \u2208 F.F b \u2227 closure (F.F b) \u2286 s) \u2192 a \u2208 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime_symm {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, a \u2208 s \u2192 IsClosed s \u2192 \u2203 b, a \u2208 F b \u2227 F b \u2286 s) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_open_closure {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 b, IsOpen (closure (F b)))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun b : \u03c3 => x \u2208 closure (F b)) fun b => closure (F b)) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite_Realizer_finite_unions {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {F : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (R : LocallyFinite.Realizer F f) (x : \u03b1) :\n    Finite { i | (f i \u222a F.F (R.bas x)).Nonempty } := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem locallyFinite_iff_exists_realizer_and {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] (F : Ctop.Realizer \u03b1) {f : \u03b2 \u2192 Set \u03b1} :\n    LocallyFinite f \u2194 \u2203 R : LocallyFinite.Realizer F f, True \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer_mem_interior_converse_open {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2192 \u2203 b, IsOpen (F.F b) \u2227 a \u2208 F.F b \u2227 F.F b \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer_isClosed_iUnion_interior {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsClosed (\u22c3 b, interior (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime_extra_closed {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, a \u2208 s \u2192 IsClosed s \u2192 \u2203 b, a \u2208 F b \u2227 s \u2286 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_open_extra_closure {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 b, IsOpen (F b))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun _ : \u03c3 => True) fun b => closure (F b)) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_iff_cover_eventually {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2}\n    (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, a \u2208 R.F t \u2192 (\u2203\u1da0 x in f, m x \u2208 R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_quadruple_superset {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsClosed s \u2192 a \u2208 s \u2192 \u2203 b, s \u2286 F b \u2227 a \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_fifth_prime {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsClosed s \u2192 a \u2208 s \u2192 \u2203 b, F b \u2286 s \u2227 a \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer_isClosed_iInter_interior {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsClosed (\u22c2 b, interior (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer_mem_interior_converse_closure_open {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2192 \u2203 b, a \u2208 interior (F.F b) \u2227 closure (F.F b) \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime_forward {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, a \u2208 s \u2192 IsOpen s \u2192 \u2203 b, F b \u2286 s \u2227 a \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iUnion_closure {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsOpen (\u22c3 b, closure (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime_variation {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsOpen s \u2192 a \u2208 s \u2192 \u2203 b, s \u2286 F b \u2227 a \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_iff_cover_eventually' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2}\n    (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, a \u2208 R.F t \u2192 (\u2200\u1da0 x in f, m x \u2208 closure (R.F t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_converse_open' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2192 \u2203 b, IsOpen (F.F b) \u2227 a \u2208 F.F b \u2227 closure (F.F b) \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_closed_nhds_variant {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hclosed : \u2200 b, IsClosed (F b))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun _ : \u03c3 => True) fun b => closure (F b)) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer_isClosed_iUnion_closure {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsClosed (\u22c3 b, closure (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.finite_unions {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {F : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (R : LocallyFinite.Realizer F f) (x : \u03b1) :\n    Finite { i | (F.F (R.bas x) \u222a f i).Nonempty } := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_iff_cover' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2}\n    (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, a \u2208 R.F t \u2192 (\u2200\u1da0 x in f, m x \u2208 closure (R.F t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iUnion_interior' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsOpen (\u22c3 b, interior (closure (F.F (g b)))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_image {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsClosed (\u22c3 b, F.F (g b)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iUnion_interior' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsOpen (\u22c3 b, interior (closure (F.F (g b)))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_closure_converse' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    (\u2203 b, a \u2208 closure (F.F b) \u2227 closure (F.F b) \u2286 s) \u2192 a \u2208 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_iInter {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsClosed (\u22c2 b, F.F (g b)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_subset {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2}\n    (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2192 \u2200 t, a \u2208 R.F t \u2192 (\u2200\u1da0 x in f, m x \u2208 closure (R.F t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_fourth_prime_alt {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsOpen s \u2192 a \u2208 s \u2192 \u2203 b, a \u2208 F b \u2227 s \u2286 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_quadruple_closed {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsClosed s \u2192 a \u2208 s \u2192 \u2203 b, a \u2208 F b \u2227 s \u2286 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_iInter_image {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsClosed (\u22c2 b, closure (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.finite_interiors {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {F : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (R : LocallyFinite.Realizer F f) (x : \u03b1) :\n    Finite { i | (interior (F.F (R.bas x)) \u2229 f i).Nonempty } := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_cover_open {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2}\n    (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, IsOpen (R.F t) \u2192 a \u2208 R.F t \u2192 (\u2200\u1da0 x in f, m x \u2208 R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_iff_interior {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2} (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, a \u2208 interior (R.F t) \u2192 \u2203 s \u2208 f, \u2200 x \u2208 s, m x \u2208 interior (R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_image_union {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g h : \u03b2 \u2192 F.\u03c3} :\n    IsOpen (\u22c3 i, F.F (g i) \u222a F.F (h i)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_double_prime_variant {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, IsOpen s \u2192 a \u2208 s \u2192 \u2203 b, a \u2208 F b \u2227 s \u2286 closure (F b)) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_cover_closure {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2} (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    (\u2200 t, a \u2208 R.F t \u2192 (\u2200\u1da0 x in f, m x \u2208 closure (R.F t))) \u2192 Tendsto m f (\ud835\udcdd a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ofEquiv_apply_pointwise {\u03b1 \u03c3 \u03c4} (E : \u03c3 \u2243 \u03c4) (F : Ctop \u03b1 \u03c3) (x : \u03b1) :\n    x \u2208 (F.ofEquiv E) (E (F.top x)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_image {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 R.\u03c3} :\n    IsClosed (\u22c2 b, R.F (g b)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_open_symm {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 b, IsOpen (F b))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun b : \u03c3 => True) fun b => F b) :\n    T \u2264 F.toTopsp := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_closed_dir {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hclosed : \u2200 b, IsClosed (F b))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun b : \u03c3 => True) fun b => F b) :\n    F.toTopsp \u2264 T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_iff_subset {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2}\n    (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, R.F t \u2286 interior (closure (R.F t)) \u2192 a \u2208 R.F t \u2192 (\u2200\u1da0 x in f, m x \u2208 R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.nhds_basis {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun b : R.\u03c3 => a \u2208 R.F b) fun b => R.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_iff_subset {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2194 \u2203 b, R.F b \u2286 s \u2227 a \u2208 R.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.hasBasis_nhds {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) (x : \u03b1) :\n    (\ud835\udcdd x).HasBasis (fun b : R.\u03c3 => x \u2208 R.F b) fun b => R.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_inter {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s t : R.\u03c3} :\n    IsClosed (R.F s \u2229 R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_union {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s t : R.\u03c3} :\n    IsOpen (R.F s \u222a R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_open_le {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 b, IsOpen (F b))\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (fun b : \u03c3 => True) fun b => closure (F b)) :\n    F.toTopsp \u2264 T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.closed_union {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {F : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (R : LocallyFinite.Realizer F f) :\n    LocallyFinite (fun i => closure (f i)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.closure_iUnion {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 R.\u03c3} :\n    closure (\u22c3 b, R.F (g b)) = \u22c3 b, closure (R.F (g b)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_nhds_of_open {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {a : \u03b1} {b : R.\u03c3} :\n    a \u2208 R.F b \u2192 R.F b \u2208 \ud835\udcdd a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.nhds_le {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {a : \u03b1} {b : R.\u03c3} :\n    (\ud835\udcdd a) \u2264 \ud835\udcdd[closure (R.F b)] a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ofEquiv_injective {\u03b1 \u03c3 \u03c4} (E : \u03c3 \u2243 \u03c4) (F : Ctop \u03b1 \u03c3) :\n    Function.Injective (F.ofEquiv E) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.subset_basis_nhds {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    \u2200 s \u2208 \ud835\udcdd a, \u2203 b, a \u2208 R.F b \u2227 R.F b \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.subset_nhds_of_closure {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {a : \u03b1} {s : Set \u03b1} :\n    closure s \u2208 \ud835\udcdd a \u2192 \u2203 b, a \u2208 F.F b \u2227 closure (F.F b) \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_iff_subset_closure {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2194 \u2203 b, a \u2208 F.F b \u2227 closure (F.F b) \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.finite_closed_intersections {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {F : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (R : LocallyFinite.Realizer F f) (x : \u03b1) :\n    Finite { i | (closure (f i) \u2229 F.F (R.bas x)).Nonempty } := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iInter_interior {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 F.\u03c3} :\n    IsOpen (\u22c2 b, interior (F.F (g b))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_closure_converse_variation {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    (\u2203 b, a \u2208 closure (F.F b) \u2227 F.F b \u2286 s) \u2192 a \u2208 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_iInter {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 R.\u03c3} :\n    IsClosed (\u22c2 i, R.F (g i)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_iff_exists_basis {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2194 \u2203 b, a \u2208 R.F b \u2227 R.F b \u2286 interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_closure_iff_exists_basis {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 closure s \u2194 \u2203 b, a \u2208 R.F b \u2227 closure (R.F b) \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_open_eq {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 b, IsOpen (F b))\n    (hcover : \u2200 x, \u2203 b, x \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_closed_eq {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hclosed : \u2200 b, IsClosed (F b))\n    (hcover : \u2200 x, \u2203 b, x \u2208 F b) :\n    F.toTopsp = T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.hasBasis_nhds' {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun b : R.\u03c3 => a \u2208 R.F b) fun b => interior (R.F b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ofEquiv_surjective' {\u03b1 \u03c3 \u03c4} (E : \u03c3 \u2243 \u03c4) (F : Ctop \u03b1 \u03c3) :\n    Function.Surjective (fun c : \u03c4 => F (E.symm c)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_open_le {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 b, IsOpen (F b)) :\n    T \u2264 F.toTopsp := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_of_closed_ge {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hclosed : \u2200 b, IsClosed (F b)) :\n    F.toTopsp \u2264 T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iInter_closure {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 R.\u03c3} :\n    IsOpen (\u22c2 i, closure (R.F (g i))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_subset {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2192 \u2203 b, a \u2208 R.F b \u2227 R.F b \u2286 interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.open_of_closed {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {R : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (L : LocallyFinite.Realizer R f) :\n    LocallyFinite (fun i => interior (closure (f i))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.hasBasis_closure {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun b : R.\u03c3 => a \u2208 closure (R.F b)) fun b => closure (R.F b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.hasBasis_interior {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun b : R.\u03c3 => a \u2208 interior (R.F b)) fun b => interior (R.F b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.tendsto_of_eventually {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2} (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    (\u2200 b, a \u2208 R.F b \u2192 (\u2200\u1da0 x in f, m x \u2208 R.F b)) \u2192 Tendsto m f (\ud835\udcdd a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.closure_eq_of_closed {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {b : R.\u03c3} :\n    IsClosed (R.F b) \u2192 closure (R.F b) = R.F b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_closure_self {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {b : R.\u03c3} {a : \u03b1} :\n    a \u2208 R.F b \u2192 a \u2208 closure (R.F b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_iInter {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 R.\u03c3} :\n    IsClosed (\u22c2 i, R.F (g i)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem tendsto_nhds_converse {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2} (F : f.Realizer) (R : Ctop.Realizer \u03b1) {a : \u03b1} :\n    (\u2200 b, a \u2208 R.F b \u2192 (\u2200\u1da0 x in f, m x \u2208 R.F b)) \u2192 Tendsto m f (\ud835\udcdd a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_interior_subset_closure {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2192 \u2203 b, a \u2208 R.F b \u2227 R.F b \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isClosed_union {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s t : R.\u03c3} :\n    IsClosed (R.F s \u222a R.F t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_inter {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s t : R.\u03c3} :\n    IsOpen (interior (R.F s) \u2229 interior (R.F t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.closed_union {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {R : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (L : LocallyFinite.Realizer R f) :\n    LocallyFinite (fun i => closure (f i)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iInter_closure {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 R.\u03c3} :\n    IsOpen (\u22c2 i, closure (R.F (g i))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.mem_closure_iff {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 closure s \u2194 \u2200 b, a \u2208 R.F b \u2192 (R.F b \u2229 s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem LocallyFinite.Realizer.finite_nbhd {\u03b1 \u03b2 : Type*}\n    [TopologicalSpace \u03b1] {R : Ctop.Realizer \u03b1} {f : \u03b2 \u2192 Set \u03b1}\n    (L : LocallyFinite.Realizer R f) (a : \u03b1) :\n    Finite { i | (f i \u2229 interior (R.F (L.bas a))).Nonempty } := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem Realizer.isOpen_iUnion_closure' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]\n    (R : Ctop.Realizer \u03b1) {g : \u03b2 \u2192 R.\u03c3} :\n    IsOpen (\u22c3 i, closure (interior (R.F (g i)))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03c3 : Type*} {\u03c4 : Type*}\nvariable (F : Ctop \u03b1 \u03c3)\nvariable [TopologicalSpace \u03b1]\n\nopen Ctop Topology Realizer Set Filter hiding\ntheorem ext_basis_open_subset {\u03b1 : Type*} [T : TopologicalSpace \u03b1]\n    {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (hopen : \u2200 b, IsOpen (F b))\n    (hbasis : \u2200 x, \u2200 s \u2208 \ud835\udcdd x, \u2203 b, x \u2208 F b \u2227 F b \u2286 s) :\n    F.toTopsp \u2264 T := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem filter_comm_subset {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] (s : Finset \u03b1) : (s.filter p).filter q \u2286 (s.filter q).filter p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem filter_card_pos_iff {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {s : Finset \u03b1} : 0 < (s.filter p).card \u2194 \u2203 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem filter_subset_iff {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {s t : Finset \u03b1} : s.filter p \u2286 t \u2194 \u2200 x \u2208 s, p x \u2192 x \u2208 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem subset_filter_iff {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {t s : Finset \u03b1} : t \u2286 s.filter p \u2194 t \u2286 s \u2227 \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem coe_filter_subset {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] (s : Finset \u03b1) : (\u2191(s.filter p) : Set \u03b1) \u2286 (\u2191s : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem filter_card_lt_card_of_exists_not {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {s : Finset \u03b1} (h : \u2203 x \u2208 s, \u00acp x) : (s.filter p).card < s.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem monotone_filter_card {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {s t : Finset \u03b1} (h : s \u2286 t) : (s.filter p).card \u2264 (t.filter p).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem filter_subset_card_lt {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {s : Finset \u03b1} (h : \u2203 x \u2208 s, \u00acp x) : (s.filter p).card < s.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\n\ntheorem filter_subset_and_pred_imp {\u03b1 : Type*} {p q : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred q] {s : Finset \u03b1} (h : \u2200 x \u2208 s, p x \u2192 q x) : s.filter p \u2286 s.filter q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_filter_card_eq {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    (s : Finset \u03b1) : ((s.filter p).filter p).card = (s.filter p).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem coe_subset_of_filter {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    (s : Finset \u03b1) : (\u2191s : Set \u03b1) \u2286 (\u2191(s.filter p) : Set \u03b1) \u222a {x | \u00acp x} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_lt_of_filter_proper_subset {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card < s.card) : (\u2203 x \u2208 s, \u00acp x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_of_filter_filter {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q]\n    (s : Finset \u03b1) : (s.filter p).filter q \u2286 s.filter (fun x \u21a6 p x \u2227 q x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem exists_not_of_card_ne {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card \u2260 s.card) : \u2203 x \u2208 s, \u00ac p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_subset_iff_mem {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {s t : Finset \u03b1} : s.filter p \u2286 t \u2194 \u2200 x, p x \u2192 x \u2208 s \u2192 x \u2208 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_of_double_filter {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] (s : Finset \u03b1) : (s.filter p).filter q \u2286 s.filter (fun x \u21a6 q x \u2227 p x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_subset {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} :\n    t \u2286 s.filter p \u2192 t \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_card_eq_of_forall {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop)\n    [DecidablePred p] [DecidablePred q] {s : Finset \u03b1}\n    (h : \u2200 x \u2208 s, p x = q x) :\n    (s.filter p).card = (s.filter q).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_union_complement {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    (s : Finset \u03b1) :\n    (\u2191s : Set \u03b1) = (\u2191(s.filter p) : Set \u03b1) \u222a {x | \u00ac p x} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_imp_forall {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_of_double_filter {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q]\n    (s : Finset \u03b1) :\n    (s.filter p).filter q \u2286 s.filter (fun x \u21a6 q x \u2227 p x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} :\n    t \u2286 s.filter p \u2192 \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_card_sub_eq {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    (s : Finset \u03b1) :\n    s.card - (s.filter p).card = (s.filter fun x \u21a6 \u00acp x).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_subset_card_le {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s t : Finset \u03b1} (h : s \u2286 t) :\n    (s.filter p).card \u2264 t.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_card_lt_iff_exists_not {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {s : Finset \u03b1} :\n    (s.filter p).card < s.card \u2194 \u2203 x \u2208 s, \u00acp x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_subset_and_pred_imp_card {\u03b1 : Type*} {p q : \u03b1 \u2192 Prop}\n    [DecidablePred p] [DecidablePred q] {s : Finset \u03b1}\n    (h : \u2200 x \u2208 s, p x \u2192 q x) :\n    (s.filter p).card \u2264 (s.filter q).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_eq_of_pointwise_imp_card {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop)\n    [DecidablePred p] [DecidablePred q] {s : Finset \u03b1}\n    (h : \u2200 x \u2208 s, p x \u2194 q x) :\n    (s.filter p).card = (s.filter q).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_two_step_card_le {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop)\n    [DecidablePred p] [DecidablePred q] (s : Finset \u03b1) :\n    ((s.filter p).filter q).card \u2264 (s.filter fun x \u21a6 p x \u2227 q x).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_subset_imp_subset_set {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {t s : Finset \u03b1} :\n    t \u2286 s.filter p \u2192 (\u2191t : Set \u03b1) \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_imp_forall_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem my_subset_filter_iff {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} :\n    t \u2286 s.filter p \u2194 \u2200 x, x \u2208 t \u2192 x \u2208 s \u2227 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem my_filter_card_le_of_exists_not {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : \u2203 x \u2208 s, \u00ac p x) :\n    (s.filter p).card \u2264 s.card - 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem my_strict_mono_filter_card {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s t : Finset \u03b1} (h : s \u2282 t) :\n    (s.filter p).card < (t.filter p).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem my_elements_split_by_filter {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    (s : Finset \u03b1) :\n    (\u2191s : Set \u03b1) = (\u2191(s.filter p) : Set \u03b1) \u222a (\u2191(s.filter fun x \u21a6 \u00ac p x) : Set \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem my_card_eq_imp_all_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem my_subset_filter_imp_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} :\n    t \u2286 s.filter p \u2192 \u2200 x, x \u2208 t \u2192 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem my_card_eq_filter_full_imp {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : s.card = (s.filter p).card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_subset_card_le {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} :\n    (s.filter p).card \u2264 s.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_imp_all_pred_alt {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred_alt {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} (h : t \u2286 s.filter p) :\n    \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_imp_forall_pred_alt {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem our_card_eq_imp_all_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem our_subset_filter_imp_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} (h : t \u2286 s.filter p) :\n    \u2200 x, x \u2208 t \u2192 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem our_card_eq_filter_full_imp {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {s : Finset \u03b1} (h : s.card = (s.filter p).card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_card_nonzero_iff {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} : (s.filter p).card \u2260 0 \u2194 \u2203 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp' {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} : t \u2286 s.filter p \u2192 (t \u2286 s \u2227 \u2200 x \u2208 t, p x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_mem_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} : t \u2286 s.filter p \u2192 \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_imp_all_pred' {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) : \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_filter_full_imp' {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : s.card = (s.filter p).card) : \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_imp_pred_all_alt2 {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {s : Finset \u03b1}\n    (h : (s.filter p).card = s.card) : \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred_alt2 {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {t s : Finset \u03b1} (h : t \u2286 s.filter p) : \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem two_step_filter_card_le_alt {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop)\n    [DecidablePred p] [DecidablePred q] (s : Finset \u03b1) :\n    ((s.filter q).filter p).card \u2264 (s.filter fun x \u21a6 p x \u2227 q x).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_imp_forall_pred_rev {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {s : Finset \u03b1} (h : s.card = (s.filter p).card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_card_ge_one_iff {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] {s : Finset \u03b1} :\n    1 \u2264 (s.filter p).card \u2194 \u2203 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_zero_imp_no_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = 0) : \u2200 x \u2208 s, \u00ac p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_full_imp_all_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) : \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred' {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} (h : t \u2286 s.filter p) : \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_forall_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {t s : Finset \u03b1} (h : t \u2286 s.filter p) :\n    \u2200 x, x \u2208 t \u2192 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_eq_full_imp_all_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {s : Finset \u03b1}\n    (h : s.card = (s.filter p).card) : \u2200 x, x \u2208 s \u2192 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_full_implies_all {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] {s : Finset \u03b1}\n    (h : (s.filter p).card = s.card) :\n    \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_of_filter_subset {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s t : Finset \u03b1} :\n    s.filter p \u2286 t \u2192 s \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred_all {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} (h : t \u2286 s.filter p) :\n    \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem mem_filter_of_mem_and_pred {\u03b1 : Type*} {p : \u03b1 \u2192 Prop} [DecidablePred p]\n    {s : Finset \u03b1} {a : \u03b1}\n    (hs : a \u2208 s) (hp : p a) :\n    a \u2208 s.filter p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_of_filter_filter {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [DecidablePred p]\n    [DecidablePred q] (s : Finset \u03b1) :\n    (s.filter p).filter q \u2286 s.filter (fun x \u21a6 p x \u2227 q x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} (h : t \u2286 s.filter p) :\n    \u2200 x, x \u2208 t \u2192 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_two_step_card_le {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [DecidablePred p]\n    [DecidablePred q] (s : Finset \u03b1) :\n    ((s.filter p).filter q).card \u2264 (s.filter fun x \u21a6 p x \u2227 q x).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} : t \u2286 s.filter p \u2192 \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_comm_subset {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop) [DecidablePred p]\n    [DecidablePred q] (s : Finset \u03b1) : (s.filter p).filter q \u2286 (s.filter q).filter p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem filter_card_sub_eq {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    (s : Finset \u03b1) : s.card - (s.filter p).card = (s.filter fun x \u21a6 \u00ac p x).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_of_filter_filter {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop)\n    [DecidablePred p] [DecidablePred q] (s : Finset \u03b1) :\n    (s.filter p).filter q \u2286 s.filter (fun x \u21a6 p x \u2227 q x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem exists_not_of_card_ne {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card \u2260 s.card) : \u2203 x \u2208 s, \u00ac p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem card_full_imp_all_pred {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {s : Finset \u03b1} (h : (s.filter p).card = s.card) : \u2200 x \u2208 s, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\nvariable (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] {s t : Finset \u03b1}\nvariable {p}\nvariable (p)\nvariable {p q}\nvariable (p q)\n\nopen Elab Term Batteries.ExtendedBinder Subtype Multiset Lean Meta Function\ntheorem subset_filter_imp_pred_all {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {t s : Finset \u03b1} (h : t \u2286 s.filter p) : \u2200 x \u2208 t, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem card_disjSum_comm {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2) :\n    (s.disjSum t).card = (t.disjSum s).card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem card_toRight_add_card_toLeft {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    u.toRight.card + u.toLeft.card = u.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem toLeft_map_subset {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.toLeft.map Embedding.inl) \u2286 u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem toRight_map_subset {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.toRight.map Embedding.inr) \u2286 u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem disjSum_subset_iff {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} :\n    s\u2081.disjSum t\u2081 \u2286 s\u2082.disjSum t\u2082 \u2194 s\u2081 \u2286 s\u2082 \u2227 t\u2081 \u2286 t\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem disjSum_ssubset_iff {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} :\n    s\u2081.disjSum t\u2081 \u2282 s\u2082.disjSum t\u2082 \u2194 (s\u2081 \u2282 s\u2082 \u2227 t\u2081 \u2286 t\u2082) \u2228 (s\u2081 \u2286 s\u2082 \u2227 t\u2081 \u2282 t\u2082) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem card_toLeft_eq_card_iff {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    u.toLeft.card = u.card \u2194 u.toRight = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem card_toRight_eq_card_iff {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    u.toRight.card = u.card \u2194 u.toLeft = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem disjSum_eq_iff_left {\u03b1 \u03b2 : Type*} {s : Finset \u03b1} {t : Finset \u03b2} :\n    s.disjSum t = s.disjSum (\u2205 : Finset \u03b2) \u2194 t = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\n\ntheorem disjSum_eq_iff_right {\u03b1 \u03b2 : Type*} {s : Finset \u03b1} {t : Finset \u03b2} :\n    s.disjSum t = (\u2205 : Finset \u03b1).disjSum t \u2194 s = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem card_disjSum_add_comm {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2) :\n    (s.disjSum t).card = t.card + s.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toLeft_erase_inl_subset {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2]\n    (u : Finset (\u03b1 \u2295 \u03b2)) (a : \u03b1) :\n    (u.erase (inl a)).toLeft \u2286 u.toLeft := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toRight_erase_inr_subset {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2]\n    (u : Finset (\u03b1 \u2295 \u03b2)) (b : \u03b2) :\n    (u.erase (inr b)).toRight \u2286 u.toRight := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_left_iff {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t : Finset \u03b2} :\n    s\u2081.disjSum t \u2286 s\u2082.disjSum t \u2194 s\u2081 \u2286 s\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toLeft_erase_inl_card_le {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2]\n    (u : Finset (\u03b1 \u2295 \u03b2)) (a : \u03b1) :\n    (u.erase (Sum.inl a)).toLeft.card \u2264 u.toLeft.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toRight_erase_inr_card_le {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2]\n    (u : Finset (\u03b1 \u2295 \u03b2)) (b : \u03b2) :\n    (u.erase (Sum.inr b)).toRight.card \u2264 u.toRight.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_self_card_double {\u03b1 : Type*} (s : Finset \u03b1) :\n    (s.disjSum s).card = 2 * s.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toLeft_map_subset_disjSum {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.toLeft.map Embedding.inl) \u2286 u.toLeft.disjSum u.toRight := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toRight_map_subset_disjSum {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.toRight.map Embedding.inr) \u2286 u.toLeft.disjSum u.toRight := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_right_only_iff {\u03b1 \u03b2 : Type*} {s : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} :\n    s.disjSum t\u2081 \u2286 s.disjSum t\u2082 \u2194 t\u2081 \u2286 t\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toLeft_image_sumComm_subset {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2]\n    (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.image (Equiv.sumComm _ _).toEmbedding).toLeft \u2286 u.toRight := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toRight_image_sumComm_subset {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2]\n    (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.image (Equiv.sumComm _ _).toEmbedding).toRight \u2286 u.toLeft := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_left_refl {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t : Finset \u03b2} :\n    s\u2081 \u2286 s\u2082 \u2192 s\u2081.disjSum t \u2286 s\u2082.disjSum t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_left_refl' {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t : Finset \u03b2} :\n    s\u2081 \u2286 s\u2082 \u2192 s\u2081.disjSum t \u2286 s\u2082.disjSum t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_left_refl_alt {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t : Finset \u03b2} :\n    s\u2081 \u2286 s\u2082 \u2192 s\u2081.disjSum t \u2286 s\u2082.disjSum t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_left {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t : Finset \u03b2} :\n    s\u2081 \u2286 s\u2082 \u2192 s\u2081.disjSum t \u2286 s\u2082.disjSum t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_right {\u03b1 \u03b2 : Type*} {s : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} :\n    t\u2081 \u2286 t\u2082 \u2192 s.disjSum t\u2081 \u2286 s.disjSum t\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toLeft_map_subset_disjSum {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.toLeft.map Embedding.inl) \u2286 u.toLeft.disjSum u.toRight := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem toRight_map_subset_disjSum {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    (u.toRight.map Embedding.inr) \u2286 u.toLeft.disjSum u.toRight := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_eq_empty_left {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2) :\n    s.disjSum t = \u2205 \u2192 s = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_eq_empty_right {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2) :\n    s.disjSum t = \u2205 \u2192 t = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem card_toLeft_eq_of_toRight_empty {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    u.toRight = \u2205 \u2192 u.toLeft.card = u.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem card_toRight_eq_of_toLeft_empty {\u03b1 \u03b2 : Type*} (u : Finset (\u03b1 \u2295 \u03b2)) :\n    u.toLeft = \u2205 \u2192 u.toRight.card = u.card := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 : Type*} (s : Finset \u03b1) (t : Finset \u03b2)\nvariable {s t} {s\u2081 s\u2082 : Finset \u03b1} {t\u2081 t\u2082 : Finset \u03b2} {a : \u03b1} {b : \u03b2} {x : \u03b1 \u2295 \u03b2}\nvariable {u v : Finset (\u03b1 \u2295 \u03b2)}\nvariable [DecidableEq \u03b1] [DecidableEq \u03b2]\n\nopen Function Multiset Sum\ntheorem disjSum_subset_left_refl_rule {\u03b1 \u03b2 : Type*} {s\u2081 s\u2082 : Finset \u03b1} {t : Finset \u03b2} :\n    s\u2081 \u2286 s\u2082 \u2192 s\u2081.disjSum t \u2286 s\u2082.disjSum t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\n\ntheorem sqrt_sq_eq_abs (q : \u211a) : Rat.sqrt (q ^ 2) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\n\ntheorem sqrt_abs_mul_self (q : \u211a) : Rat.sqrt (|q| * |q|) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\n\ntheorem exists_pow_two (x : \u211a) : (\u2203 q : \u211a, q ^ 2 = x) \u2194 Rat.sqrt x ^ 2 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\n\ntheorem isSquare_iff_sqrt_pow_two (m : \u211a) : IsSquare m \u2194 Rat.sqrt m ^ 2 = m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\n\ntheorem sqrt_ofNat_le_self (n : \u2115) : Rat.sqrt (n : \u211a) \u2264 n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\n\ntheorem sqrt_intCast_pow_two (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 2) = Int.sqrt (z ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_neg_mul_neg_eq_abs (q : \u211a) : Rat.sqrt ((-q) * (-q)) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_four_eq_abs_sq (q : \u211a) : Rat.sqrt (q ^ 4) = |q| ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem exists_sq_iff_sqrt_pow_two (x : \u211a) : (\u2203 q : \u211a, q * q = x) \u2194 Rat.sqrt x ^ 2 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem isSquare_iff_sqrt_mul_self (m : \u211a) : IsSquare m \u2194 Rat.sqrt m * Rat.sqrt m = m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_four (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 4) = Int.sqrt (z ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_le_abs (q : \u211a) : Rat.sqrt (q * q) \u2264 |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem exists_pow_four_imp (x : \u211a) : (\u2203 q : \u211a, q ^ 4 = x) \u2192 Rat.sqrt x ^ 4 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_pow_two_eq_abs (q : \u211a) : Rat.sqrt (|q| ^ 2) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_mul_self_eq_int (z : \u2124) : Rat.sqrt ((z : \u211a) * z) = Int.sqrt (z * z) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_neg_pow_two_eq_abs (q : \u211a) : Rat.sqrt ((-q) ^ 2) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_four_eq_abs_product (q : \u211a) : Rat.sqrt (q ^ 4) = |q| * |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem exists_sq_iff_sqrt_mul_self (x : \u211a) : (\u2203 q : \u211a, q ^ 2 = x) \u2194 Rat.sqrt x * Rat.sqrt x = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_six_eq_int (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 6) = Int.sqrt (z ^ 6) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem exists_pow_four_imp_sqrt_sq (x : \u211a) : (\u2203 q : \u211a, q ^ 4 = x) \u2192 (Rat.sqrt x ^ 2) ^ 2 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_mul_eq_abs (q : \u211a) : Rat.sqrt (|q| * q) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_le_abs' (q : \u211a) : Rat.sqrt (q ^ 2) \u2264 |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_mul_abs_eq_abs (q : \u211a) : Rat.sqrt (q * |q|) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_two_eq_int_sqrt (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 2) = Int.sqrt (z * z) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_neg_mul_self_eq_abs (q : \u211a) : Rat.sqrt ((-q) * q) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_eight_eq_int (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 8) = Int.sqrt (z ^ 8) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_six_eq_abs_cubic (q : \u211a) : Rat.sqrt (q ^ 6) = |q| ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_pow_four_eq_abs_sq (q : \u211a) : Rat.sqrt (|q| ^ 4) = |q| ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_le_abs (n : \u2115) : Rat.sqrt (n : \u211a) \u2264 |(n : \u211a)| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_sq (z : \u2124) : Rat.sqrt ((z : \u211a) * (z : \u211a)) = Int.sqrt (z ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_fourth (q : \u211a) : Rat.sqrt (q ^ 4) = (Rat.sqrt (q ^ 2)) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_eight_eq_abs_fourth (q : \u211a) : Rat.sqrt (q ^ 8) = |q| ^ 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_le_abs (n : \u2115) : Rat.sqrt (n : \u211a) \u2264 |(n : \u211a)| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_mul_self_pow_four_eq (q : \u211a) : Rat.sqrt ((q * q) ^ 2) = |q| ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_lt_succ (n : \u2115) : Rat.sqrt (n : \u211a) < n + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_two_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_four_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_mul_self_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) * z) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_six_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 6) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_sq_pow_two_eq (q : \u211a) : (Rat.sqrt (q ^ 2)) ^ 2 = |q| ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_eight_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 8) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_sq_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) * (z : \u211a)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_mul_neg_eq_abs (q : \u211a) : Rat.sqrt (|q| * (-q)) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_le_succ (n : \u2115) : Rat.sqrt (n : \u211a) \u2264 n + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_mul_neg_eq_abs (q : \u211a) : Rat.sqrt (q * (-q)) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_ten_eq_abs_quintic (q : \u211a) : Rat.sqrt (q ^ 10) = |q| ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_twelve_eq_int (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 12) = Int.sqrt (z ^ 12) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_pow_six_eq_abs_cubic (q : \u211a) : Rat.sqrt (|q| ^ 6) = |q| ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_le_abs_add_one (q : \u211a) : Rat.sqrt (q ^ 2) \u2264 |q| + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_lt_next (n : \u2115) : Rat.sqrt (n : \u211a) < n + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_twelve_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 12) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_sq_pow_four_eq_abs_sq (q : \u211a) : Rat.sqrt ((q ^ 2) ^ 2) = |q| ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_natCast_le_nat_succ (n : \u2115) : Rat.sqrt (n : \u211a) \u2264 n.succ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_mul_self_pow_two_eq_abs (q : \u211a) : Rat.sqrt ((q * q) ^ 1) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_le_abs_succ (n : \u2115) : Rat.sqrt (n : \u211a) \u2264 |(n : \u211a)| + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_two_eq_int_abs (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 2) = |(z : \u2124)| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem exists_pow_four_iff_sqrt_fourth (x : \u211a) : (\u2203 q : \u211a, q ^ 4 = x) \u2194 Rat.sqrt x ^ 4 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_six_eq_int_abs (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 6) = |(z : \u2124)| ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_neg_pow_two_le_abs (q : \u211a) : Rat.sqrt ((-q) ^ 2) \u2264 |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_four_le_abs_sq (q : \u211a) : Rat.sqrt (q ^ 4) \u2264 |q| ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_eight_eq_int_abs (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 8) = |(z : \u2124)| ^ 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_mul_self_le_abs (q : \u211a) : Rat.sqrt (|q| * |q|) \u2264 |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_lt_nat_succ (n : \u2115) : Rat.sqrt (n : \u211a) < n.succ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_pow_three_eq_abs (q : \u211a) : Rat.sqrt (|q| ^ 3) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem exists_pow_three (x : \u211a) : (\u2203 q : \u211a, q ^ 3 = x) \u2194 Rat.sqrt x ^ 3 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem isCube_iff_sqrt_pow_three (m : \u211a) : (\u2203 q : \u211a, q ^ 3 = m) \u2194 Rat.sqrt m ^ 3 = m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_three (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 3) = Int.sqrt (z ^ 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_six_le_abs_cubic (q : \u211a) : Rat.sqrt (q ^ 6) \u2264 |q| ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_five_eq_int (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 5) = Int.sqrt (z ^ 5) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_seven_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 7) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_sq_pow_three_eq (q : \u211a) : (Rat.sqrt (q ^ 3)) ^ 2 = Rat.sqrt (q ^ 6) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_lt_double (n : \u2115) : Rat.sqrt (n : \u211a) < 2 * n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_le_abs_plus_one (q : \u211a) : Rat.sqrt (q * q) \u2264 |q| + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_three_nonneg (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_ofNat_lt_twice_succ (n : \u2115) : Rat.sqrt (n : \u211a) < 2 * (n.succ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_twelve_nonneg_var (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 12) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_pow_twelve_eq_abs_sixth (q : \u211a) : Rat.sqrt (q ^ 12) = |q| ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem exists_pow_eight_iff_sqrt_eighth (x : \u211a) : (\u2203 r : \u211a, r ^ 8 = x) \u2194 Rat.sqrt x ^ 8 = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_four_eq_int_abs_sq (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 4) = |(z : \u2124)| ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_sq_eq_abs' (q : \u211a) : Rat.sqrt ((q ^ 1) * q) = |q| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_ten_eq_int_sqrt (z : \u2124) : Rat.sqrt ((z : \u211a) ^ 10) = Int.sqrt (z ^ 10) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_intCast_pow_twelve_nonneg' (z : \u2124) : 0 \u2264 Rat.sqrt ((z : \u211a) ^ 12) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\n\ntheorem sqrt_abs_pow_twelve_eq_abs_sixth (q : \u211a) : Rat.sqrt (|q| ^ 12) = |q| ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem ext_cauchy_ne {x y : Real} : x \u2260 y \u2194 x.cauchy \u2260 y.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem ofCauchy_add_comm (a b) : (\u27e8a + b\u27e9 : \u211d) = (\u27e8b\u27e9 : \u211d) + \u27e8a\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem ofCauchy_mul_comm (a b) : (\u27e8a * b\u27e9 : \u211d) = (\u27e8b\u27e9 : \u211d) * \u27e8a\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem cauchy_add_comm (a b : \u211d) : (a + b : \u211d).cauchy = (b + a : \u211d).cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem ofCauchy_pow_two (a) : (\u27e8a ^ 2\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem cauchy_pow_two (a : \u211d) : (a ^ 2 : \u211d).cauchy = a.cauchy ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem ofCauchy_div_mul (f g) : ((\u27e8f / g\u27e9 : \u211d) * \u27e8g\u27e9) = (\u27e8f\u27e9 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem ofCauchy_natCast_pos (n : \u2115) : 0 < (n.succ : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\n\ntheorem ext_zero_cauchy {x : \u211d} : x = 0 \u2194 x.cauchy = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_one_cauchy {x : \u211d} : x = 1 \u2194 x.cauchy = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_sub_comm (a b) : (\u27e8a - b\u27e9 : \u211d) = \u27e8b\u27e9 - \u27e8a\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_sub_self (a : \u211d) : (a - a : \u211d).cauchy = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_inv_one : ((1 : \u211d)\u207b\u00b9).cauchy = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_three (a) : (\u27e8a ^ 3\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_neg_neg_neg (x : \u211d) : (- - -x : \u211d).cauchy = -x.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_four (a) : (\u27e8a ^ 4\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_four (a : \u211d) : (a ^ 4 : \u211d).cauchy = a.cauchy ^ 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_div (f g) : ((\u27e8f * g\u27e9 : \u211d) / \u27e8g\u27e9) = (\u27e8f\u27e9 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_two_cauchy {x : \u211d} : x = 2 \u2194 x.cauchy = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_neg_one_cauchy {x : \u211d} : x = -1 \u2194 x.cauchy = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_zero_sub (a : \u211d) : (0 - a : \u211d).cauchy = -a.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_div_self (a : \u211d) : (a / a : \u211d).cauchy = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_five (a) : (\u27e8a ^ 5\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_two_alt (a) : (\u27e8a ^ 2\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) * \u27e8a\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_two_alt (a : \u211d) : (a ^ 2 : \u211d).cauchy = a.cauchy * a.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_div_swap (f g) : (\u27e8g\u27e9 : \u211d) * (\u27e8f / g\u27e9 : \u211d) = (\u27e8f\u27e9 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_zero_of_cauchy (x : \u211d) : x.cauchy = 0 \u2192 x = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_one_of_cauchy (x : \u211d) : x.cauchy = 1 \u2192 x = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_two_of_cauchy (x : \u211d) : x.cauchy = 2 \u2192 x = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_neg_one_of_cauchy (x : \u211d) : x.cauchy = -1 \u2192 x = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_add_assoc (a b c) : (\u27e8(a + b) + c\u27e9 : \u211d) = ((\u27e8a\u27e9 : \u211d) + (\u27e8b\u27e9 : \u211d)) + \u27e8c\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_assoc (a b c) : (\u27e8(a * b) * c\u27e9 : \u211d) = ((\u27e8a\u27e9 : \u211d) * (\u27e8b\u27e9 : \u211d)) * \u27e8c\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_add_assoc (a b c : \u211d) : (((a + b) + c) : \u211d).cauchy = a.cauchy + b.cauchy + c.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_neg_zero : (- (0 : \u211d)).cauchy = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_zero (a) : (\u27e8a ^ 0\u27e9 : \u211d) = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_inv_mul (f : \u211d) : (f\u207b\u00b9 * f : \u211d).cauchy = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_sub_self (a) : (\u27e8a - a\u27e9 : \u211d) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_mul_zero (a : \u211d) : (a * 0 : \u211d).cauchy = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_six (a) : (\u27e8a ^ 6\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_six (a : \u211d) : (a ^ 6 : \u211d).cauchy = a.cauchy ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_inv (f g) : ((\u27e8f * g\u27e9 : \u211d) * (\u27e8g\u27e9 : \u211d)\u207b\u00b9) = (\u27e8f\u27e9 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_three_cauchy {x : \u211d} : x = 3 \u2194 x.cauchy = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_neg_two_cauchy {x : \u211d} : x = -2 \u2194 x.cauchy = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_mul_two (a : \u211d) : (a * 2 : \u211d).cauchy = (2 * a : \u211d).cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_seven (a) : (\u27e8a ^ 7\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_div_mul_right (f g) : ((\u27e8f / g\u27e9 : \u211d) / \u27e8g\u27e9) = ((\u27e8f\u27e9 : \u211d) / \u27e8g\u27e9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_neg_two_of_cauchy (x : \u211d) : x.cauchy = -2 \u2192 x = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_neg_three_of_cauchy (x : \u211d) : x.cauchy = -3 \u2192 x = -3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_add_commuted (a b : \u211d) : (a + b : \u211d).cauchy = b.cauchy + a.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_squared (a) : (\u27e8a * a\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_squared (a : \u211d) : (a * a : \u211d).cauchy = a.cauchy ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem eq_of_cauchy_one (x : \u211d) : x.cauchy = 1 \u2192 x = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_add_assoc_alt (a b c) : (\u27e8a + (b + c)\u27e9 : \u211d) = \u27e8a\u27e9 + (\u27e8b\u27e9 + \u27e8c\u27e9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_assoc_alt (a b c) : (\u27e8a * (b * c)\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) * ((\u27e8b\u27e9 : \u211d) * \u27e8c\u27e9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_add_assoc_alt (a b c : \u211d) : ((a + (b + c)) : \u211d).cauchy = a.cauchy + b.cauchy + c.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_mul_inv (f : \u211d) : (f * f\u207b\u00b9 : \u211d).cauchy = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_zero_mul (a : \u211d) : (0 * a : \u211d).cauchy = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_five_neg (x : \u211d) : (- - - - -x : \u211d).cauchy = -x.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_mul_comm (a b : \u211d) : (a * b : \u211d).cauchy = (b * a : \u211d).cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_cubed (a : \u211d) : (a ^ 3 : \u211d).cauchy = a.cauchy ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_zero (a) : (\u27e8a * 0\u27e9 : \u211d) = (0 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_div_as_mul_inv (f g) : (\u27e8f / g\u27e9 : \u211d) = (\u27e8f\u27e9 : \u211d) * (\u27e8g\u27e9 : \u211d)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_four_cauchy {x : \u211d} : x = 4 \u2194 x.cauchy = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_neg_four_cauchy {x : \u211d} : x = -4 \u2194 x.cauchy = -4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_mul_comm' (a b : \u211d) : (a * b : \u211d).cauchy = b.cauchy * a.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_left_zero (a) : (\u27e80 * a\u27e9 : \u211d) = (0 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_mul_assoc_left (a b c : \u211d) : (a * (b * c) : \u211d).cauchy = a.cauchy * b.cauchy * c.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_five (a : \u211d) : (a ^ 5 : \u211d).cauchy = a.cauchy ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_seven (a : \u211d) : (a ^ 7 : \u211d).cauchy = a.cauchy ^ 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_one (a : \u211d) : (a ^ 1 : \u211d).cauchy = a.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_inv_zero : (\u27e8(0 : \u211a)\u207b\u00b9\u27e9 : \u211d) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_two_mul (a : \u211d) : (2 * a : \u211d).cauchy = a.cauchy * 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_neg_three_cauchy {x : \u211d} : x = -3 \u2194 x.cauchy = -3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_one_of_cauchy_alt (x : \u211d) : x.cauchy = 1 \u2192 x = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_neg_three_of_cauchy_alt (x : \u211d) : x.cauchy = -3 \u2192 x = -3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem eq_of_cauchy_one_alt (x : \u211d) : x.cauchy = 1 \u2192 x = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_eq_three_of_cauchy (x : \u211d) : x.cauchy = 3 \u2192 x = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\nofCauchy_pow_eight (a) : (\u27e8a ^ 8\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\ncauchy_pow_eight (a : \u211d) : (a ^ 8 : \u211d).cauchy = a.cauchy ^ 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\nofCauchy_pow_nine (a) : (\u27e8a ^ 9\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\ncauchy_pow_nine (a : \u211d) : (a ^ 9 : \u211d).cauchy = a.cauchy ^ 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\nofCauchy_mul_div_left (f g) : ((\u27e8f * g\u27e9 : \u211d) / \u27e8f\u27e9) = (\u27e8g\u27e9 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\ncauchy_seven_neg (x : \u211d) : (- - - - - - -x : \u211d).cauchy = -x.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\nofCauchy_pow_ten (a) : (\u27e8a ^ 10\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 10 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\ncauchy_pow_ten (a : \u211d) : (a ^ 10 : \u211d).cauchy = a.cauchy ^ 10 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\ncauchy_eq_four_of_cauchy (x : \u211d) : x.cauchy = 4 \u2192 x = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\next_five_cauchy {x : \u211d} : x = 5 \u2194 x.cauchy = 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\next_neg_five_cauchy {x : \u211d} : x = -5 \u2194 x.cauchy = -5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem\nofCauchy_zero_add_symm (a) : (\u27e8a + 0\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem mk_eq_zero_iff (f : CauSeq \u211a abs) : Real.mk f = 0 \u2194 f \u2248 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem mk_eq_one_iff (f : CauSeq \u211a abs) : Real.mk f = 1 \u2194 f \u2248 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_inv_zero : ((0 : \u211d)\u207b\u00b9).cauchy = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_zero (a) : (\u27e8a ^ 0\u27e9 : \u211d) = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_zero_add (a : \u211d) : (a + 0 : \u211d).cauchy = a.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_zero_add (a) : (\u27e8a + 0\u27e9 : \u211d) = \u27e8a\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_five (a : \u211d) : (a ^ 5 : \u211d).cauchy = a.cauchy ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_five (a) : (\u27e8a ^ 5\u27e9 : \u211d) = \u27e8a\u27e9 ^ 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_six (a : \u211d) : (a ^ 6 : \u211d).cauchy = a.cauchy ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_six (a) : (\u27e8a ^ 6\u27e9 : \u211d) = \u27e8a\u27e9 ^ 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_seven (a : \u211d) : (a ^ 7 : \u211d).cauchy = a.cauchy ^ 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_seven (a) : (\u27e8a ^ 7\u27e9 : \u211d) = \u27e8a\u27e9 ^ 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_eight (a : \u211d) : (a ^ 8 : \u211d).cauchy = a.cauchy ^ 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_eight (a) : (\u27e8a ^ 8\u27e9 : \u211d) = \u27e8a\u27e9 ^ 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_nine (a : \u211d) : (a ^ 9 : \u211d).cauchy = a.cauchy ^ 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_nine (a) : (\u27e8a ^ 9\u27e9 : \u211d) = \u27e8a\u27e9 ^ 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_ten (a : \u211d) : (a ^ 10 : \u211d).cauchy = a.cauchy ^ 10 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_ten (a) : (\u27e8a ^ 10\u27e9 : \u211d) = \u27e8a\u27e9 ^ 10 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_three_neg (a) : (\u27e8- - -a\u27e9 : \u211d) = -\u27e8a\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_two_mul (a : \u211d) : (2 * a : \u211d).cauchy = a.cauchy * 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_two_mul (a) : (\u27e82 * a\u27e9 : \u211d) = (2 : \u211d) * \u27e8a\u27e9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_mul_assoc (a b c : \u211d) : ((a * b) * c : \u211d).cauchy = a.cauchy * b.cauchy * c.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_three_alt (a) : (\u27e8a ^ 3\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) * \u27e8a\u27e9 ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_three_alt (a : \u211d) : (a ^ 3 : \u211d).cauchy = a.cauchy * a.cauchy ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ext_cauchy_one {x : \u211d} : (x.cauchy = 1) \u2192 (x = 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_pow_four_alt (a) : (\u27e8a ^ 4\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) ^ 2 * (\u27e8a\u27e9 : \u211d) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_pow_four_alt (a : \u211d) : (a ^ 4 : \u211d).cauchy = a.cauchy ^ 2 * a.cauchy ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_two_mul_left (a : \u211d) : (2 * a : \u211d).cauchy = 2 * a.cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem mk_eq_two_iff (f : CauSeq \u211a abs) : Real.mk f = 2 \u2194 f \u2248 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem mk_eq_neg_one_iff (f : CauSeq \u211a abs) : Real.mk f = -1 \u2194 f \u2248 -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_sub_comm (a b : \u211d) : (a - b : \u211d).cauchy = (b - a : \u211d).cauchy := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_add_neg (x : \u211d) : (x + -x : \u211d).cauchy = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_inv_one : (\u27e8(1 : \u211a)\u207b\u00b9\u27e9 : \u211d) = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem ofCauchy_mul_assoc_left (a b c) : (\u27e8a * (b * c)\u27e9 : \u211d) = (\u27e8a\u27e9 : \u211d) * (\u27e8b\u27e9 : \u211d) * (\u27e8c\u27e9 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem mk_eq_nat_iff (f : CauSeq \u211a abs) (n : \u2115) : Real.mk f = n \u2194 f \u2248 n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x : \u211d}\n\nopen CauSeq.Completion in scoped CauSeq Classical\ntheorem cauchy_two_mul_right (a : \u211d) : (a * 2 : \u211d).cauchy = a.cauchy * 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem neg_inv_gold : \u03c8 = -\u03c6\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem neg_inv_goldConj : \u03c6 = -\u03c8\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_div_neg_one_eq_goldConj : \u03c6 / (-1 : \u211d) = \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_add_goldConj_comm : \u03c8 + \u03c6 = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem goldConj_sub_gold : \u03c8 - \u03c6 = -\u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem goldConj_pow_sub_goldConj_pow (n : \u2115) : \u03c8 ^ (n + 2) - \u03c8 ^ (n + 1) = \u03c8 ^ n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_cube : \u03c6 ^ 3 = 2 * \u03c6 + (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem goldConj_cube : \u03c8 ^ 3 = 2 * \u03c8 + (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_nonneg : (0 : \u211d) \u2264 \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_ne_one : \u03c6 \u2260 (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem one_le_gold : (1 : \u211d) \u2264 \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_le_two : \u03c6 \u2264 (2 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem goldConj_nonpos : \u03c8 \u2264 (0 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_ne_neg_one : \u03c6 \u2260 (-1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem neg_one_le_goldConj : (-1 : \u211d) \u2264 \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem gold_sq_irrational : Irrational (\u03c6 ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem goldConj_sq_irrational : Irrational (\u03c8 ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem fibRec_charPoly_eq_alt {\u03b2 : Type*} [CommRing \u03b2] : fibRec.charPoly = X ^ 2 - X - (1 : \u03b2[X]) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem fib_succ_isSol_fibRec : fibRec.IsSolution (fun n : \u2115 => Nat.fib (n + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem geom_gold_succ_isSol_fibRec : fibRec.IsSolution (fun n => \u03c6 ^ (n + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem geom_goldConj_succ_isSol_fibRec : fibRec.IsSolution (fun n => \u03c8 ^ (n + 1)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\n\ntheorem Real.coe_fib_succ_eq' : (fun n => (Nat.fib (n + 1) : \u211d)) = fun n => (\u03c6 ^ (n + 1) - \u03c8 ^ (n + 1)) / \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_gt_half : (1 : \u211d) / 2 < \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_lt_three : \u03c6 < (3 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_lt_neg_half : \u03c8 < -(1 : \u211d) / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem abs_goldConj_lt_one : |\u03c8| < (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_irrational_abs : Irrational |\u03c8| := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem fibRec_solution_shift : fibRec.IsSolution (fun n => Nat.fib (n + 2)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem Real.coe_fib_mul_sqrt_eq : \u2200 n, (Nat.fib n : \u211d) * \u221a5 = \u03c6 ^ n - \u03c8 ^ n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem fib_golden_conj_exp_alt (n : \u2115) : Nat.fib (n + 1) = \u03c6 * Nat.fib n + \u03c8 ^ n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem fib_golden_exp_alt (n : \u2115) : \u03c6 * Nat.fib (n + 1) = \u03c6 ^ (n + 1) - Nat.fib n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem \u03c8_eq_phi_minus_sqrt5 : \u03c8 = \u03c6 - \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem \u03c6_eq_\u03c8_plus_sqrt5 : \u03c6 = \u03c8 + \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_cube_eq_zero : \u03c6 ^ 3 - 2 * \u03c6 - (1 : \u211d) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_cube_eq_zero : \u03c8 ^ 3 - 2 * \u03c8 - (1 : \u211d) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_le_three : \u03c6 \u2264 (3 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem neg_two_le_goldConj : -(2 : \u211d) \u2264 \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_plus_one_irrational : Irrational (\u03c6 + 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem sqrt5_irrational : Irrational \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_pow_two_pos : (0 : \u211d) < \u03c6 ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_pow_two_pos : (0 : \u211d) < \u03c8 ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_sq_ne_two : \u03c6 ^ 2 \u2260 (2 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem \u03c6_ne_\u03c8 : \u03c6 \u2260 \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_ne_neg_two : \u03c8 \u2260 -(2 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem fibersol_geom_gold_shift : fibRec.IsSolution (fun n => \u03c6 ^ (n + 2)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem fibersol_geom_goldConj_shift : fibRec.IsSolution (fun n => \u03c8 ^ (n + 2)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem Real.coe_fib_succ_mul_sqrt_eq : (fun n => (Nat.fib (n + 1) : \u211d) * \u221a5) = fun n => \u03c6 ^ (n + 1) - \u03c8 ^ (n + 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_sub_one : \u03c6 - 1 = -\u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_le_three : \u03c6 \u2264 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_gt_neg_two : -2 < \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem inv_gold_mul_neg : \u03c6\u207b\u00b9 * (-\u03c8) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_cube_sub : \u03c6 ^ 3 - 2 * \u03c6 = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_cube_sub : \u03c8 ^ 3 - 2 * \u03c8 = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_div_two_gt_half : (1 : \u211d) / 2 < \u03c6 / 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_pow_three_pos : 0 < \u03c6 ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_pow_three_neg : \u03c8 ^ 3 < 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_mul_psi_inv : \u03c6 * \u03c8\u207b\u00b9 = -\u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_mul_phi_inv : \u03c8 * \u03c6\u207b\u00b9 = -\u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_sq_sub_two_ne_zero : \u03c6 ^ 2 - 2 \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_sq_add_two_ne_zero : \u03c8 ^ 2 + 2 \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_ne_neg_one : \u03c8 \u2260 (-1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem sqrt5_pos : (0 : \u211d) < \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_inv_mul_neg_phi_eq_one : \u03c8\u207b\u00b9 * (-\u03c6) = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_pow_succ_succ_eq_sum (n : \u2115) : \u03c6 ^ (n + 2) = \u03c6 ^ (n + 1) + \u03c6 ^ n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_pow_succ_succ_eq_sum (n : \u2115) : \u03c8 ^ (n + 2) = \u03c8 ^ (n + 1) + \u03c8 ^ n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_pow_three_pos : 0 < \u03c6 ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_pow_three_neg : \u03c8 ^ 3 < 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_plus_one_eq_neg_phi : \u03c8 + 1 = -\u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_sq_ne_two : \u03c8 ^ 2 \u2260 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_inv_mul_psi_inv_neg_one : \u03c6\u207b\u00b9 * \u03c8\u207b\u00b9 = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_inv_eq_gold_minus_one : \u03c6\u207b\u00b9 = \u03c6 - 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_minus_one_eq_inv_gold : \u03c6 - 1 = \u03c6\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_mul_inv_gold_eq_one : \u03c6 * \u03c6\u207b\u00b9 = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem inv_gold_mul_gold_eq_one : \u03c6\u207b\u00b9 * \u03c6 = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_inv_eq_one_minus_phi : \u03c8\u207b\u00b9 = 1 - \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem one_minus_phi_eq_psi_inv : 1 - \u03c6 = \u03c8\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_mul_inv_psi_eq_one : \u03c8 * \u03c8\u207b\u00b9 = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_cube_eq_gold_sq_add_gold : \u03c6 ^ 3 = \u03c6 ^ 2 + \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_cube_eq_goldConj_sq_add_goldConj : \u03c8 ^ 3 = \u03c8 ^ 2 + \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_sq_nonzero : \u03c6 ^ 2 \u2260 (0 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_sq_nonzero : \u03c8 ^ 2 \u2260 (0 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem inv_phi_mul_inv_psi_eq_neg_one : \u03c6\u207b\u00b9 * \u03c8\u207b\u00b9 = (-1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_div_neg_one_eq_gold : \u03c8 / (-1 : \u211d) = \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_inv_add_conj_eq_zero : \u03c6\u207b\u00b9 + \u03c8 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_add_gold_eq_zero : \u03c8\u207b\u00b9 + \u03c6 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_lt_neg_one : \u03c8\u207b\u00b9 < (-1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_inv_eq_one_minus_phi : \u03c8\u207b\u00b9 = 1 - \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_plus_one_eq_neg_phi : \u03c8 + (1 : \u211d) = -\u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_sq_ne_two : \u03c8 ^ 2 \u2260 (2 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_inv_eq_one_add_conj : \u03c6\u207b\u00b9 = 1 + \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_eq_one_add_gold : \u03c8\u207b\u00b9 = 1 + \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_sq_eq_one_add_gold : \u03c6 ^ 2 = 1 + \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_sq_eq_one_add_conj : \u03c8 ^ 2 = 1 + \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_lt_three : \u03c6 < 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem fib_relation_with_powers (n : \u2115) : Nat.fib (n + 2) = Nat.fib (n + 1) + Nat.fib n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_mul_conj_eq_one : \u03c8\u207b\u00b9 * \u03c8 = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_minus_one_pos : 0 < \u03c6 - 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_plus_one_neg : \u03c8 + 1 < 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_add_gold_eq_zero : \u03c8\u207b\u00b9 + \u03c6 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_char_poly_root : Polynomial.eval \u03c8 (X ^ 2 - X - 1) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_inv_add_conj_eq_zero : \u03c6\u207b\u00b9 + \u03c8 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_sub_one_eq_conj : \u03c6 - 1 = \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_div_neg_one_eq_gold : \u03c8 / (-1) = \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_gt_half : (1 : \u211d) / 2 < \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_lt_neg_half : \u03c8 < -((1 : \u211d) / 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_lt_three : \u03c6 < 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem sqrt5_irrational : Irrational \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_le_two : \u03c6 \u2264 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_eq_one_plus_conj : \u03c6 = 1 + \u03c8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_inv_eq_gold_minus_one : \u03c6\u207b\u00b9 = \u03c6 - 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_char_poly_root : Polynomial.eval \u03c6 (X ^ 2 - X - 1) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_char_poly_root : Polynomial.eval \u03c8 (X ^ 2 - X - 1) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem sqrt5_pos : 0 < \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem inv_gold_add_self : \u03c6\u207b\u00b9 + \u03c6 = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_mul_conj_inv_eq_neg_one : \u03c6 * \u03c8\u207b\u00b9 = (-1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_mul_gold_inv_eq_neg_one : \u03c8 * \u03c6\u207b\u00b9 = (-1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_le_three : \u03c6 \u2264 (3 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem sqrt5_pos : (0 : \u211d) < \u221a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_ne_neg_one : \u03c6 \u2260 (-1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_ne_one : \u03c8 \u2260 (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_mul_conj_eq_one : \u03c8\u207b\u00b9 * \u03c8 = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_gt_half : (1 : \u211d) / 2 < \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_lt_neg_half : \u03c8 < -((1 : \u211d) / 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_minus_one_pos : (0 : \u211d) < \u03c6 - (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_plus_one_neg : \u03c8 + (1 : \u211d) < (0 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_pow_three_sub_sq : \u03c6 ^ 3 - \u03c6 ^ 2 = \u03c6 + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_pow_three_sub_sq : \u03c8 ^ 3 - \u03c8 ^ 2 = \u03c8 + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_plus_conj : \u03c8\u207b\u00b9 + \u03c8 = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_minus_one_ne_zero : \u03c6 - 1 \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_plus_one_ne_zero : \u03c8 + 1 \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_add_gold_ne_two : \u03c8 + \u03c6 \u2260 (2 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_not_root_shifted_poly : Polynomial.eval \u03c6 (X ^ 2 - 3 * X + 2) \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_mul_inv_sub_one_eq_zero : \u03c6 * \u03c6\u207b\u00b9 - 1 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_inv_mul_sub_one_eq_zero : \u03c8\u207b\u00b9 * \u03c8 - 1 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem psi_plus_one_eq_neg_phi : \u03c8 + 1 = -\u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem neg_gold_mul_neg_goldConj : (-\u03c6) * (-\u03c8) = (1 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_fourth : \u03c6 ^ 4 = 3 * \u03c6 + (2 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_fourth : \u03c8 ^ 4 = 3 * \u03c8 + (2 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem one_lt_gold_sq : 1 < \u03c6 ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem phi_mul_conj_inv_eq_neg_phi_sq : \u03c6 * \u03c8\u207b\u00b9 = -\u03c6 ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_mul_phi_inv_eq_neg_conj_sq : \u03c8 * \u03c6\u207b\u00b9 = -\u03c8 ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_fourth_eq_poly : \u03c6 ^ 4 - 3 * \u03c6 - (2 : \u211d) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_fourth_eq_poly : \u03c8 ^ 4 - 3 * \u03c8 - (2 : \u211d) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_fifth : \u03c6 ^ 5 = 5 * \u03c6 + (3 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem goldConj_fifth : \u03c8 ^ 5 = 5 * \u03c8 + (3 : \u211d) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem one_lt_gold_cube : 1 < \u03c6 ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem conj_cube_lt_neg_one : \u03c8 ^ 3 < -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_sq_gt_gold : \u03c6 ^ 2 > \u03c6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type*} [CommSemiring \u03b1]\n\nopen Real Polynomial goldenRatio\ntheorem gold_div_conj_eq_neg_phi_sq : \u03c6 / \u03c8 = -\u03c6 ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\n\ntheorem isSimpleGroup_of_injective {H : Type*} [Group H] [IsSimpleGroup H] [Nontrivial G] (f : G \u2192* H) (hf : Function.Injective f) : IsSimpleGroup G := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_of_ne_bot {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (Hn : H.Normal) (h : H \u2260 \u22a5) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_bot_of_ne_top {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (Hn : H.Normal) (h : H \u2260 \u22a4) : H = \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleAddGroup_of_injective {A H : Type*} [AddGroup A] [AddGroup H] [IsSimpleAddGroup H] [Nontrivial A] (f : A \u2192+ H) (hf : Function.Injective f) : IsSimpleAddGroup A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_bot_of_ne_top {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (Hn : H.Normal) (h : H \u2260 \u22a4) : H = \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_top_of_ne_bot {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (Hn : H.Normal) (h : H \u2260 \u22a5) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleGroup_of_trivial_kernel {G H : Type*} [Group G] [Group H] [IsSimpleGroup H] [Nontrivial G] (f : G \u2192* H) (hker : f.ker = \u22a5) : IsSimpleGroup G := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleAddGroup_of_trivial_kernel {A H : Type*} [AddGroup A] [AddGroup H] [IsSimpleAddGroup H] [Nontrivial A] (f : A \u2192+ H) (hker : f.ker = \u22a5) : IsSimpleAddGroup A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleGroup_of_range_eq_top {G H : Type*} [Group G] [Group H] [IsSimpleGroup G] [Nontrivial H] (f : G \u2192* H) (hf : f.range = \u22a4) : IsSimpleGroup H := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleAddGroup_of_range_eq_top {A H : Type*} [AddGroup A] [AddGroup H] [IsSimpleAddGroup A] [Nontrivial H] (f : A \u2192+ H) (hf : f.range = \u22a4) : IsSimpleAddGroup H := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleGroup_of_embedding {G H : Type*} [Group G] [Group H]\n    [IsSimpleGroup H] [Nontrivial G] (e : Function.Embedding G H) : IsSimpleGroup G := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleAddGroup_of_embedding {A H : Type*} [AddGroup A] [AddGroup H]\n    [IsSimpleAddGroup H] [Nontrivial A] (e : Function.Embedding A H) :\n    IsSimpleAddGroup A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_of_exists_nonidentity {G : Type*} [Group G]\n    [IsSimpleGroup G] {H : Subgroup G} (Hn : H.Normal)\n    (h : \u2203 g : G, g \u2208 H \u2227 g \u2260 1) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_of_nontrivial {G : Type*} [Group G] [IsSimpleGroup G]\n    {H : Subgroup G} (Hn : H.Normal) (h : Nontrivial H) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_top_of_exists_nonzero {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (Hn : H.Normal) (h : \u2203 a : A, a \u2208 H \u2227 a \u2260 0) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleGroup_of_bijective {G H : Type*} [Group G] [Group H] [IsSimpleGroup H] [Nontrivial G] (f : G \u2192* H) (hf : Function.Bijective f) : IsSimpleGroup G := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleAddGroup_of_bijective {A H : Type*} [AddGroup A] [AddGroup H] [IsSimpleAddGroup H] [Nontrivial A] (f : A \u2192+ H) (hf : Function.Bijective f) : IsSimpleAddGroup A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.ne_bot_iff_eq_top {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (Hn : H.Normal) : (H \u2260 \u22a5) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.ne_top_iff_eq_bot {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (Hn : H.Normal) : (H \u2260 \u22a4) \u2194 H = \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_top_of_nontrivial {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (Hn : H.Normal) (h : Nontrivial H) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_iff_nontrivial {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (Hn : H.Normal) : Nontrivial H \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_bot_iff_trivial {A : Type*} [AddGroup A]\n    [IsSimpleAddGroup A] {H : AddSubgroup A} (hN : H.Normal) :\n    (Subsingleton H) \u2194 H = \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_iff_nonempty {G : Type*} [Group G] [IsSimpleGroup G]\n    {H : Subgroup G} (hN : H.Normal) : (\u2203 g : G, g \u2208 H \u2227 g \u2260 1) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_top_iff_nonempty {A : Type*} [AddGroup A] [IsSimpleAddGroup A]\n    {H : AddSubgroup A} (hN : H.Normal) : (\u2203 a : A, a \u2208 H \u2227 a \u2260 0) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_of_nonempty' {G : Type*} [Group G] [IsSimpleGroup G]\n    {H : Subgroup G} (hN : H.Normal) (h : \u2203 g : G, g \u2208 H) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_iff_nonempty' {G : Type*} [Group G] [IsSimpleGroup G]\n    {H : Subgroup G} (hN : H.Normal) : (\u2203 g : G, g \u2208 H) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_top_iff_nonempty' {A : Type*} [AddGroup A] [IsSimpleAddGroup A]\n    {H : AddSubgroup A} (hN : H.Normal) : (\u2203 a : A, a \u2208 H) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.ne_top_iff_eq_bot {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (hN : H.Normal) : (H \u2260 \u22a4) \u2194 H = \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.ne_bot_iff_eq_top {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (hN : H.Normal) : (H \u2260 \u22a5) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.ne_bot_iff_eq_top {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (hN : H.Normal) : (H \u2260 \u22a5) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_iff_nonempty' {G : Type*} [Group G] [IsSimpleGroup G]\n    {H : Subgroup G} (hN : H.Normal) : (\u2203 g : G, g \u2208 H) \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_top_iff_nontrivial' {A : Type*} [AddGroup A] [IsSimpleAddGroup A]\n    {H : AddSubgroup A} (hN : H.Normal) : Nontrivial H \u2194 H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_bot_iff_trivial {G : Type*} [Group G] [IsSimpleGroup G]\n    {H : Subgroup G} (hN : H.Normal) : (Subsingleton H) \u2194 H = \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_top_or_ne_bot {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (hN : H.Normal) : H = \u22a4 \u2228 H \u2260 \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_bot_or_ne_top {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (hN : H.Normal) : H = \u22a5 \u2228 H \u2260 \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem Subgroup.Normal.eq_bot_of_proper {G : Type*} [Group G] [IsSimpleGroup G] {H : Subgroup G} (hN : H.Normal) (hproper : H < \u22a4) : H = \u22a5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem AddSubgroup.Normal.eq_top_of_proper {A : Type*} [AddGroup A] [IsSimpleAddGroup A] {H : AddSubgroup A} (hN : H.Normal) (hproper : \u22a5 < H) : H = \u22a4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleGroup_of_injective_nonempty {G H : Type*} [Group G] [Group H] [IsSimpleGroup H] (f : G \u2192* H) (hf : Function.Injective f) (hG : Nonempty G) : IsSimpleGroup G := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {G : Type*} [Group G]\nvariable {A : Type*} [AddGroup A]\nvariable (G) (A)\nvariable {G} {A}\n\nopen Subgroup\ntheorem isSimpleAddGroup_of_injective_nonempty {A H : Type*} [AddGroup A] [AddGroup H] [IsSimpleAddGroup H] (f : A \u2192+ H) (hf : Function.Injective f) (hA : Nonempty A) : IsSimpleAddGroup A := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\n\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_sub_half_dist_sq\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n    [NormedAddTorsor V P] (a b c : P) :\n    dist b a ^ 2 + dist c a ^ 2 =\n      2 * (dist (midpoint \u211d b c) a ^ 2 - (dist b c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_sub_half_dist_sq_alt\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist a b ^ 2 + dist a c ^ 2 = 2 * (dist (midpoint \u211d b c) a ^ 2 - (dist b c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_sub_half_dist_sq_symm\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n    [NormedAddTorsor V P] (a b c : P) :\n    dist b a ^ 2 + dist c a ^ 2 = 2 * (dist (midpoint \u211d b c) a ^ 2 + (dist b c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_sub_half_dist_sq_alt2\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist c a ^ 2 + dist c b ^ 2 =\n      2 * (dist c (midpoint \u211d a b) ^ 2 - (dist a b / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq_sym\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist b a ^ 2 + dist c a ^ 2 = 2 * (dist a (midpoint \u211d b c) ^ 2 + (dist b c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq_alt2\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist a b ^ 2 + dist c b ^ 2 = 2 * (dist b (midpoint \u211d a c) ^ 2 + (dist a c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_sub_quarter_dist_sq\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist a b ^ 2 + dist a c ^ 2 = 2 * (dist a (midpoint \u211d b c) ^ 2 - (dist b c / 4) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_sum_eq_four_mul_midpoint_dist_sq_plus_half_dist_sq\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist b a ^ 2 + dist c a ^ 2 = 4 * (dist a (midpoint \u211d b c) ^ 2 + (dist b c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_sum_eq_two_mul_midpoint_dist_sq\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist b a ^ 2 + dist c a ^ 2 = 2 * dist a (midpoint \u211d b c) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_sum_eq_two_mul_midpoint_dist_sq_symm\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist a b ^ 2 + dist a c ^ 2 = 2 * dist (midpoint \u211d b c) a ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_quarter_dist_sq\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist c a ^ 2 + dist c b ^ 2 = 2 * (dist c (midpoint \u211d a b) ^ 2 + (dist a b / 4) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_sub_half_dist_sq_variant {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n  [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist b a ^ 2 + dist c a ^ 2 = 2 * (dist a (midpoint \u211d b c) ^ 2 - (dist b c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem dist_sq_add_dist_sq_eq_two_mul_midpoint_dist_sq_add_half_dist_sq_symm\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist a b ^ 2 + dist a c ^ 2 =\n      2 * (dist (midpoint \u211d b c) a ^ 2 + (dist b c / 2) ^ 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem midsegment_length_relation\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist (midpoint \u211d a b) (midpoint \u211d a c) = dist b c / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\nvariable {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n\nopen Real scoped InnerProductGeometry RealInnerProductSpace EuclideanGeometry CharZero\ntheorem distance_sum_of_triangle_vertices\n    {V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n    [MetricSpace P] [NormedAddTorsor V P] (a b c : P) :\n    dist a b + dist b c + dist c a \u2265 2 * dist a (midpoint \u211d b c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem direction_smul_neg_one\n    {k V : Type*} [Field k] [AddCommGroup V] [Module k V]\n    (s : AffineSubspace k V) :\n    (-1 : k) \u2022 s.direction = s.direction := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_zero_vector\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    (v : V) (s : AffineSubspace k P) :\n    v +\u1d65 s = s \u2194 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem mem_pointwise_vadd_iff_sub_v\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    {v : V} {s : AffineSubspace k P} {p : P} :\n    p \u2208 v +\u1d65 s \u2194 (-v) +\u1d65 p \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem map_pointwise_vadd_neg\n    {k V\u2081 V\u2082 P\u2081 P\u2082 : Type*} [Ring k]\n    [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\n    [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\n    (f : P\u2081 \u2192\u1d43[k] P\u2082) (v : V\u2081) (s : AffineSubspace k P\u2081) :\n    ((-v) +\u1d65 s).map f = -(f.linear v) +\u1d65 s.map f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem smul_mem_smul_iff_inv\n    {k G V : Type*} [Ring k] [AddCommGroup V] [Module k V]\n    [Group G] [DistribMulAction G V] [SMulCommClass G k V]\n    {a : G} {s : AffineSubspace k V} {p : V} :\n    p \u2208 a\u207b\u00b9 \u2022 s \u2194 a \u2022 p \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_neg_vector\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    (v : V) (s : AffineSubspace k P) :\n    (-v) +\u1d65 s = s \u2194 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_vector_zero\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    (v : V) (s : AffineSubspace k P) :\n    s = v +\u1d65 s \u2194 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem vadd_mem_pointwise_vadd_iff_right\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    {v : V} {s : AffineSubspace k P} {p : P} :\n    p \u2208 v +\u1d65 s \u2194 p \u2208 (-v) +\u1d65 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem mem_smul_set_iff_inv_smul\n    {k G V : Type*} [Ring k] [AddCommGroup V] [Module k V]\n    [Group G] [DistribMulAction G V] [SMulCommClass G k V]\n    {a : G} {s : AffineSubspace k V} {p : V} :\n    p \u2208 a \u2022 s \u2194 a\u207b\u00b9 \u2022 p \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_vector_neg_zero\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    (v : V) (s : AffineSubspace k P) :\n    (-v) +\u1d65 s = v +\u1d65 s \u2194 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_opposite_vectors_zero\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    (v : V) (s : AffineSubspace k P) :\n    v +\u1d65 s = (-v) +\u1d65 s \u2194 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem direction_smul_neg_two\n    {k V : Type*} [Field k] [AddCommGroup V] [Module k V]\n    (s : AffineSubspace k V) :\n    (-1 : k) \u2022 ((-1 : k) \u2022 s.direction) = s.direction := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem vadd_mem_vadd_iff_shift\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    {v : V} {s : AffineSubspace k P} {p : P} :\n    v +\u1d65 p \u2208 s \u2194 p \u2208 (-v) +\u1d65 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem map_pointwise_vadd_zero_affineSpan\n    {k V\u2081 V\u2082 P\u2081 P\u2082 : Type*} [Ring k]\n    [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\n    [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\n    (f : P\u2081 \u2192\u1d43[k] P\u2082) (t : Set P\u2081) :\n    ((0 : V\u2081) +\u1d65 affineSpan k t).map f = (0 : V\u2082) +\u1d65 affineSpan k (f '' t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_vector_double_neg_zero\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    (v : V) (s : AffineSubspace k P) :\n    v +\u1d65 s = (-v) +\u1d65 s \u2194 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem mem_pointwise_vadd_self_iff_zero\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    {v : V} {s : AffineSubspace k P} {p : P} :\n    p \u2208 v +\u1d65 s \u2194 (v = 0 \u2227 p \u2208 s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem vadd_mem_pointwise_vadd_iff_neg\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    {v : V} {s : AffineSubspace k P} {p : P} :\n    p \u2208 (-v) +\u1d65 s \u2194 v +\u1d65 p \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem direction_smul_unit\n    {k V : Type*} [Field k] [AddCommGroup V] [Module k V]\n    {a : k} (ha : IsUnit a) (s : AffineSubspace k V) :\n    a \u2022 s.direction = s.direction := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem direction_smul_neg_unit\n    {k V : Type*} [Field k] [AddCommGroup V] [Module k V]\n    {a : k} (ha : a \u2260 0) (s : AffineSubspace k V) :\n    (-a) \u2022 s.direction = s.direction := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem map_affineSpan_zero\n    {k V\u2081 V\u2082 P\u2081 P\u2082 : Type*} [Ring k]\n    [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\n    [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\n    (f : P\u2081 \u2192\u1d43[k] P\u2082) (t : Set P\u2081) :\n    ((0 : V\u2081) +\u1d65 affineSpan k t).map f = affineSpan k (f '' t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_neg_vector_rev\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    (s : AffineSubspace k P) (v : V) :\n    s = (-v) +\u1d65 s \u2194 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem pointwise_vadd_eq_self_iff_vector_nonneg {k V P : Type*}\n  [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n  (v : V) (s : AffineSubspace k P) :\n  v +\u1d65 s = s \u2194 -v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem direction_smul_neg_unit_alt {k V : Type*}\n  [Field k] [AddCommGroup V] [Module k V]\n  {a : k} (ha : IsUnit a) (s : AffineSubspace k V) :\n  (-a) \u2022 s.direction = s.direction := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem mem_pointwise_vadd_self_iff_zero_alt {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P] {v : V} {s : AffineSubspace k P} {p : P} : p \u2208 v +\u1d65 s \u2194 (v = 0 \u2227 p \u2208 s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem mem_pointwise_vadd_iff_vadd_mem {k V P : Type*} [Ring k]\n  [AddCommGroup V] [Module k V] [AffineSpace V P]\n  {v : V} {s : AffineSubspace k P} {p : P} :\n  p \u2208 v +\u1d65 s \u2194 v +\u1d65 p \u2208 v +\u1d65 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem mem_smul_set_iff_left {k G V : Type*} [Ring k] [AddCommGroup V]\n  [Module k V] [Group G] [DistribMulAction G V] [SMulCommClass G k V]\n  {a : G} {s : AffineSubspace k V} {p : V} :\n  p \u2208 a \u2022 s \u2194 a\u207b\u00b9 \u2022 p \u2208 a\u207b\u00b9 \u2022 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem direction_smul_inv_eq {k V : Type*} [Field k]\n    [AddCommGroup V] [Module k V] {a : k} (ha : a \u2260 0)\n    (s : AffineSubspace k V) :\n    (a\u207b\u00b9 : k) \u2022 s.direction = s.direction := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem direction_smul_unit {k V : Type*} [Field k]\n    [AddCommGroup V] [Module k V] {a : k} (ha : IsUnit a)\n    (s : AffineSubspace k V) :\n    a \u2022 s.direction = s.direction := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem vadd_mem_pointwise_vadd_self\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    {v : V} {s : AffineSubspace k P} :\n    v +\u1d65 (Classical.arbitrary P) \u2208 v +\u1d65 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {M k V P V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\nvariable [Ring k]\nvariable [AddCommGroup V] [Module k V] [AffineSpace V P]\nvariable [AddCommGroup V\u2081] [Module k V\u2081] [AddTorsor V\u2081 P\u2081]\nvariable [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082]\nvariable [Monoid M] [DistribMulAction M V] [SMulCommClass M k V] {a : M} {s : AffineSubspace k V}\nvariable [Field k] [AddCommGroup V] [Module k V] {a : k}\n\nopen Affine Pointwise Set\ntheorem mem_pointwise_vadd_self_iff_and\n    {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V] [AffineSpace V P]\n    {v : V} {s : AffineSubspace k P} {p : P} :\n    p \u2208 v +\u1d65 s \u2194 p \u2208 s \u2227 v = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\n\ntheorem skewAdjointMatricesSubmodule_alt (J : Matrix n n R\u2082) :\n    skewAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule (-J\u1d40) J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_symm (M : Matrix n n R\u2081) (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b P) (toLin c b P) = Matrix.toBilin c (P\u1d40 * M * P) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem selfAdjointMatricesSubmodule'_transpose :\n    selfAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule J\u1d40 J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem skewAdjointMatricesSubmodule_alt' (J : Matrix n n R\u2082) :\n    skewAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule (-J\u1d40) J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_left (M : Matrix n n R\u2081) (P : Matrix n n R\u2081)\n    (b : Basis n R\u2081 M\u2081) :\n    (Matrix.toBilin b M).compLeft (Matrix.toLin b b P\u1d40) =\n      Matrix.toBilin b (P * M) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_right (M : Matrix n n R\u2081) (Q : Matrix n n R\u2081)\n    (b : Basis n R\u2081 M\u2081) :\n    (Matrix.toBilin b M).compRight (Matrix.toLin b b Q) =\n      Matrix.toBilin b (M * Q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_basis (b c : Basis n R\u2081 M\u2081) (M : Matrix n n R\u2081) (P : Matrix n n R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b P) (toLin c b P) = Matrix.toBilin c (P\u1d40 * M * P) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem skewAdjointMatricesSubmodule_transpose (J : Matrix n n R\u2082) :\n    skewAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule (-J\u1d40) J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem selfAdjointMatricesSubmodule_transpose :\n    selfAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule J\u1d40 J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_left_basis (M : Matrix n n R\u2081) (P : Matrix n n R\u2081) (b : Basis n R\u2081 M\u2081) :\n    (Matrix.toBilin b M).compLeft (Matrix.toLin b b P\u1d40) = Matrix.toBilin b (P * M) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_right_basis (M : Matrix n n R\u2081) (Q : Matrix n n R\u2081) (b : Basis n R\u2081 M\u2081) :\n    (Matrix.toBilin b M).compRight (Matrix.toLin b b Q) = Matrix.toBilin b (M * Q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_transpose_basis (M : Matrix n n R\u2081) (b c : Basis n R\u2081 M\u2081)\n    (P : Matrix n n R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b P\u1d40) (toLin c b P\u1d40) =\n      Matrix.toBilin c (P * M * P\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem skewAdjointMatricesSubmodule_alt_transpose (J : Matrix n n R\u2082) :\n    skewAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule (-J)\u1d40 J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_left_scaled (M : Matrix n n R\u2081) (P : Matrix n n R\u2081)\n    (b : Basis n R\u2081 M\u2081) (r : R\u2081) :\n    (Matrix.toBilin b M).compLeft (Matrix.toLin b b (r \u2022 P\u1d40)) =\n      Matrix.toBilin b (r \u2022 P * M) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_right_scaled (M : Matrix n n R\u2081) (Q : Matrix n n R\u2081)\n    (b : Basis n R\u2081 M\u2081) (s : R\u2081) :\n    (Matrix.toBilin b M).compRight (Matrix.toLin b b (s \u2022 Q)) =\n      Matrix.toBilin b (M * s \u2022 Q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_symm_basis (M : Matrix n n R\u2081) (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b P) (toLin c b P) = Matrix.toBilin c (P\u1d40 * M * P) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_left_scaled [Fintype n]\n    (M : Matrix n n R\u2081) (P : Matrix n n R\u2081) (b : Basis n R\u2081 M\u2081) (r : R\u2081) :\n    (Matrix.toBilin b M).compLeft (Matrix.toLin b b (r \u2022 P\u1d40)) =\n      Matrix.toBilin b (r \u2022 P * M) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_right_scaled [Fintype n]\n    (M : Matrix n n R\u2081) (Q : Matrix n n R\u2081) (b : Basis n R\u2081 M\u2081) (s : R\u2081) :\n    (Matrix.toBilin b M).compRight (Matrix.toLin b b (s \u2022 Q)) =\n      Matrix.toBilin b (M * s \u2022 Q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_symm_scaled [Fintype n]\n    (M : Matrix n n R\u2081) (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) (k : R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b (k \u2022 P)) (toLin c b (k \u2022 P)) =\n      Matrix.toBilin c ((k \u2022 P)\u1d40 * M * (k \u2022 P)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_basis_scaled [Fintype n]\n    (b c : Basis n R\u2081 M\u2081) (M : Matrix n n R\u2081) (P : Matrix n n R\u2081) (r : R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b (r \u2022 P)) (toLin c b (r \u2022 P)) =\n      Matrix.toBilin c ((r \u2022 P)\u1d40 * M * (r \u2022 P)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem skewAdjointMatricesSubmodule_neg_transpose [Fintype n] [DecidableEq n]\n    (J : Matrix n n R\u2082) :\n    skewAdjointMatricesSubmodule (-J) = pairSelfAdjointMatricesSubmodule (J\u1d40) (-J\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem selfAdjointMatricesSubmodule_eq_pair [Fintype n] [DecidableEq n]\n    (J : Matrix n n R\u2082) :\n    selfAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule J (-J) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_transpose_scaled [Fintype n]\n    (M : Matrix n n R\u2081) (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) (s : R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b (s \u2022 P\u1d40)) (toLin c b (s \u2022 P\u1d40)) =\n      Matrix.toBilin c ((s \u2022 P) * M * (s \u2022 P)\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_symm_swap (M : Matrix n n R\u2081)\n    (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b P\u1d40) (toLin c b P\u1d40) =\n      Matrix.toBilin c (P * M * P\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_left_simple (M P : Matrix n n R\u2081) (b : Basis n R\u2081 M\u2081) :\n    (Matrix.toBilin b M).compLeft (Matrix.toLin b b P) = Matrix.toBilin b (P\u1d40 * M) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_right_simple (M Q : Matrix n n R\u2081) (b : Basis n R\u2081 M\u2081) :\n    (Matrix.toBilin b M).compRight (Matrix.toLin b b Q) = Matrix.toBilin b (M * Q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_double (M : Matrix n n R\u2081) (P Q : Matrix n n R\u2081)\n    (b : Basis n R\u2081 M\u2081) :\n    (Matrix.toBilin b M).comp (toLin b b P) (toLin b b Q) =\n      Matrix.toBilin b (P\u1d40 * M * Q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_left_scaled_simple (M P : Matrix n n R\u2081)\n    (b : Basis n R\u2081 M\u2081) (k : R\u2081) :\n    (Matrix.toBilin b M).compLeft (Matrix.toLin b b (k \u2022 P\u1d40)) =\n      Matrix.toBilin b (k \u2022 P * M) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_right_scaled_simple (M Q : Matrix n n R\u2081)\n    (b : Basis n R\u2081 M\u2081) (k : R\u2081) :\n    (Matrix.toBilin b M).compRight (Matrix.toLin b b (k \u2022 Q)) =\n      Matrix.toBilin b (M * k \u2022 Q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_symm_scaled_simple (M : Matrix n n R\u2081)\n    (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) (k : R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b (k \u2022 P)) (toLin c b (k \u2022 P)) =\n      Matrix.toBilin c ((k \u2022 P)\u1d40 * M * (k \u2022 P)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_transpose_simple (M : Matrix n n R\u2081)\n    (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b P\u1d40) (toLin c b P\u1d40) =\n      Matrix.toBilin c (P * M * P\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem selfAdjointMatricesSubmodule_symm [DecidableEq n] :\n    selfAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule J J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem skewAdjointMatricesSubmodule_symm [DecidableEq n] :\n    skewAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule (-J)\u1d40 J\u1d40 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem pairSelfAdjointMatricesSubmodule_neg (J K : Matrix n n R\u2082) :\n    pairSelfAdjointMatricesSubmodule (-J) K = pairSelfAdjointMatricesSubmodule J (-K) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem skewAdjointMatricesSubmodule_equiv (J : Matrix n n R\u2082) :\n    skewAdjointMatricesSubmodule J = skewAdjointMatricesSubmodule (-J\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem Matrix.toBilin_comp_symm_basis_alt (M : Matrix n n R\u2081)\n    (b c : Basis n R\u2081 M\u2081) (P : Matrix n n R\u2081) :\n    (Matrix.toBilin b M).comp (toLin c b P) (toLin c b P\u1d40) =\n      Matrix.toBilin c (P\u1d40 * M * P\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem selfAdjointMatricesSubmodule_eq_pair_neg {R : Type*} {n : Type*}\n    [CommRing R] [Fintype n] [DecidableEq n] (J : Matrix n n R) :\n    selfAdjointMatricesSubmodule J = pairSelfAdjointMatricesSubmodule J (-J) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem pairSelfAdjointMatricesSubmodule_neg_symm {R : Type*} {n : Type*}\n    [CommRing R] [Fintype n] [DecidableEq n] (J K : Matrix n n R) :\n    pairSelfAdjointMatricesSubmodule (-J) (-K) = pairSelfAdjointMatricesSubmodule K J := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {R\u2081 : Type*} {M\u2081 : Type*} [CommSemiring R\u2081] [AddCommMonoid M\u2081] [Module R\u2081 M\u2081]\nvariable {R\u2082 : Type*} {M\u2082 : Type*} [CommRing R\u2082] [AddCommGroup M\u2082] [Module R\u2082 M\u2082]\nvariable {n o : Type*}\nvariable [Fintype n] [Fintype o]\nvariable [DecidableEq n] [DecidableEq o]\nvariable [DecidableEq n] (b : Basis n R\u2081 M\u2081)\nvariable {M\u2082' : Type*} [AddCommMonoid M\u2082'] [Module R\u2081 M\u2082']\nvariable (c : Basis o R\u2081 M\u2082')\nvariable [DecidableEq o]\nvariable {n : Type*} [Fintype n]\nvariable (b : Basis n R\u2082 M\u2082)\nvariable (J J\u2083 A A' : Matrix n n R\u2082)\nvariable [DecidableEq n]\nvariable {A : Type*} [CommRing A] [IsDomain A] [Module A M\u2082] (B\u2083 : BilinForm A M\u2082)\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\nopen Finset Matrix LinearMap (BilinForm)\ntheorem skewAdjointMatricesSubmodule_equiv_transpose {R : Type*} {n : Type*}\n    [CommRing R] [Fintype n] [DecidableEq n] (J : Matrix n n R) :\n    skewAdjointMatricesSubmodule J = skewAdjointMatricesSubmodule (-J\u1d40) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\n\ntheorem IsSymm.ext_iff' {A : Matrix n n \u03b1} : A.IsSymm \u2194 \u2200 i j, A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\n\ntheorem IsSymm.ext' {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\n\ntheorem IsSymm.apply' {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_swap_eq {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.mul_self [CommSemiring \u03b1] [Fintype n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A * A).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise' {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.add_four {A B C D : Matrix n n \u03b1} [Add \u03b1] (hA : A.IsSymm) (hB : B.IsSymm) (hC : C.IsSymm) (hD : D.IsSymm) : (A + B + C + D).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.equal_entries {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_reverse {A : Matrix n n \u03b1} :\n    (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.swap_entry_eq {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_swap {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_eq {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_eq_entries {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_eq_alt {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_eq_entries_alt {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_eq_alt2 {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_alt {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_swap_eq_alt {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_alt {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_eq_entries_alt2 {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_eq_alt3 {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_alt2 {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_swap_eq_alt2 {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_alt2 {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_rev {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entries_equal {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_rev2 {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_swap {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.ext_left {A : Matrix n n \u03b1} :\n    (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_comm {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_comm {A : Matrix n n \u03b1} :\n    (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_symm_eq {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_comm {A : Matrix n n \u03b1} :\n    (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_left {A : Matrix n n \u03b1} :\n    (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.equal_entries_rev {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_comm_rev {A : Matrix n n \u03b1} :\n    (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_swap_symm {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_alt_left {A : Matrix n n \u03b1} :\n    (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_eq_left {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_three [CommSemiring \u03b1] [Fintype n] [DecidableEq n]\n    {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 3).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_rev' {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_eq_comm {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_two [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 2).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_four [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 4).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_rev {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_symm {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.equal_entries_symm {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem isSymm_one_add_zero [DecidableEq n] [Zero \u03b1] [One \u03b1] [Add \u03b1] : ((1 : Matrix n n \u03b1) + 0).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_symm_comm {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise'' {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.ext_alt {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_alt {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.add_four_alt {A B C D : Matrix n n \u03b1} [Add \u03b1] (hA : A.IsSymm) (hB : B.IsSymm) (hC : C.IsSymm) (hD : D.IsSymm) : (A + (B + C) + D).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.swap_entry_eq_alt {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.ext_left_alt {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_comm_alt {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_eq_alt {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_comm_alt {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_eq_entries_alt {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.ext_flip {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_flip {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_five [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 5).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_six [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 6).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_commute {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.ext_rev {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_symm {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.add_four_alt {A B C D : Matrix n n \u03b1} [Add \u03b1] (h1 : A.IsSymm) (h2 : B.IsSymm) (h3 : C.IsSymm) (h4 : D.IsSymm) : (A + (B + C) + D).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_five [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 5).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.sub_self {A : Matrix n n \u03b1} [Sub \u03b1] : (A - A).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_six [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 6).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_flip {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.ext_flip {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.neg_neg {A : Matrix n n \u03b1} [Neg \u03b1] (h : A.IsSymm) : (-(-A)).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.ext_comm {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_comm' {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entry_eq_swap {A : Matrix n n \u03b1} :\n    (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entry_eq_swap {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_six' [CommSemiring \u03b1] [Fintype n] [DecidableEq n]\n    {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 6).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_symm' {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) :\n    A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.symm_apply_rev {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.add_five {A B C D E : Matrix n n \u03b1} [Add \u03b1] (hA : A.IsSymm) (hB : B.IsSymm) (hC : C.IsSymm) (hD : D.IsSymm) (hE : E.IsSymm) : (A + B + C + D + E).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_seven [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 7).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_symm_reverse {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entries_comm {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.entries_match {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.sub_four {A B C D : Matrix n n \u03b1} [Sub \u03b1] (hA : A.IsSymm) (hB : B.IsSymm) (hC : C.IsSymm) (hD : D.IsSymm) : (A - B - C - D).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_flip {A : Matrix n n \u03b1} : (\u2200 i j, A i j = A j i) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.add_comm_four {A B C D : Matrix n n \u03b1} [Add \u03b1] (hA : A.IsSymm) (hB : B.IsSymm) (hC : C.IsSymm) (hD : D.IsSymm) : (A + (B + (C + D))).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_flip_rev {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_eight [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 8).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_left {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.add_five {A B C D E : Matrix n n \u03b1} [Add \u03b1] (hA : A.IsSymm) (hB : B.IsSymm) (hC : C.IsSymm) (hD : D.IsSymm) (hE : E.IsSymm) : (A + B + C + D + E).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.equal_entries_left {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.swap_entry_left {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_commutative {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_six_left [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 6).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.add_seven {A B C D E F G H : Matrix n n \u03b1} [Add \u03b1] (hA : A.IsSymm) (hB : B.IsSymm) (hC : C.IsSymm) (hD : D.IsSymm) (hE : E.IsSymm) (hF : F.IsSymm) (hG : G.IsSymm) (hH : H.IsSymm) : (A + B + C + D + E + F + G + H).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.swap_apply {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A i j = A j i := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.pow_six_left [CommSemiring \u03b1] [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsSymm) : (A ^ 6).IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.of_entrywise_flip {A : Matrix n n \u03b1} : (\u2200 i j, A j i = A i j) \u2192 A.IsSymm := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 n m R : Type*}\n\n\ntheorem IsSymm.apply_flip_symm {A : Matrix n n \u03b1} (h : A.IsSymm) (i j : n) : A j i = A i j := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem ExistsUnique.intro_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (w : \u03b1)\n    (h\u2081 : p w) (h\u2082 : \u2200 y, p y \u2192 w = y) : \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem ExistsUnique.elim_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h\u2082 : \u2203! x, p x) (h\u2081 : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 x = y) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem existsUnique_of_exists_of_unique_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (hex : \u2203 x, p x) (huniq : \u2200 y\u2081 y\u2082, p y\u2081 \u2192 p y\u2082 \u2192 y\u2082 = y\u2081) : \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem ExistsUnique.eq_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem existsUnique_eq_or {\u03b1 : Sort*} {a' : \u03b1} : \u2203! a, a = a' \u2228 a' = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem ExistsUnique.elim\u2082_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop} {b : Prop}\n    (h\u2082 : \u2203! x, \u2203! hx : p x, q x hx)\n    (h\u2081 : \u2200 x (hx : p x), q x hx \u2192 (\u2200 y (hy : p y), q y hy \u2192 y = x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem ExistsUnique.exists\u2082_and {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*} {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) : \u2203 x hx, q x hx \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\n\ntheorem ExistsUnique.eq\u2082_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hpy\u2081 : p y\u2081) (hqy\u2081 : q y\u2081 hpy\u2081) (hpy\u2082 : p y\u2082) (hqy\u2082 : q y\u2082 hpy\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (hex : \u2203! x, p x) (h : (\u2203 x, p x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_and_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 ((\u2203 x, p x) \u2227 (\u2200 y\u2081 y\u2082, p y\u2081 \u2192 p y\u2082 \u2192 y\u2081 = y\u2082)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_false_of_two {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (x y : \u03b1) (hx : p x) (hy : p y) (hneq : x \u2260 y) : \u00ac\u2203! z, p z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique\u2082_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hpy\u2081 : p y\u2081) (hpy\u2082 : p y\u2082) : y\u2081 = y\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_right {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h\u2081 : \u2203! x, p x) (h\u2082 : \u2200 x, p x \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_symm' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_unique [Subsingleton \u03b1] {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim\u2083 {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*} [\u2200 x, Subsingleton (p x)]\n    {q : \u2200 x, p x \u2192 Prop} {b : Prop} (hex : \u2203! x, \u2203! hx : p x, q x hx)\n    (H : \u2200 x hx, q x hx \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_triple {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hy\u2081 : p y\u2081) (hq\u2081 : q y\u2081 hy\u2081) (hy\u2082 : p y\u2082) (hq\u2082 : q y\u2082 hy\u2082) : y\u2081 = y\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_and_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x \u2227 True) \u2194 \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_comm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (hex : \u2203! x, p x) (H : \u2200 x, p x \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2081 = y\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_if_and_only_if {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2192 ((\u2203 x, p x) \u2227 (\u2200 y\u2081 y\u2082, p y\u2081 \u2192 p y\u2082 \u2192 y\u2081 = y\u2082)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_or_comm {\u03b1 : Sort*} (a : \u03b1) : \u2203! x, a = x \u2228 x = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.intro_and_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (w : \u03b1)\n    (h\u2081 : p w \u2227 True) (h\u2082 : \u2200 y, p y \u2192 y = w) : \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_of_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (ht : True) (h\u2081 : \u2203! x, p x) (h\u2082 : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 y = x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2192 \u2203 x, p x \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_true {\u03b1 : Sort*} : (\u2203! _ : \u03b1, True) \u2194 Subsingleton \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim\u2082_and_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop} {b : Prop}\n    (h\u2082 : \u2203! x, \u2203! hx : p x, q x hx) (ht : True)\n    (h\u2081 : \u2200 x hx, q x hx \u2192 (\u2200 y hy, q y hy \u2192 y = x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique\u2082_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hy\u2081 : p y\u2081) (hq\u2081 : q y\u2081 hy\u2081) (hy\u2082 : p y\u2082) (hq\u2082 : q y\u2082 hy\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_or_and {\u03b1 : Sort*} {a' : \u03b1} : \u2203! a, a = a' \u2227 a' = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq\u2082_symm_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hy\u2081 : p y\u2081) (hq\u2081 : q y\u2081 hy\u2081) (hy\u2082 : p y\u2082) (hq\u2082 : q y\u2082 hy\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_and_unique_alt {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 ((\u2203 x, p x \u2227 True) \u2227 (\u2200 y\u2081 y\u2082, p y\u2081 \u2192 p y\u2082 \u2192 y\u2081 = y\u2082)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_forall_alt {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2200 x, p x) \u2192 (\u2203! x, p x) \u2192 Subsingleton \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_or_comm_alt {\u03b1 : Sort*} (a : \u03b1) : \u2203! x, a = x \u2227 x = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h\u2081 : \u2203! x, p x) (h\u2082 : \u2200 x, p x \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_swap {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (hy\u2081 : p y\u2081) (hy\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_and_true {p q : Prop} : (\u2203! _ : p, q \u2227 True) \u2194 p \u2227 q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique\u2082_swap {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hy\u2081 : p y\u2081) (hq\u2081 : q y\u2081 hy\u2081) (hy\u2082 : p y\u2082) (hq\u2082 : q y\u2082 hy\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_comm' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_unique_alt {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 ((\u2203 x, p x) \u2227 (\u2200 y z, p y \u2192 p z \u2192 z = y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_swap {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (hex : \u2203! x, p x) (h : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 x = y) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_of_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y : \u03b1} (py : p y) : y = Classical.choose h := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_comm [Subsingleton \u03b1] {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_pair {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*} [\u2200 x, Subsingleton (p x)]\n    {q : \u2200 x, p x \u2192 Prop} {\u03b2 : Prop}\n    (hex : \u2203! x, \u2203! hx : p x, q x hx)\n    (h : \u2200 x hx, q x hx \u2192 (\u2200 y hy, q y hy \u2192 y = x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_pair {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx)\n    {y\u2081 y\u2082 : \u03b1} (hy\u2081 : p y\u2081) (hq\u2081 : q y\u2081 hy\u2081) (hy\u2082 : p y\u2082) (hq\u2082 : q y\u2082 hy\u2082) : y\u2081 = y\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_equality {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hu : p u) (hv : p v) : v = u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_swap {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_exists {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (hex : \u2203! x, p x) (h : (\u2203 x, p x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_rev {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (py : p y) (pz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_pair_alt {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (hex : \u2203! x, p x) (h : \u2200 x, p x \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_equality' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hv : p v) (hu : p u) : u = v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_and {p q : Prop} : (\u2203! _ : p, q \u2227 True) \u2194 p \u2227 q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_comm_alt {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (py : p y) (pz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_unique_comm [Subsingleton \u03b1] {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (ht : True) (hex : \u2203! x, p x) (h : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 y = x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_exists {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h : \u2203! x, p x) (hb : (\u2203 x, p x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_of_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, True \u2227 p x) : \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_swap {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (hy\u2081 : p y\u2081) (hy\u2082 : p y\u2082) : y\u2082 = y\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_of_false {p : Prop} {q : p \u2192 Prop} (h : \u00acp) :\n    (\u2203! h' : p, q h') \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim\u2081 {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (hex : \u2203! x, p x) (h : \u2200 x, p x \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique\u2083 {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*}\n    [\u2200 x, Subsingleton (p x)] {q : \u2200 x, p x \u2192 Prop}\n    (h : \u2203! x, \u2203! hx : p x, q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hy\u2081 : p y\u2081) (hq\u2081 : q y\u2081 hy\u2081) (hy\u2082 : p y\u2082) (hq\u2082 : q y\u2082 hy\u2082) : y\u2081 = y\u2082 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 ((\u2203 x, p x) \u2227 (\u2200 y z, p y \u2192 p z \u2192 y = z)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_rev {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h\u2081 : \u2203! x, p x) (h\u2082 : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 y = x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_flip {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hu : p u) (hv : p v) : v = u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_or_comm {\u03b1 : Sort*} {a : \u03b1} : \u2203! x, a = x \u2228 x = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_and {p q : Prop} : p \u2227 q \u2192 (\u2203! _ : p, q) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_and_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 ((\u2203 x, p x) \u2227 (\u2200 y z, p y \u2192 p z \u2192 y = z)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z} (hy : p y) (hz : p z) : y = z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_and_false {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x \u2227 False) \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.swap_eq {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z} (hy : p y) (hz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_exists {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h : \u2203! x, p x) (H : (\u2203 x, p x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_of_subsingleton {\u03b1 : Sort*} [Subsingleton \u03b1]\n    {p : \u03b1 \u2192 Prop} : (\u2203! x, p x) \u2194 \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (hex : \u2203! x, p x) (h : \u2200 x, p x \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.intro_and_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (w : \u03b1)\n    (h\u2081 : p w) : \u2203! x, True \u2227 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_left' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h\u2080 : \u2203! x, p x) (h\u2081 : (\u2203 x, p x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_comm_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hu : p u) (hv : p v) : v = u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_false_iff_true {\u03b1 : Sort*} : (\u00ac\u2203! _ : \u03b1, False) \u2194 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_of_subsingleton_and_exists {\u03b1 : Sort*} [Subsingleton \u03b1]\n    {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) : \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_left' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : y = z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_rev {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h\u2081 : \u2203! x, p x) (h\u2082 : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 y = x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_flip {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hu : p u) (hv : p v) : v = u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_or_comm {\u03b1 : Sort*} (a : \u03b1) : \u2203! x, a = x \u2228 x = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_imp {p q : Prop} : p \u2192 (\u2203! _ : p, q) \u2192 q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.intro_and_true' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (w : \u03b1)\n    (hw : p w) : \u2203! x, True \u2227 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (ht : True) (hex : \u2203! x, p x)\n    (h : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 y = x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_of_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, True \u2227 p x) : \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_exists' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h : \u2203! x, p x) (hb : (\u2203 x, p x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_equality {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hu : p u) (hv : p v) : v = u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_unique_comm {\u03b1 : Sort*} [Subsingleton \u03b1]\n    {p : \u03b1 \u2192 Prop} : (\u2203! x, p x) \u2194 \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.choose_eq {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (h : \u2203! x, p x) : p (Classical.choose h) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_iff_exists_and_subsingleton {\u03b1 : Sort*} [Subsingleton \u03b1] {p : \u03b1 \u2192 Prop} : (\u2203! x, p x) \u2194 \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (h : \u2203! x, p x) : \u2203 x, p x \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_true {p q : Prop} : (\u2203! _ : p, q \u2227 True) \u2194 p \u2227 q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_symm_rev {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_of_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop} (h : \u2203! x, p x) (H : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 y = x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_imp {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop} (H : (\u2203 x, p x) \u2192 \u03b2) (h : \u2203! x, p x) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_of_true {\u03b1 : Sort*} : (True) \u2192 (\u2203! _ : \u03b1, True) \u2228 (\u00acNonempty \u03b1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_eq {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : y = z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_true {p : Prop} :\n    (\u2203! _ : p, True) \u2194 p := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.intro_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (w : \u03b1)\n    (hp : p w) : \u2203! x, p x \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_imp_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) : \u2200 y z, p y \u2192 p z \u2192 y = z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.swap_eq {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_and_false {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x \u2227 False) \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) : \u2203 x, p x \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_exists {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h : \u2203! x, p x) (H : (\u2203 x, p x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h : \u2203! x, p x) (H : \u2200 x, p x \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_if_and_only_if {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 ((\u2203 x, p x) \u2227 \u2200 y z, p y \u2192 p z \u2192 y = z) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_comm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hu : p u) (hv : p v) : v = u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_true {\u03b1 : Sort*} :\n    (\u2203! _ : \u03b1, True) \u2194 Subsingleton \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_of_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, True \u2227 p x) : \u2203 x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_or_eq {\u03b1 : Sort*} (a : \u03b1) :\n    \u2203! x, x = a \u2228 a = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_right' {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h\u2081 : \u2203! x, p x) (h\u2082 : (\u2203 x, p x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_reverse {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_and_true {\u03b1 : Sort*} {a : \u03b1} :\n    \u2203! x, (x = a \u2227 a = x) \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.choose_property {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) : p (Classical.choose h) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_or_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x \u2228 True) \u2194 Subsingleton \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.of_subsingleton {\u03b1 : Sort*} [Subsingleton \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2203 x, p x) \u2192 \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_and_imp_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x \u2227 True) \u2192 \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.swap_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hz : p z) (hy : p y) : y = z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_and_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) : \u2203 x, True \u2227 p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_rev_eq {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_exists_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h\u2081 : \u2203! x, p x) (h\u2082 : (\u2203 x, p x) \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_unique_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h : \u2203! x, p x) (H : \u2200 x, p x \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_if_exists_and_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    ((\u2203 x, p x) \u2227 (\u2200 y z, p y \u2192 p z \u2192 y = z)) \u2192 \u2203! x, p x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_or_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x \u2228 True) \u2194 Subsingleton \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_swap_rev {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.exists_or {\u03b1 : Sort*} {p q : \u03b1 \u2192 Prop}\n    (hp : \u2203! x, p x) (hq : \u2203! x, q x) : \u2203! x, p x \u2228 q x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_comm_symm {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {a b : \u03b1} (ha : p a) (hb : p b) : b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.unique_rev_eq {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hy : p y) (hz : p z) : z = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_prop_and {p q : Prop} : (\u2203! _ : p, q) \u2192 p \u2192 q := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.eq_flip_rev {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {u v : \u03b1} (hv : p v) (hu : p u) : u = v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.choose_mem {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) : p (Classical.choose h) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_exists_to_prop {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h : \u2203! x, p x) (hb : (\u2203 x, p x) \u2192 b) : b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_eq_or_comm {\u03b1 : Sort*} (a : \u03b1) : \u2203! x, a = x \u2228 x = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.elim_unique_to_prop {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {\u03b2 : Prop}\n    (h : \u2203! x, p x) (H : \u2200 x, p x \u2192 \u03b2) : \u03b2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_and_false_left {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, False \u2227 p x) \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.intro_true {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} (w : \u03b1)\n    (hw : p w) : \u2203! x, p x \u2227 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem existsUnique_imp_unique_eq {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) : \u2200 y z, p y \u2192 p z \u2192 y = z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Sort*}\n\nopen in Lean TSyntax.Compat\ntheorem ExistsUnique.swap_unique {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y z : \u03b1} (hz : p z) (hy : p y) : y = z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\n\ntheorem IsRefl.reflexive_apply [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\n\ntheorem Reflexive.rel_of_eq_imp {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : x = y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\n\ntheorem Reflexive.eq_imp_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : x = y \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\n\ntheorem Relation.map_id_left (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (g : \u03b2 \u2192 \u03b3) : Relation.Map r id g = fun a c \u21a6 \u2203 b, r a b \u2227 g b = c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_forall [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_flip {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_flip_imp_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : y = x \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_id_right (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b3) : Relation.Map r f id = fun c b \u21a6 \u2203 a, r a b \u2227 f a = c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_rel [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_imp_iff' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_rel_all [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_flip' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_const_left (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (c : \u03b3) : Relation.Map r (\u03bb _ : \u03b1 \u21a6 c) id = \u03bb _ b \u21a6 \u2203 a, r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_pointwise [IsRefl \u03b1 r] {x : \u03b1} : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_ne_imp {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n    (hr : \u00ac x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_const_right (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (c : \u03b3) :\n    Relation.Map r id (fun _ : \u03b2 \u21a6 c) = fun a _ \u21a6 \u2203 b, r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_univ [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_symm {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n    (hr : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_rel' [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n    (hr : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_const_left' (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (c : \u03b3) :\n    Relation.Map r (Function.const \u03b1 c) id = fun _ b \u21a6 \u2203 a, r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_self {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_rev {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_forall {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : \u2200 z : \u03b1, r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_flip_eq {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_related {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_congr_eq {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_every {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_symm {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r x y) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_point {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (u : \u03b1) : r u u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_ne {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_univ {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_symm {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_rel'' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_self [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_apply [IsRefl \u03b1 r] : \u2200 z : \u03b1, r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_rev {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_implies {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : (x = y) \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_const_right_apply (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (c : \u03b3) : Relation.Map r id (Function.const \u03b2 c) = fun a _ \u21a6 \u2203 b, r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.pointwise_reflexive [IsRefl \u03b1 r] {x : \u03b1} : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.universal_reflexive [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_ne {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : \u00ac x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_flip_eq {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_related [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_congr_eq {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_everywhere [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_symm_eq {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_pointwise [IsRefl \u03b1 r] (u : \u03b1) : r u u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_eq {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_singleton [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_left {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_left_imp_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : x = y \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_self' [IsRefl \u03b1 r] (y : \u03b1) : r y y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_right {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n    (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_imp_iff_rev {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} :\n    x = y \u2192 r y x \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_forall' [IsRefl \u03b1 r] : \u2200 z : \u03b1, r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.ne_imp_iff_rev {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} :\n    x \u2260 y \u2192 r y x \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.pointwise_reflexive' [IsRefl \u03b1 r] (w : \u03b1) : r w w := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.universal_reflexive' [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_symm_eq' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n    (hxy : y = x \u2192 r y x) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_left' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n    (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_single [IsRefl \u03b1 r] (t : \u03b1) : r t t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_left_imp_iff_rev {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} :\n    y = x \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_self_apply {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (y : \u03b1) : r y y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_symm_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_symm_imp_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : y = x \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_forall_apply {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : \u2200 z : \u03b1, r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_flip_eq_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_flip_imp_iff' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : x = y \u2192 r y x \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.self_relational {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_rev {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_imp_iff_rev' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_point {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] {x : \u03b1} : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_ne_imp' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : \u00ac x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_univ_apply {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_single {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (t : \u03b1) : r t t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.ne_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : x \u2260 y \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_everything {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_symm_eq_alt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {m n : \u03b1} (hr : n = m \u2192 r m n) : r m n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Symmetric.flip_left_eq {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Symmetric r) {a b : \u03b1} : r a b = r b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_const [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_all [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_symm (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_symm_imp_iff (h : Reflexive r) {x y : \u03b1} : y = x \u2192 r y x \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_ne (h : Reflexive r) {x y : \u03b1} (hxy : \u00ac x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_left' (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.point_reflexive [IsRefl \u03b1 r] {x : \u03b1} : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.univ_reflexive [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_inv (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_singleton' [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_rev' (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_imp_iff_rev'' (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_apply' [IsRefl \u03b1 r] (z : \u03b1) : r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_symm_eq_alt (h : Reflexive r) {m n : \u03b1} (hmn : n = m \u2192 r m n) : r m n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.everywhere_reflexive [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_apply\u2082 [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_comm {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_comm_imp_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : x = y \u2192 r y x \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_id_left_iff (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (g : \u03b2 \u2192 \u03b3) (a : \u03b1) (c : \u03b3) : Relation.Map r id g a c \u2194 \u2203 b, r a b \u2227 g b = c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_all' [IsRefl \u03b1 r] : \u2200 z : \u03b1, r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_swap {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_id_right_iff (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b3) (c : \u03b3) (b : \u03b2) : Relation.Map r f id c b \u2194 \u2203 a, r a b \u2227 f a = c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.point_reflexive' [IsRefl \u03b1 r] {a : \u03b1} : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_ne'' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hne : \u00acx \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_const_left_iff (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (c : \u03b3) (b : \u03b2) : Relation.Map r (Function.const \u03b1 c) id c b \u2194 \u2203 a, r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Relation.map_const_right_iff (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (c : \u03b3) (a : \u03b1) : Relation.Map r id (Function.const \u03b2 c) a c \u2194 \u2203 b, r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.ne_imp_iff_left' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : x \u2260 y \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_univ' [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Symmetric.flip_eq_of_symm' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Symmetric r) (x y : \u03b1) : flip r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_apply' [IsRefl \u03b1 r] (y : \u03b1) : r y y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_all' [IsRefl \u03b1 r] : \u2200 z : \u03b1, r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_ne_imp' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_point [IsRefl \u03b1 r] {x : \u03b1} : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_rev' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n  (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.everywhere_reflexive' [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.ne_imp_iff_left'' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} :\n  x \u2260 y \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_congr_eq' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1}\n  (hxy : x = y \u2192 r x y) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_single' [IsRefl \u03b1 r] (t : \u03b1) : r t t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_apply' [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_univ' [IsRefl \u03b1 r] : \u2200 x : \u03b1, r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_eq {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_swap {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_left {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_left_imp_iff' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : y = x \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_right {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_singleton [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.pointwise_reflexive'' [IsRefl \u03b1 r] {x : \u03b1} : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_not_ne_imp' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : \u00ac x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.ne_imp_iff_left'' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : x \u2260 y \u2192 r x y \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_everywhere' [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_pointwise' [IsRefl \u03b1 r] (u : \u03b1) : r u u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.refl_apply\u2082 [IsRefl \u03b1 r] (z : \u03b1) : r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_eq_symm' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.eq_rev_imp_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (y = x \u2192 r y x) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem IsRefl.reflexive_all' [IsRefl \u03b1 r] : \u2200 a : \u03b1, r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen Function ReflTransGen ReflGen Relation\ntheorem Reflexive.rel_of_imp_eq_rev'' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\n\ntheorem Reflexive.rel_of_eq_imp (h : Reflexive r) {x y : \u03b1} (hr : x = y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\n\ntheorem Reflexive.eq_imp_iff (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_apply {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_neq_imp' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.neq_imp_iff' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} : (x \u2260 y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem reflexive_neq_imp_iff'' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] {x y : \u03b1} : (x \u2260 y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Acc.of_fibration' {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : \u2200 {a b}, r\u03b2 b (f a) \u2192 \u2203 a', r\u03b1 a' a \u2227 f a' = b) {a : \u03b1} : Acc r\u03b1 a \u2192 Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem join_of_single' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {a b : \u03b1} (hab : r b a) : Relation.Join r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (y = x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_symm (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Acc.of_fibration'' {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2}\n    (fib : \u2200 {a b}, r\u03b2 (f a) b \u2192 \u2203 a', r\u03b1 a a' \u2227 f a' = b) {a : \u03b1} :\n    Acc r\u03b1 a \u2192 Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_id {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_swap {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_application {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_symmetric {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Acc.of_fibration_right {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 {a b}, r\u03b2 (f a) b \u2192 \u2203 a', r\u03b1 a' a \u2227 f a' = b) {a : \u03b1} :\n    Acc r\u03b1 a \u2192 Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp_alt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.of_eq_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff_symm {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (y = x \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.of_ne_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.of_ne_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_symm_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y \u2260 x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Relation.Fibration_of_Acc {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (fib : Relation.Fibration r\u03b1 r\u03b2 f) {a : \u03b1} (ha : Acc r\u03b1 a) : Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_flip (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_imp_left (h : Reflexive r) {x y : \u03b1} (hxy : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_twice {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_neq_imp'' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.neq_imp_iff'' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {x y : \u03b1} : (x \u2260 y \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_inverse (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff_inverse (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm_right (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_itself {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_symmetric' (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Relation.Fibration_of_Acc_left {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    {f : \u03b1 \u2192 \u03b2} (fib : Relation.Fibration r\u03b1 r\u03b2 f) {a : \u03b1} (ha : Acc r\u03b1 a) : Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp_leftAlt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_id' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm_leftAlt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : y \u2260 x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff_symm (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_of_reflexive {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Relation.Fibration.acc_left {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (fib : Relation.Fibration r\u03b1 r\u03b2 f) {a : \u03b1} : Acc r\u03b1 a \u2192 Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem reflGen_minimal_left {\u03b1 : Type*} {r r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr' : Reflexive r') (hsub : \u2200 x y, r x y \u2192 r' x y) {x y : \u03b1} (hxy : Relation.ReflGen r x y) : r' x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem transGen_minimal_left {\u03b1 : Type*} {r r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (ht' : Transitive r') (hsub : \u2200 x y, r x y \u2192 r' x y) {x y : \u03b1} (hxy : Relation.TransGen r x y) : r' x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem reflTransGen_minimal_left {\u03b1 : Type*} {r r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr' : Reflexive r') (ht' : Transitive r') (hsub : \u2200 x y, r x y \u2192 r' x y) {x y : \u03b1} (hxy : Relation.ReflTransGen r x y) : r' x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp_right {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self'' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Acc.of_fibration_left {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (fib : Relation.Fibration r\u03b1 r\u03b2 f) {a : \u03b1} : Acc r\u03b1 a \u2192 Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_twice {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_symm_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_symm_imp_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (y = x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (y \u2260 x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_apply_right {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_flip {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm_right {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Acc.of_fibration_right' {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 {a b}, r\u03b2 b (f a) \u2192 \u2203 a', r\u03b1 a' a \u2227 f a' = b)\n    {a : \u03b1} : Acc r\u03b1 a \u2192 Acc r\u03b2 (f a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_inverse {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_inverse_imp_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_twice' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_swap {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_symm_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hr : y \u2260 x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_imp_left (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_iff_left (h : Reflexive r) {x y : \u03b1} : (x \u2260 y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_rev (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_once {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (z : \u03b1) : r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm_right (h : Reflexive r) {x y : \u03b1} (hxy : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_symm_iff (h : Reflexive r) {x y : \u03b1} : (y \u2260 x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_flip (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_flip_iff (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (w : \u03b1) : r w w := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_of_reflexive (h : Reflexive r) {x y : \u03b1} (heq : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff_left (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_of_reflexive (h : Reflexive r) {x y : \u03b1} (hne : y \u2260 x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Relation.Join.of_equivalence {\u03b1 : Type*} {r r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (heq : Equivalence r) (hsub : \u2200 a b, r' a b \u2192 r a b) {x y : \u03b1} : Relation.Join r' x y \u2192 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (y \u2260 x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (y = x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem reflexive_eq_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] {x y : \u03b1} : (y = x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_apply_alt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Relation.Fibration.acc_right {\u03b1 \u03b2 : Type*} {r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop} {r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (fib : Relation.Fibration r\u03b1 r\u03b2 f) {b : \u03b2} {a : \u03b1} (h : f a = b) : (Acc r\u03b1 a) \u2192 Acc r\u03b2 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_symm_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_symm_right {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hr : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.self_twice_alt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (x : \u03b1) : r x x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (y \u2260 x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem reflexive_eq_imp_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] {x y : \u03b1} : (x = y \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_rel {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_iff_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (y \u2260 x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem flip_eq_iff_rev {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : r = flip r \u2194 Symmetric r := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_rel_swap {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self_alt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (z : \u03b1) : r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_imp_rev {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_iff_rev {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_imp_symm {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_flip {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_flip_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self_twice {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (w : \u03b1) : r w w := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_imp_alt {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (hne : y \u2260 x \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_inverse {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} (heq : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_inverse_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_flip_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_flip_imp_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2194 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_flip_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : x \u2260 y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_twice {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r]\n    (z : \u03b1) : r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_rev_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_rev_imp_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (y = x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_ne_swap {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hne : y \u2260 x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_swap_imp_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (y \u2260 x \u2192 r x y) \u2194 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.rel_of_eq_inverse' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hxy : x = y \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem ReflTransGen.eq_or_step {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    {a b : \u03b1} : Relation.ReflTransGen r a b \u2192 a = b \u2228 Relation.TransGen r a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} (hyp : y = x \u2192 r x y) : r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_flip_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2192 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsRefl \u03b1 r] (z : \u03b1) : r z z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (y \u2260 x \u2192 r x y) \u2192 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_or_rel {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : x = y \u2228 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_flip_imp {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (x \u2260 y \u2192 r x y) \u2192 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_right {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (x = y \u2192 r y x) \u2192 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self_left {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsRefl \u03b1 r] (w : \u03b1) : r w w := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_flip_imp2 {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (y = x \u2192 r x y) \u2192 r x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.ne_imp_right {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) {x y : \u03b1} : (x \u2260 y \u2192 r y x) \u2192 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_twice {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsRefl \u03b1 r] (v : \u03b1) : r v v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_or_rel' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Reflexive r) (x y : \u03b1) : x = y \u2228 r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem IsRefl.apply_self' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (a : \u03b1) : r a a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Relation.Join.symmetric_of_reflexive {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {a b : \u03b1} :\n    Relation.Join r a b \u2192 Relation.Join r b a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\nvariable {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}\nvariable (r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\nvariable {r\u03b1 r\u03b2}\nvariable {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}\nvariable (r) in\nvariable (r)\nvariable {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}\n\nopen ReflGen ReflTransGen Relation Function\ntheorem Reflexive.eq_imp_flip (h : Reflexive r) {x y : \u03b1}\n    (hxy : x = y \u2192 r y x) : r y x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem smul_mass {\u03a9 : Type*} [MeasurableSpace \u03a9] (c : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) : (c \u2022 \u03bc).mass = c \u2022 \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem add_mass {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9) : (\u03bc + \u03bd).mass = \u03bc.mass + \u03bd.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem restrict_mass_le {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (A : Set \u03a9) : (\u03bc.restrict A).mass \u2264 \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem restrict_eq_self_of_subset_univ {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.FiniteMeasure \u03a9) : \u03bc.restrict (Set.univ) = \u03bc := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem testAgainstNN_le_mass_mul_bound {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192\u1d47 \u211d\u22650) : \u03bc.testAgainstNN f \u2264 (\u2a06 x, f x) * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem smul_testAgainstNN_const {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) : (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = c * d * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem toWeakDualBCNN_injective {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9] : Function.Injective (MeasureTheory.FiniteMeasure.toWeakDualBCNN : MeasureTheory.FiniteMeasure \u03a9 \u2192 WeakDual \u211d\u22650 (\u03a9 \u2192\u1d47 \u211d\u22650)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem map_mass_eq_mass {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192 \u03a9') : (\u03bc.map f).mass = \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\n\ntheorem lipschitz_testAgainstNN_unit_mass {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9] (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (h\u03bc : \u03bc.mass = 1) : LipschitzWith 1 fun f : \u03a9 \u2192\u1d47 \u211d\u22650 \u21a6 \u03bc.testAgainstNN f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_smul_eq_mul {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (c : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).mass = c * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem restrict_univ_mass {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc.restrict Set.univ).mass = \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem restrict_empty_mass_zero {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc.restrict (\u2205 : Set \u03a9)).mass = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_smul_comm {\u03a9 : Type*} [MeasurableSpace \u03a9] (c : \u211d\u22650)\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).mass = \u03bc.mass * c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_of_add_swap {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bd + \u03bc).mass = \u03bc.mass + \u03bd.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem testAgainstNN_le_sup_mul_mass {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    [TopologicalSpace \u03a9] (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.testAgainstNN f \u2264 \u03bc.mass * (\u2a06 x, f x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_mul {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    [TopologicalSpace \u03a9] (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = \u03bc.mass * c * d := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_mass_mono {\u03a9 : Type*} [MeasurableSpace \u03a9] {c d : \u211d\u22650} (h : c \u2264 d)\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).mass \u2264 (d \u2022 \u03bc).mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem restrict_empty_eq_zero {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    \u03bc.restrict (\u2205 : Set \u03a9) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const' {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = c * (d * \u03bc.mass) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem toWeakDualBCNN_eq_iff {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    [OpensMeasurableSpace \u03a9] {\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9} :\n    \u03bc.toWeakDualBCNN = \u03bd.toWeakDualBCNN \u2194 \u03bc = \u03bd := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_of_add_comm {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc + \u03bd).mass = (\u03bd + \u03bc).mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_mul_flip {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    [TopologicalSpace \u03a9] (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = \u03bc.mass * d * c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_smul_pos_iff {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (c : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    0 < (c \u2022 \u03bc).mass \u2194 (0 < c \u2227 0 < \u03bc.mass) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_add_three {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc \u03bd \u03be : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc + \u03bd + \u03be).mass = \u03bc.mass + \u03bd.mass + \u03be.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem restrict_mass_eq_self {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (A : Set \u03a9) (hA : A = Set.univ) :\n    (\u03bc.restrict A).mass = \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem map_mass_le {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192 \u03a9') :\n    (\u03bc.map f).mass \u2264 \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem map_comp_mass_eq {\u03a9 \u03a9' \u03a9'' : Type*}\n    [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] [MeasurableSpace \u03a9'']\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192 \u03a9') (g : \u03a9' \u2192 \u03a9'') :\n    ((\u03bc.map f).map g).mass = \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem testAgainstNN_const_le {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (c : \u211d\u22650) :\n    \u03bc.testAgainstNN (BoundedContinuousFunction.const \u03a9 c) \u2264 c * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_of_add_comm {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc + \u03bd).mass = (\u03bd + \u03bc).mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_mass_le {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    {c : \u211d\u22650} {\u03bc : MeasureTheory.FiniteMeasure \u03a9} :\n    (c \u2022 \u03bc).mass \u2264 c * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_le_add {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    {\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9} :\n    \u03bc.mass \u2264 (\u03bc + \u03bd).mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_le {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    {c d : \u211d\u22650} {\u03bc : MeasureTheory.FiniteMeasure \u03a9} :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) \u2264 c * d * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem toWeakDualBCNN_eq_imp {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    [OpensMeasurableSpace \u03a9] {\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9} :\n    \u03bc.toWeakDualBCNN = \u03bd.toWeakDualBCNN \u2192 \u03bc = \u03bd := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem map_mass_le {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\n    {\u03bc : MeasureTheory.FiniteMeasure \u03a9} {f : \u03a9 \u2192 \u03a9'} :\n    (\u03bc.map f).mass \u2264 \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_smul_ge {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    {c : \u211d\u22650} {\u03bc : MeasureTheory.FiniteMeasure \u03a9} :\n    (c \u2022 \u03bc).mass \u2265 c * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_add_ge_left {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    {\u03bc \u03bd : MeasureTheory.FiniteMeasure \u03a9} :\n    \u03bc.mass \u2264 (\u03bd + \u03bc).mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_eq {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    {c d : \u211d\u22650} {\u03bc : MeasureTheory.FiniteMeasure \u03a9} :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = c * \u03bc.mass * d := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem restrict_mass_subset_eq {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.FiniteMeasure \u03a9) {A B : Set \u03a9} (hAB : A \u2286 B) : (\u03bc.restrict A).mass \u2264 (\u03bc.restrict B).mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_add_assoc {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc \u03bd \u03be : MeasureTheory.FiniteMeasure \u03a9) : (\u03bc + (\u03bd + \u03be)).mass = \u03bc.mass + \u03bd.mass + \u03be.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_swap {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = d * c * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem map_comp_mass_eq_id {\u03a9 \u03a9' \u03a9'' : Type*}\n    [MeasurableSpace \u03a9] [MeasurableSpace \u03a9'] [MeasurableSpace \u03a9'']\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192 \u03a9') (g : \u03a9' \u2192 \u03a9'') :\n    ((\u03bc.map f).map g).mass \u2264 \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_add_assoc' {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc \u03bd \u03be : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc + \u03bd + \u03be).mass = \u03bc.mass + (\u03bd.mass + \u03be.mass) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_comm {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = d * \u03bc.mass * c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_add_assoc_four {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc \u03bd \u03be \u03b7 : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc + \u03bd + \u03be + \u03b7).mass = \u03bc.mass + \u03bd.mass + \u03be.mass + \u03b7.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem testAgainstNN_const_bound {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (c : \u211d\u22650) :\n    \u03bc.testAgainstNN (BoundedContinuousFunction.const \u03a9 c) \u2264 \u03bc.mass * c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_comm {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = d * \u03bc.mass * c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_le_smul_mass {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (c : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    \u03bc.mass \u2264 (c + 1) \u2022 \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_const_comm {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    (c d : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).testAgainstNN (BoundedContinuousFunction.const \u03a9 d) = d * \u03bc.mass * c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem map_mass_le {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192 \u03a9') :\n    (\u03bc.map f).mass \u2264 \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_add_assoc {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc \u03bd \u03be : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc + (\u03bd + \u03be)).mass = \u03bc.mass + \u03bd.mass + \u03be.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_pos_of_nonzero {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (h\u03bc : \u03bc \u2260 0) :\n    0 < \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_add_idem {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (\u03bc + \u03bc).mass = 2 * \u03bc.mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_mass_lt_of_lt {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    {c d : \u211d\u22650} (hcd : c < d) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (h\u03bc : \u03bc.mass \u2260 0) :\n    (c \u2022 \u03bc).mass < (d \u2022 \u03bc).mass := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_smul_eq_zero_imp {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (c : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    (c \u2022 \u03bc).mass = 0 \u2192 (c = 0 \u2228 \u03bc.mass = 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_testAgainstNN_bound {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    [TopologicalSpace \u03a9] (c : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    (c \u2022 \u03bc).testAgainstNN f \u2264 c * \u03bc.testAgainstNN f := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem mass_smul_pos_iff {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (c : \u211d\u22650) (\u03bc : MeasureTheory.FiniteMeasure \u03a9) :\n    0 < (c \u2022 \u03bc).mass \u2194 (0 < c \u2227 0 < \u03bc.mass) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_mass_zero_iff_left {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (c : \u211d\u22650) :\n    (c \u2022 \u03bc).mass = 0 \u2194 (c = 0 \u2228 \u03bc.mass = 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9]\nvariable {R : Type*} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\nvariable [TopologicalSpace \u03a9]\nvariable [OpensMeasurableSpace \u03a9]\nvariable [HasOuterApproxClosed \u03a9] [BorelSpace \u03a9]\nvariable (\u03a9)\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable {\u03a9 \u03a9' : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03a9']\nvariable [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\nvariable [TopologicalSpace \u03a9'] [BorelSpace \u03a9']\n\nopen BoundedContinuousFunction MeasureTheory Function Filter NNReal scoped Topology ENNReal Set\ntheorem smul_mass' {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    (\u03bc : MeasureTheory.FiniteMeasure \u03a9) (c : \u211d\u22650) :\n    (c \u2022 \u03bc).mass = \u03bc.mass \u2022 c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem bernoulliFun_endpoints_sum_eq {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 0 + bernoulliFun k 1 = 2 * bernoulli k := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem bernoulliFun_one_eval_one :\n    bernoulliFun 1 1 = bernoulliFun 1 0 + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem hasDerivAt_bernoulliFun_succ (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun (k + 1)) ((k + 1) * bernoulliFun k x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem antideriv_bernoulliFun_succ (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 2) y / (k + 2)) (bernoulliFun (k + 1) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem bernoulliFourierCoeff_recurrence_succ (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff (k + 1) n =\n      1 / (-2 * \u03c0 * I * n) * (ite (k + 1 = 1) 1 0 - (k + 1) * bernoulliFourierCoeff k n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem bernoulliFourierCoeff_zero_succ {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff (k + 1) 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem hasSum_zeta_six :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 6) (\u03c0 ^ 6 / 945) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem hasSum_zeta_eight :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 8) (\u03c0 ^ 8 / 9450) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem Polynomial.bernoulli_four_eval_one_quarter :\n    (Polynomial.bernoulli 4).eval (1 / 4) = -1 / 30 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\n\ntheorem hasSum_L_function_mod_four_eval_five :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 5 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 5 / 1536) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_sum_eq' {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 1 + bernoulliFun k 0 = 2 * bernoulliFun k 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_diff_eq {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 1 - bernoulliFun k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_half_eq_zero_of_odd {k : \u2115} (hk : Odd k) :\n    bernoulliFun k (1 / 2) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_two_eval_one :\n    bernoulliFun 2 1 = bernoulliFun 2 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_neg_one :\n    bernoulliFun 1 (-1) = bernoulliFun 1 0 - 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_pred (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun k y / k) (bernoulliFun (k - 1) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_pred (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff k n =\n      1 / (-2 * \u03c0 * I * n) * (ite (k = 1) 1 0 - k * bernoulliFourierCoeff (k - 1) n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_ten :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 10) (\u03c0 ^ 10 / 93555) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_twelve :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 12) (\u03c0 ^ 12 / 638512875) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_five_eval_one_quarter :\n    (Polynomial.bernoulli 5).eval (1 / 4) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_six_eval_one_half :\n    (Polynomial.bernoulli 6).eval (1 / 2) = -31 / 1344 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 7 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_nine :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 9 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 9 / 98304) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_even_zero {k : \u2115} (hk : Even k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_odd_neg (k : \u2115) {n : \u2124} (hn : n \u2260 0) (hk : Odd k) :\n    bernoulliFourierCoeff k (-n) = (-1) ^ k * bernoulliFourierCoeff k n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_symmetry (k : \u2115) (x : \u211d) :\n    bernoulliFun k (1 - x) = (-1) ^ k * bernoulliFun k x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_avg_eq {k : \u2115} (hk : k \u2260 1) :\n    (bernoulliFun k 0 + bernoulliFun k 1) / 2 = bernoulli k := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_endpoint_difference :\n    bernoulliFun 1 1 - bernoulliFun 1 0 = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_succ_succ (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun (k + 2)) ((k + 2) * bernoulliFun (k + 1) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_succ_succ (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 3) y / (k + 3)) (bernoulliFun (k + 2) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_succ_alt (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    (-2 * \u03c0 * I * n) * bernoulliFourierCoeff (k + 1) n =\n      ite (k + 1 = 1) 1 0 - (k + 1) * bernoulliFourierCoeff k n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_succ_succ {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff (k + 2) 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_six_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 6) (2 * \u03c0 ^ 6 / 1890) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_eight_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 8) (2 * \u03c0 ^ 8 / 18900) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_one_half :\n    (Polynomial.bernoulli 4).eval (1 / 2) = 7 / 240 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_three_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 3 * Real.cos (\u03c0 * n / 2)) (-\u03c0 ^ 3 / 32) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_product_eq {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 0 * bernoulliFun k 1 = (bernoulli k) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_half_neg_eq_zero_of_odd {k : \u2115} (hk : Odd k) :\n    bernoulliFun k (-1 / 2) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_two_eval_one_alt :\n    bernoulliFun 2 1 = bernoulli 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_two :\n    bernoulliFun 1 2 = bernoulliFun 1 0 + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_pred_alt (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    (-2 * \u03c0 * I * n) * bernoulliFourierCoeff k n =\n      ite (k = 1) 1 0 - k * bernoulliFourierCoeff (k - 1) n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_alt {k : \u2115} (hk : 2 \u2264 k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_ten_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 10) (2 * \u03c0 ^ 10 / 187110) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_twelve_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 12) (4 * \u03c0 ^ 12 / 2554051500) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_five_eval_one_half :\n    (Polynomial.bernoulli 5).eval (1 / 2) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_six_eval_one_quarter :\n    (Polynomial.bernoulli 6).eval (1 / 4) = -31 / 1344 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 7 * Real.cos (\u03c0 * n / 2)) (-\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_nine_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 9 * Real.cos (\u03c0 * n / 2)) (-\u03c0 ^ 9 / 98304) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_odd_neg_alt (k : \u2115) {n : \u2124} (hn : n \u2260 0) (hk : Odd k) :\n    bernoulliFourierCoeff k (-n) = (-1) ^ (k + 1) * bernoulliFourierCoeff k n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_shift_symmetry (k : \u2115) (x : \u211d) :\n    bernoulliFun k (x + 1) = bernoulliFun k x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_one_quarter_alt :\n    (Polynomial.bernoulli 4).eval (1 / 4) = 1 / 30 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_five_alt :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 5 * Real.sin (\u03c0 * n / 2)) (-\u03c0 ^ 5 / 1536) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_pred_alt2 (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 1) y / (k + 1)) (bernoulliFun k x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_alt {k : \u2115} (hk : 1 < k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_twelve_variant :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 12) (2 * \u03c0 ^ 12 / 1277025750) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven_variant :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 7 * Real.sin (\u03c0 * n / 2)) (-\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_nine_variant :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 9 * Real.sin (\u03c0 * n / 2)) (-\u03c0 ^ 9 / 98304) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_symmetry_alt (k : \u2115) (x : \u211d) :\n    bernoulliFun k x = (-1) ^ k * bernoulliFun k (1 - x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_succ_succ_alt (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun (k + 3)) ((k + 3) * bernoulliFun (k + 2) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_succ_succ_alt (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 4) y / (k + 4)) (bernoulliFun (k + 3) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_succ_alt2 (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff (k + 1) n =\n      -((k + 1) / (2 * \u03c0 * I * n)) * bernoulliFourierCoeff k n +\n      (1 / (-2 * \u03c0 * I * n)) * ite (k + 1 = 1) 1 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_succ_succ_alt {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff (k + 3) 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_six_variant2 :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 6) (\u03c0 ^ 6 * 2 / 1890) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_eight_variant2 :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 8) (\u03c0 ^ 8 * 2 / 18900) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_three_variant :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 3 * Real.cos (\u03c0 * n / 2)) (\u03c0 ^ 3 / 32) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_two_alt :\n    bernoulliFun 1 2 = 2 + bernoulliFun 1 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_pred_alt2 (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff k n =\n      1 / (-2 * \u03c0 * I * n) * (ite (k = 1) 1 0) -\n      k / (-2 * \u03c0 * I * n) * bernoulliFourierCoeff (k - 1) n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_alt2 {k : \u2115} (hk : 2 \u2264 k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_ten_variant2 :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 10) (4 * \u03c0 ^ 10 / 374220) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_twelve_variant2 :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 12) (\u03c0 ^ 12 * 4 / 2554051500) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven_variant2 :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 7 * Real.cos (\u03c0 * n / 2)) (\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_nine_variant2 :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 9 * Real.cos (\u03c0 * n / 2)) (\u03c0 ^ 9 / 98304) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_odd_neg_alt2 (k : \u2115) {n : \u2124} (hn : n \u2260 0) (hk : Odd k) :\n    bernoulliFourierCoeff k n = (-1) ^ k * bernoulliFourierCoeff k (-n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_sum_eq_rev {k : \u2115} (hk : k \u2260 1) :\n    2 * bernoulli k = bernoulliFun k 1 + bernoulliFun k 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_one_alt :\n    bernoulliFun 1 1 = 1 + bernoulliFun 1 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_succ_swap (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun (k + 1)) (bernoulliFun k x * (k + 1)) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_succ_alt_sign (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff (k + 1) n =\n      -(1 / (2 * \u03c0 * I * n)) * ((k + 1) * bernoulliFourierCoeff k n - ite (k + 1 = 1) 1 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_sum_eq_double {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 0 + bernoulliFun k 1 = 2 * bernoulliFun k 0 + 2 * (bernoulli k - bernoulliFun k 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_new {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_succ_succ_new (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y \u21a6 bernoulliFun (k + 3) y / (k + 3)) (bernoulliFun (k + 2) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_succ_succ_new {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff (k + 2) 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_new_alt {k : \u2115} (hk : 2 \u2264 k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_nine_alt_new :\n    HasSum (fun n : \u2115 \u21a6 (1 : \u211d) / (n : \u211d) ^ 9 * Real.cos (\u03c0 * n / 2)) (-\u03c0 ^ 9 / 98304) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_strict {k : \u2115} (hk : 1 < k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven_variant_new :\n    HasSum (fun n : \u2115 \u21a6 1 / (n : \u211d) ^ 7 * Real.sin (\u03c0 * n / 2)) (-\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_alt2_new {k : \u2115} (hk : 2 \u2264 k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven_variant2_new :\n    HasSum (fun n : \u2115 \u21a6 1 / (n : \u211d) ^ 7 * Real.cos (\u03c0 * n / 2)) (\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_nine_variant2_new :\n    HasSum (fun n : \u2115 \u21a6 1 / (n : \u211d) ^ 9 * Real.cos (\u03c0 * n / 2)) (\u03c0 ^ 9 / 98304) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_sum_eq_twice {k : \u2115} (hk : k \u2260 1) :\n    2 * (bernoulliFun k 0 + bernoulliFun k 1) = 4 * bernoulli k := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_succ_alt (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y \u21a6 bernoulliFun (k + 1) y) ((k + 1) \u2022 bernoulliFun k x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_succ_alt (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y \u21a6 bernoulliFun (k + 2) y / (k + 2)) (bernoulliFun (k + 1) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_succ_shift (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff (k + 1) n =\n      (1 / (-2 * \u03c0 * I * n)) * (ite (k = 0) 1 0 - (k + 1) * bernoulliFourierCoeff k n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_one_eighth :\n    (Polynomial.bernoulli 4).eval (1 / 8) = -7 / 960 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_alt3 {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_five_eval_one_eighth :\n    (Polynomial.bernoulli 5).eval (1 / 8) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_six_eval_one_third :\n    (Polynomial.bernoulli 6).eval (1 / 3) = -31 / 972 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_nine_cos :\n    HasSum (fun n : \u2115 \u21a6 1 / (n : \u211d) ^ 9 * Real.cos (\u03c0 * n / 2)) (-\u03c0 ^ 9 / 98304) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_three_quarters :\n    (Polynomial.bernoulli 4).eval (3 / 4) = 1 / 30 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_three_sin :\n    HasSum (fun n : \u2115 \u21a6 1 / (n : \u211d) ^ 3 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 3 / 32) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_sum_eq_zero {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 0 + bernoulliFun k 1 - 2 * bernoulli k = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_half :\n    bernoulliFun 1 (1 / 2) = bernoulliFun 1 0 + 1 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_succ_succ_alt2 (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 3) y / (k + 3)) (bernoulliFun (k + 2) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_pred_eq_zero {k : \u2115} (hk : 1 < k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_four_alt :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 4) (\u03c0 ^ 4 / 90) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_three_eval_three_quarters :\n    (Polynomial.bernoulli 3).eval (3 / 4) = -3 / 64 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_one_eighth :\n    (Polynomial.bernoulli 4).eval (1 / 8) = -7 / 960 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_general {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_diff_piecewise (k : \u2115) :\n    bernoulliFun k 1 - bernoulliFun k 0 = ite (k = 1) 1 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_three :\n    bernoulliFun 1 3 = bernoulliFun 1 0 + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_neg (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff k (-n) = (-1) ^ k * bernoulliFourierCoeff k n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_two_eval_one_quarter :\n    (Polynomial.bernoulli 2).eval (1 / 4) = 1 / 48 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_symmetry (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff k n = (-1) ^ k * bernoulliFourierCoeff k (-n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_weighted_sum {k : \u2115} (hk : k \u2260 1) :\n    (bernoulliFun k 0 + 3 * bernoulliFun k 1) / 4 = bernoulli k := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_three :\n    bernoulliFun 1 3 = bernoulliFun 1 0 + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_shift (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff (k + 2) n =\n      1 / (-2 * \u03c0 * I * n) * (ite (k + 2 = 1) 1 0 - (k + 2) * bernoulliFourierCoeff (k + 1) n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_three :\n    HasSum (fun n : \u2115 \u21a6 (1 : \u211d) / (n : \u211d) ^ 3) (\u03c0 ^ 3 / 32) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_seven_eval_one_half :\n    (Polynomial.bernoulli 7).eval (1 / 2) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_eleven :\n    HasSum (fun n : \u2115 \u21a6 1 / (n : \u211d) ^ 11 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 11 / 393216) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_half_zero_of_even {k : \u2115} (hk : Even k) :\n    bernoulliFun k (1 / 2) = bernoulli k - (2 ^ (1 - k) - 1) * bernoulli k := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_two_eval_two :\n    bernoulliFun 2 2 = bernoulliFun 2 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_shift_periodicity (k : \u2115) (x : \u211d) :\n    bernoulliFun k (x + 2) = bernoulliFun k x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_fourteen :\n    HasSum (fun n : \u2115 \u21a6 (1 : \u211d) / (n : \u211d) ^ 14) (\u03c0 ^ 14 / 6385128750) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_three_eval_one_eighth :\n    (Polynomial.bernoulli 3).eval (1 / 8) = -3 / 512 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_general' {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_quad (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun (k + 4)) ((k + 4) * bernoulliFun (k + 3) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_quad (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y \u21a6 bernoulliFun (k + 5) y / (k + 5)) (bernoulliFun (k + 4) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_one_third :\n    (Polynomial.bernoulli 4).eval (1 / 3) = 7 / 162 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_succ_next {k : \u2115} (hk : k \u2260 0) : bernoulliFourierCoeff (k + 2) 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_quarter_pos : (Polynomial.bernoulli 4).eval (1 / 4) = 1 / -30 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_general {k : \u2115} (hk : k \u2260 0) : bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_quad (k : \u2115) (x : \u211d) : HasDerivAt (bernoulliFun (k + 4)) ((k + 4) * bernoulliFun (k + 3) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_quad (k : \u2115) (x : \u211d) : HasDerivAt (fun y \u21a6 bernoulliFun (k + 5) y / (k + 5)) (bernoulliFun (k + 4) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_weighted_sum {k : \u2115} (hk : k \u2260 1) : (bernoulliFun k 0 + 3 * bernoulliFun k 1) / 4 = bernoulli k := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_succ_shift (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 2) y / (k + 2)) (bernoulliFun (k + 1) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven_symm :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 7 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_succ_succ_comm (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun (k + 2)) (bernoulliFun (k + 1) x * (k + 2)) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_general_alt {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_sum_eq_alt {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 1 + bernoulliFun k 0 = 2 * bernoulliFun k 0 - 2 * (bernoulli k - bernoulliFun k 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_one_alt2 :\n    bernoulliFun 1 1 = 1 + bernoulliFun 1 (-0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_succ_alt_variant (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 1) y) ((k.succ) * bernoulliFun k x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_succ_variant (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff (k.succ) n =\n      1 / (-2 * \u03c0 * I * n) * (ite (k.succ = 1) 1 0 - (k.succ) * bernoulliFourierCoeff k n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_six_variant3 :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 6) (\u03c0 ^ 6 / 1890) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_eight_variant3 :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 8) (\u03c0 ^ 8 / 18900) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_half_eq_zero_of_odd_alt {k : \u2115} (hk : Odd k) :\n    bernoulliFun k (1 / 2) + bernoulliFun k (-1 / 2) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_two_eval_one_variant :\n    bernoulliFun 2 1 = bernoulliFun 2 (-0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_symmetry_variant (k : \u2115) (x : \u211d) :\n    bernoulliFun k (1 - x) + bernoulliFun k x = (1 + (-1) ^ k) * bernoulliFun k x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_ten_variant3 :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 10) (\u03c0 ^ 10 / 187110) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasDerivAt_bernoulliFun_succ_alt2 (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun (k.succ)) (bernoulliFun k x * (k.succ)) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_two_eval_one_variant :\n    bernoulliFun 2 1 = bernoulliFun 2 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_symmetry_variant (k : \u2115) (x : \u211d) :\n    bernoulliFun k (1 - x) + bernoulliFun k x = (1 + (-1) ^ k) * bernoulliFun k x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_ten_variant3 :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 10) (\u03c0 ^ 10 / 93555) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_general_alt {k : \u2115} (hk : k \u2260 0) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_L_function_mod_four_eval_seven_symm :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 7 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 7 / 21504) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_two_eval_three :\n    bernoulliFun 2 3 = bernoulliFun 2 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_four :\n    bernoulliFun 1 4 = bernoulliFun 1 0 + 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_zero_of_positive {k : \u2115} (hk : 0 < k) :\n    bernoulliFourierCoeff k 0 = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_sixteen :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 16) (\u03c0 ^ 16 / 325641566250) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_seven_eval_one_quarter :\n    (Polynomial.bernoulli 7).eval (1 / 4) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_recurrence_general (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff k n = 1 / (-2 * \u03c0 * I * n) * (if k = 1 then 1 else 0 - k * bernoulliFourierCoeff (k - 1) n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_two_alt :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 2) (\u03c0 ^ 2 / 6) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem Polynomial.bernoulli_four_eval_three_eighths :\n    (Polynomial.bernoulli 4).eval (3 / 8) = -1 / 80 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem antideriv_bernoulliFun_double (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun y => bernoulliFun (k + 2) y / (k + 2)) (bernoulliFun (k + 1) x) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_one_eval_minus_one_half :\n    bernoulliFun 1 (-1 / 2) = bernoulliFun 1 0 - 1 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_three_eval_quarter :\n    bernoulliFun 3 (1 / 4) = -3 / 64 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_four_eval_half :\n    bernoulliFun 4 (1 / 2) = 7 / 240 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem hasSum_zeta_eightteen :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ 18) (\u03c0 ^ 18 / 1133278.8) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFourierCoeff_power_symm (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff k n + bernoulliFourierCoeff k (-n) = (1 + (-1) ^ k) * bernoulliFourierCoeff k n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\n\n\nopen MeasureTheory Complex scoped Real Interval Nat intervalIntegral Set\ntheorem bernoulliFun_endpoints_sum_eq_alt2 {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 0 + bernoulliFun k 1 = 2 \u2022 (bernoulli k) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\n\ntheorem prime_of_fac_equiv_pred {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = (n - 1 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\n\ntheorem prime_iff_fac_equiv_pred {n : \u2115} (h : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = (n - 1 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_one {n : \u2115}\n    (h : ((n - 2)! : ZMod n) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_one {n : \u2115}\n    (h : n \u2260 1) : Prime n \u2194 ((n - 2)! : ZMod n) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_pred_neg {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = -(n - 1 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_pred_neg {n : \u2115}\n    (h : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = -(n - 1 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_eq_one (p : \u2115) [Fact p.Prime] : ((p - 2)! : ZMod p) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_two {n : \u2115} (h : ((n - 1)! : ZMod n) = 2) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_two {n : \u2115} (h : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_half {n : \u2115} (h : ((n - 1)! : ZMod n) = (n / 2 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_half {n : \u2115} (h : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (n / 2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_pred_pred {n : \u2115} (h : ((n - 2)! : ZMod n) = (n - 2 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_pred_pred {n : \u2115} (h : n \u2260 1) : Prime n \u2194 ((n - 2)! : ZMod n) = (n - 2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_double_neg {n : \u2115} (h : ((n - 1)! : ZMod n) = -(2 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_double_neg {n : \u2115} (h : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = -(2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_one_eq_one {n : \u2115}\n    (h : ((n - 1)! : ZMod n) * (-1 : ZMod n) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_one_eq_one {n : \u2115}\n    (h : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (-1 : ZMod n) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_eq_pred {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = (n - 1 : \u2115)) (h1 : 1 < n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_eq_pred {n : \u2115} (h : 1 < n) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = (n - 1 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_pred_factorial_one {n : \u2115}\n    (h : ((n - 2)! : ZMod n) = 1) (h1 : 2 < n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_pred_factorial_one {n : \u2115}\n    (h : 2 < n) : Prime n \u2194 ((n - 2)! : ZMod n) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_sq_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 2) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_eq_two {n : \u2115}\n    (h : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_sq_eq_one {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 2) = 1) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_sq_eq_one {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 2) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_pred_minus_two {n : \u2115} (h : ((n - 1)! : ZMod n) = (n - 2 : \u2115)) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_pred_minus_two {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (n - 2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_cubed_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 3) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_neg_one_mul_fac_eq_one {n : \u2115} (h : (-1 : ZMod n) * ((n - 1)! : ZMod n) = 1) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_neg_one_mul_fac_eq_one {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 (-1 : ZMod n) * ((n - 1)! : ZMod n) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_three {n : \u2115} (h : ((n - 1)! : ZMod n) = 3) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_three {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_half_neg {n : \u2115} (h : ((n - 1)! : ZMod n) = -(n / 2 : \u2115)) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_half_neg {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = -(n / 2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_double_neg_two {n : \u2115} (h : ((n - 2)! : ZMod n) = -(2 : \u2115)) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_double_neg_two {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 2)! : ZMod n) = -(2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_fourth_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 4) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_four {n : \u2115} (h : ((n - 1)! : ZMod n) = 4) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_four {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_pred_pred_factorial_two_eq_two {n : \u2115} (h : ((n - 2)! : ZMod n) = 2) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_pred_pred_factorial_two_eq_two {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 2)! : ZMod n) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_product_units_eq_neg_one (p : \u2115) [Fact p.Prime] : (\u220f x : (ZMod p)\u02e3, (x : ZMod p)) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_product_units_squared_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 2) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_neg_three {n : \u2115} (h : ((n - 1)! : ZMod n) = -(3 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_neg_three {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = -(3 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_pred_minus_three {n : \u2115} (h : ((n - 1)! : ZMod n) = (n - 3 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_pred_minus_three {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (n - 3 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_five_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 5) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_two_eq_two {n : \u2115} (h : ((n - 1)! : ZMod n) * (-2 : ZMod n) = 2) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_two_eq_two {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (-2 : ZMod n) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_sq_eq_minus_one {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 2) = -1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_sq_eq_minus_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 2) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_cubed_eq_neg_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 3) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_fourth_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 4) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_five {n : \u2115} (h : ((n - 1)! : ZMod n) = 5) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_five {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_half_plus_one {n : \u2115} (h : ((n - 1)! : ZMod n) = (n / 2 + 1 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_half_plus_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (n / 2 + 1 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_six_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 6) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_four_eq_one (p : \u2115) [Fact p.Prime] : (((p - 1)! : ZMod p) ^ 4) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_pow_four_eq_one {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 4) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_pow_four_eq_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 4) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_six_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 6) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_eq_neg_one (p : \u2115) [Fact p.Prime] : ((p - 3)! : ZMod p) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_three_alt {n : \u2115} (h : ((n - 1)! : ZMod n) = 3) (h1 : 2 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_three_alt {n : \u2115} (h : 2 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_units_prod_pow_five_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 5) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_half_pred_eq_one (p : \u2115) [Fact p.Prime] : ((p / 2 - 1)! : ZMod p) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_four_alt {n : \u2115} (h : ((n - 1)! : ZMod n) = 4) (h1 : 3 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_four_alt {n : \u2115} (h1 : 3 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_sq_eq_minus_one_alt {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 2) = -1) (h1 : 2 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_sq_eq_minus_one_alt {n : \u2115} (h1 : 2 \u2264 n) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 2) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_seven_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 7) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_six_eq_one (p : \u2115) [Fact p.Prime] : (((p - 1)! : ZMod p) ^ 6) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_cube_eq_neg_one (p : \u2115) [Fact p.Prime] : (((p - 1)! : ZMod p) ^ 3) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_cube_eq_neg_one {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 3) = -1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_cube_eq_neg_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 3) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_seven_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 7) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_fourth_eq_neg_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 4) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_half_plus_two {n : \u2115} (h : ((n - 1)! : ZMod n) = (n / 2 + 2 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_half_plus_two {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (n / 2 + 2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_three_eq_three {n : \u2115} (h : ((n - 1)! : ZMod n) * (-3 : ZMod n) = 3) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_three_eq_three {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (-3 : ZMod n) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_eight_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 8) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_nine_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 9) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_six {n : \u2115} (h : ((n - 1)! : ZMod n) = 6) (h1 : 2 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_six {n : \u2115} (h1 : 2 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_two_eq_minus_two {n : \u2115} (h : ((n - 1)! : ZMod n) * (2 : ZMod n) = -2) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_two_eq_minus_two {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (2 : ZMod n) = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_ten_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 10) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_units_prod_pow_nine_eq_neg_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 9) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_seven {n : \u2115} (h : ((n - 1)! : ZMod n) = 7) (h1 : 2 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_seven {n : \u2115} (h1 : 2 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_four_eq_four {n : \u2115} (h : ((n - 1)! : ZMod n) * (-4 : ZMod n) = 4) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_four_eq_four {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (-4 : ZMod n) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_twelve_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 12) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_eleven_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 11) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_quad_eq_neg_one (p : \u2115) [Fact p.Prime] : (((p - 3)! : ZMod p) ^ 4) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_quad_eq_neg_one {n : \u2115} (h : (((n - 3)! : ZMod n) ^ 4) = -1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_quad_eq_neg_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 (((n - 3)! : ZMod n) ^ 4) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_units_prod_pow_fourteen_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 14) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_thirteen_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 13) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_eight {n : \u2115} (h : ((n - 1)! : ZMod n) = 8) (h1 : 3 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_eight {n : \u2115} (h1 : 3 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_five_eq_five {n : \u2115} (h : ((n - 1)! : ZMod n) * (-5 : ZMod n) = 5) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_five_eq_five {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (-5 : ZMod n) = 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_zero {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = 0) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_zero {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    ((p - 2)! : ZMod p) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_sq_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 2) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_cube_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 3) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_product_units_eq_one (p : \u2115) [Fact p.Prime] :\n    (\u220f x : (ZMod p)\u02e3, (x : ZMod p)) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_product_units_cubed_eq_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 3) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_succ_one {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = (n + 1 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_succ_one {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = (n + 1 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_double {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = (2 * n : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_double {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = (2 * n : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_mul_two_eq_two (p : \u2115) [Fact p.Prime] :\n    ((p - 1)! : ZMod p) * (2 : ZMod p) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_two_eq_two {n : \u2115}\n    (h : ((n - 1)! : ZMod n) * (2 : ZMod n) = 2) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_two_eq_two {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) * (2 : ZMod n) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_five_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 5) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_neg_four {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = -(4 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_neg_four {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = -(4 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_mul_neg_two_eq_minus_two (p : \u2115) [Fact p.Prime] :\n    ((p - 1)! : ZMod p) * (-2 : ZMod p) = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_two_eq_minus_two {n : \u2115}\n    (h : ((n - 1)! : ZMod n) * (-2 : ZMod n) = -2) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_two_eq_minus_two {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) * (-2 : ZMod n) = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_quad_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 3)! : ZMod p) ^ 4) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_quad_eq_one {n : \u2115}\n    (h : (((n - 3)! : ZMod n) ^ 4) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_quad_eq_one {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 (((n - 3)! : ZMod n) ^ 4) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_eight_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 8) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_seven_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 7) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_nine {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = 9) (h1 : 2 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_nine {n : \u2115} (h1 : 2 \u2264 n) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_five_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 1)! : ZMod p) ^ 5) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_pow_five_eq_one {n : \u2115}\n    (h : (((n - 1)! : ZMod n) ^ 5) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_pow_five_eq_one {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 (((n - 1)! : ZMod n) ^ 5) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_ten_eq_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 10) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_nine_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 9) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_ten {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = 10) (h1 : 2 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_ten {n : \u2115} (h1 : 2 \u2264 n) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = 10 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_six_eq_six {n : \u2115}\n    (h : ((n - 1)! : ZMod n) * (-6 : ZMod n) = 6) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_six_eq_six {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) * (-6 : ZMod n) = 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_eleven_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 11) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_twelve_eq_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 12) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_eleven {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = 11) (h1 : 3 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_eleven {n : \u2115} (h1 : 3 \u2264 n) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = 11 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_six_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 1)! : ZMod p) ^ 6) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_cube_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 1)! : ZMod p) ^ 3) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_cube_eq_one {n : \u2115}\n    (h : (((n - 1)! : ZMod n) ^ 3) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_cube_eq_one {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 (((n - 1)! : ZMod n) ^ 3) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_thirteen_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 13) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_twelve {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = 12) (h1 : 3 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_twelve {n : \u2115} (h1 : 3 \u2264 n) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = 12 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_seven_eq_seven {n : \u2115}\n    (h : ((n - 1)! : ZMod n) * (-7 : ZMod n) = 7) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_seven_eq_seven {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) * (-7 : ZMod n) = 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_eq_one_variant (p : \u2115) [Fact p.Prime] :\n    ((p - 2)! : ZMod p) * (p - 1 : \u2115) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_sq_eq_one_variant (p : \u2115) [Fact p.Prime] :\n    (((p - 3)! : ZMod p) ^ 2) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_neg_one_forward {n : \u2115} (h1 : Prime n) :\n    ((n - 1)! : ZMod n) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem fac_not_neg_one_of_composite {n : \u2115}\n    (h1 : n \u2260 1) (h2 : \u00ac Prime n) :\n    ((n - 1)! : ZMod n) \u2260 -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_units_prod_pow_four_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 4) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_eight_eq_one_variant (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 8) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_four_eq_minus_one (p : \u2115) [Fact p.Prime] :\n    (((p - 1)! : ZMod p) ^ 4) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_neg_one_eq_neg_one {n : \u2115} (h : ((n - 1)! : ZMod n) * (-1 : ZMod n) = -1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_neg_one_eq_neg_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (-1 : ZMod n) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_five_eq_neg_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 5) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_factorial_pred_sq_eq_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 (((n - 2)! : ZMod n) ^ 2) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_factorial_pred_eq_two {n : \u2115} (h : ((n - 1)! : ZMod n) = 2) (h1 : 1 < n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_factorial_pred_eq_two {n : \u2115} (h1 : 1 < n) : Prime n \u2194 ((n - 1)! : ZMod n) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_half_pred_eq_minus_one (p : \u2115) [Fact p.Prime] : ((p / 2 - 1)! : ZMod p) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_three_eq_minus_three {n : \u2115} (h : ((n - 1)! : ZMod n) * (3 : ZMod n) = -3) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_three_eq_minus_three {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (3 : ZMod n) = -3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_eleven_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 11) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_eight_eq_minus_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 8) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_eight_alt {n : \u2115} (h : ((n - 1)! : ZMod n) = 8) (h1 : 2 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_eight_alt {n : \u2115} (h1 : 2 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_seven_eq_minus_one (p : \u2115) [Fact p.Prime] : (((p - 1)! : ZMod p) ^ 7) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_pow_seven_eq_minus_one {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 7) = -1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_pow_seven_eq_minus_one {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 7) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_nine_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 9) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_fifteen_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 15) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_mul_three_eq_three (p : \u2115) [Fact p.Prime] : ((p - 1)! : ZMod p) * (3 : ZMod p) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_sixteen_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 16) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_half_pred_eq_two (p : \u2115) [Fact p.Prime] : ((p / 2 - 1)! : ZMod p) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_four_eq_minus_four {n : \u2115} (h : ((n - 1)! : ZMod n) * (4 : ZMod n) = -4) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_four_eq_minus_four {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (4 : ZMod n) = -4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_eight_eq_one (p : \u2115) [Fact p.Prime] : (((p - 1)! : ZMod p) ^ 8) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_thirteen {n : \u2115} (h : ((n - 1)! : ZMod n) = 13) (h\u2081 : 3 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_thirteen {n : \u2115} (h\u2081 : 3 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 13 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_twenty_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 20) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_fourteen_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 14) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_sq_eq_minus_two {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 2) = -(2 : \u2115)) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_sq_eq_minus_two {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 2) = -(2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_cube_eq_two (p : \u2115) [Fact p.Prime] : (((p - 1)! : ZMod p) ^ 3) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_units_prod_pow_eighteen_eq_neg_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 18) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_half_minus_one {n : \u2115} (h : ((n - 1)! : ZMod n) = (n / 2 - 1 : \u2115)) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_half_minus_one {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (n / 2 - 1 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_seventeen_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 17) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_sixteen_eq_one (p : \u2115) [Fact p.Prime] : (((p - 2)! : ZMod p) ^ 16) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_fourteen {n : \u2115} (h : ((n - 1)! : ZMod n) = 14) (h\u2081 : 4 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_fourteen {n : \u2115} (h\u2081 : 4 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 14 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_nineteen_eq_neg_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 19) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_half_pred_eq_three (p : \u2115) [Fact p.Prime] : ((p / 2 - 1)! : ZMod p) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_nine_eq_one (p : \u2115) [Fact p.Prime] : (((p - 1)! : ZMod p) ^ 9) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_fourteen_alt {n : \u2115} (h : ((n - 1)! : ZMod n) = 14) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_fourteen_alt {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = 14 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_sq_eq_two {n : \u2115} (h : (((n - 1)! : ZMod n) ^ 2) = 2) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_sq_eq_two {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 (((n - 1)! : ZMod n) ^ 2) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_units_prod_pow_fifteen_eq_neg_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 15) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_four_eq_four {n : \u2115} (h : ((n - 1)! : ZMod n) * (4 : ZMod n) = 4) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_four_eq_four {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (4 : ZMod n) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_sixteen {n : \u2115} (h : ((n - 1)! : ZMod n) = 16) (h\u2081 : 4 \u2264 n) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_sixteen {n : \u2115} (h\u2081 : 4 \u2264 n) : Prime n \u2194 ((n - 1)! : ZMod n) = 16 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_twentyfour_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 24) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_half_pred_eq_four (p : \u2115) [Fact p.Prime] : ((p / 2 - 1)! : ZMod p) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_half_minus_two {n : \u2115} (h : ((n - 1)! : ZMod n) = (n / 2 - 2 : \u2115)) (h\u2081 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_half_minus_two {n : \u2115} (h\u2081 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = (n / 2 - 2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_equiv_one (p : \u2115) [Fact p.Prime] : ((p - 3)! : ZMod p) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_three_eq_three {n : \u2115} (h : ((n - 1)! : ZMod n) * (3 : ZMod n) = 3) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_three_eq_three {n : \u2115} (h1 : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) * (3 : ZMod n) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_fourth_eq_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 4) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_cubed_eq_neg_one (p : \u2115) [Fact p.Prime] : ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 3) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_three {n : \u2115} (h : ((n - 1)! : ZMod n) = 3) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_double_plus_one {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = (2 * n + 1 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_double_plus_one {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = (2 * n + 1 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_units_prod_pow_twenty_two_eq_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 22) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_mul_five_eq_minus_five {n : \u2115}\n    (h : ((n - 1)! : ZMod n) * (5 : ZMod n) = -5) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_mul_five_eq_minus_five {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) * (5 : ZMod n) = -5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_half_pred_sq_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p / 2 - 1)! : ZMod p) ^ 2) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_mul_four_eq_four (p : \u2115) [Fact p.Prime] :\n    ((p - 1)! : ZMod p) * (4 : ZMod p) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_sq_eq_four {n : \u2115}\n    (h : (((n - 1)! : ZMod n) ^ 2) = 4) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_sq_eq_four {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 (((n - 1)! : ZMod n) ^ 2) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_eighteen_eq_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 18) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_pow_twelve_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 2)! : ZMod p) ^ 12) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_nine_alt {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = 9) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_nine_alt {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_ten_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 1)! : ZMod p) ^ 10) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_pow_six_eq_one {n : \u2115}\n    (h : (((n - 1)! : ZMod n) ^ 6) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_pow_six_eq_one {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 (((n - 1)! : ZMod n) ^ 6) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_neg_five {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = -(5 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_neg_five {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = -(5 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_mul_eq_one (p : \u2115) [Fact p.Prime] :\n    ((p - 2)! : ZMod p) * ((p - 2)! : ZMod p) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_half_minus_three {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = (n / 2 - 3 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_half_minus_three {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = (n / 2 - 3 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilson_units_prod_pow_twenty_one_eq_one (p : \u2115) [Fact p.Prime] :\n    ((\u220f x : (ZMod p)\u02e3, (x : ZMod p)) ^ 21) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_half_pred_sq_eq_neg_one (p : \u2115) [Fact p.Prime] :\n    (((p / 2 - 1)! : ZMod p) ^ 2) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_double_plus_two {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = (2 * n + 2 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_equiv_double_plus_two {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 ((n - 1)! : ZMod n) = (2 * n + 2 : \u2115) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem wilsons_factorial_pow_eleven_eq_one (p : \u2115) [Fact p.Prime] :\n    (((p - 1)! : ZMod p) ^ 11) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_pow_eleven_eq_one {n : \u2115}\n    (h : (((n - 1)! : ZMod n) ^ 11) = 1) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_iff_fac_pow_eleven_eq_one {n : \u2115} (h1 : n \u2260 1) :\n    Prime n \u2194 (((n - 1)! : ZMod n) ^ 11) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem factorial_pred_pred_eq_two (p : \u2115) [Fact p.Prime] :\n    ((p - 2)! : ZMod p) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (p : \u2115) [Fact p.Prime]\nvariable {n : \u2115}\n\nopen scoped Finset FiniteField Nat ZMod\ntheorem prime_of_fac_equiv_neg_six {n : \u2115}\n    (h : ((n - 1)! : ZMod n) = -(6 : \u2115)) (h1 : n \u2260 1) : Prime n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\n\ntheorem Int.isField_iff_false : IsField \u2124 \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\n\ntheorem NumberField.mem_span_integralBasis_iff {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u2124 (Set.range (integralBasis K))) \u2194 \u2203 y : \ud835\udcde K, algebraMap (\ud835\udcde K) K y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.not_isField : \u00acIsField \u2115 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_false : IsField \u2115 \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_iff_rational {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u211a (Set.range (integralBasis K))) \u2194 \u2203 y : \ud835\udcde K, algebraMap (\ud835\udcde K) K y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_one : IsField \u2124 \u2194 (0 : \u2124) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_one' : IsField \u2124 \u2194 (0 : \u2124) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_implies_one_eq_zero : IsField \u2115 \u2192 (1 : \u2115) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_two : IsField \u2124 \u2194 (1 : \u2124) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.span_integralBasis_contains {K : Type*} [Field K] [NumberField K] (y : \ud835\udcde K) : (algebraMap (\ud835\udcde K) K y) \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_implies_two_eq_one : IsField \u2115 \u2192 (2 : \u2115) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_one_eq_zero : IsField \u2115 \u2194 (1 : \u2115) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_negOne : IsField \u2124 \u2194 (0 : \u2124) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_int {K : Type*} [Field K] [NumberField K] {x : K} : x \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, algebraMap _ _ y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_one_eq_three : IsField \u2115 \u2194 (1 : \u2115) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_rat {K : Type*} [Field K] [NumberField K] {x : K} : x \u2208 Submodule.span \u211a (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, algebraMap _ _ y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_three : IsField \u2124 \u2194 (1 : \u2124) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_two_eq_zero : IsField \u2124 \u2194 (2 : \u2124) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_implies_two_eq_zero : IsField \u2115 \u2192 (2 : \u2115) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_four : IsField \u2124 \u2194 (1 : \u2124) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_implies_three_eq_one : IsField \u2115 \u2192 (3 : \u2115) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_two_eq_zero : IsField \u2115 \u2194 (2 : \u2115) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_negOne : IsField \u2124 \u2194 (1 : \u2124) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_one_eq_two : IsField \u2115 \u2194 (1 : \u2115) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_two_eq_one : IsField \u2124 \u2194 (2 : \u2124) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_three : IsField \u2124 \u2194 (1 : \u2124) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_implies_three_eq_one : IsField \u2115 \u2192 (3 : \u2115) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_two_eq_zero : IsField \u2124 \u2194 (2 : \u2124) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_one_eq_three : IsField \u2115 \u2194 (1 : \u2115) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_int_rev {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u2124 (Set.range (integralBasis K))) \u2192 \u2203 y : \ud835\udcde K, (y : K) = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_rat_rev {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u211a (Set.range (integralBasis K))) \u2192 \u2203 y : \ud835\udcde K, (y : K) = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_implies_two_eq_zero : IsField \u2115 \u2192 (2 : \u2115) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_four : IsField \u2124 \u2194 (1 : \u2124) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_two_eq_zero : IsField \u2115 \u2194 (2 : \u2115) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_two : IsField \u2124 \u2194 (0 : \u2124) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_three : IsField \u2124 \u2194 (0 : \u2124) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_two_eq_negTwo : IsField \u2124 \u2194 (2 : \u2124) = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_four_eq_one : IsField \u2124 \u2194 (4 : \u2124) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_negOne_eq_zero : IsField \u2124 \u2194 (-1 : \u2124) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_three_eq_one : IsField \u2124 \u2194 (3 : \u2124) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_two_eq_three : IsField \u2124 \u2194 (2 : \u2124) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_zero_eq_three : IsField \u2115 \u2194 (0 : \u2115) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_two_eq_one : IsField \u2115 \u2194 (2 : \u2115) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_zero_eq_two : IsField \u2115 \u2194 (0 : \u2115) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_imp_exists {K : Type*} [Field K] [NumberField K] {x : K} : x \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, algebraMap (\ud835\udcde K) K y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_rational_imp_exists {K : Type*} [Field K] [NumberField K] {x : K} : x \u2208 Submodule.span \u211a (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, algebraMap (\ud835\udcde K) K y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_int_alt {K : Type*} [Field K] [NumberField K] {x : K} : x \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, (y : K) = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_rat_alt {K : Type*} [Field K] [NumberField K] {x : K} : x \u2208 Submodule.span \u211a (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, (y : K) = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_int_rev_alt {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u2124 (Set.range (integralBasis K))) \u2192 \u2203 y : \ud835\udcde K, algebraMap _ _ y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists_rat_rev_alt {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u211a (Set.range (integralBasis K))) \u2192 \u2203 y : \ud835\udcde K, algebraMap _ _ y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_negTwo : IsField \u2124 \u2194 (1 : \u2124) = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_two_eq_negOne : IsField \u2124 \u2194 (2 : \u2124) = -1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_negTwo : IsField \u2124 \u2194 (0 : \u2124) = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_five : IsField \u2124 \u2194 (1 : \u2124) = 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_one_eq_four : IsField \u2115 \u2194 (1 : \u2115) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_iff_exists {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u2124 (Set.range (integralBasis K))) \u2194 \u2203 y : \ud835\udcde K, x = algebraMap (\ud835\udcde K) K y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_iff_rational_alt {K : Type*} [Field K] [NumberField K] {x : K} : (x \u2208 Submodule.span \u211a (Set.range (integralBasis K))) \u2194 \u2203 y : \ud835\udcde K, x = algebraMap (\ud835\udcde K) K y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_negOne_eq_zero : IsField \u2124 \u2194 (-1 : \u2124) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_zero_eq_one : IsField \u2115 \u2194 (0 : \u2115) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isDomain_iff_zero_eq_one : IsDomain \u2124 \u2194 (0 : \u2124) \u2260 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_imp (K : Type*) [Field K] [NumberField K] {x : K} : x \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, x = algebraMap (\ud835\udcde K) K y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_five_eq_two : IsField \u2124 \u2194 (5 : \u2124) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_two_eq_three : IsField \u2115 \u2194 (2 : \u2115) = 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_negTwo : IsField \u2124 \u2194 (0 : \u2124) = -2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.not_isDomain : \u00acIsDomain \u2115 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.integralBasis_surjective (K : Type*) [Field K] [NumberField K] : Function.Surjective (algebraMap (\ud835\udcde K) K) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_five : IsField \u2124 \u2194 (1 : \u2124) = 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_five_eq_six : IsField \u2124 \u2194 (5 : \u2124) = 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_zero_eq_four : IsField \u2115 \u2194 (0 : \u2115) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_rational_imp_exists' {K : Type*} [Field K] [NumberField K] {x : K} :\n  x \u2208 Submodule.span \u211a (Set.range (integralBasis K)) \u2192 \u2203 y : \ud835\udcde K, x = algebraMap (\ud835\udcde K) K y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_three_eq_two : IsField \u2124 \u2194 (3 : \u2124) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_one_eq_four : IsField \u2115 \u2194 (1 : \u2115) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_negTwo_eq_zero : IsField \u2124 \u2194 (-2 : \u2124) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_zero_eq_four : IsField \u2124 \u2194 (0 : \u2124) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_three_eq_zero : IsField \u2115 \u2194 (3 : \u2115) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_five_eq_two : IsField \u2124 \u2194 (5 : \u2124) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isDomain_iff_zero_neq_two : IsDomain \u2124 \u2194 (0 : \u2124) \u2260 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.not_isDomain_false : IsDomain \u2124 \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_six_eq_seven : IsField \u2124 \u2194 (6 : \u2124) = 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_zero_eq_four : IsField \u2115 \u2194 (0 : \u2115) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_three_eq_five : IsField \u2124 \u2194 (3 : \u2124) = 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_implies_five_eq_two : IsField \u2115 \u2192 (5 : \u2115) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_negTwo_eq_one : IsField \u2124 \u2194 (-2 : \u2124) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_one_eq_zero_variation : IsField \u2124 \u2194 (1 : \u2124) = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_neg_one_eq_one : IsField \u2124 \u2194 (-1 : \u2124) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_four_eq_two : IsField \u2124 \u2194 (4 : \u2124) = 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_four_eq_five : IsField \u2115 \u2194 (4 : \u2115) = 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.span_integralBasis_contains_one {K : Type*} [Field K] [NumberField K] : (1 : K) \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_three_eq_four : IsField \u2124 \u2194 (3 : \u2124) = 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_five_eq_six : IsField \u2115 \u2194 (5 : \u2115) = 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isDomain_iff_two_ne_three : IsDomain \u2124 \u2194 (2 : \u2124) \u2260 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.not_isField_equiv : (\u00acIsField \u2124) \u2194 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.integralBasis_linearIndependent {K : Type*} [Field K] [NumberField K] : LinearIndependent \u2124 (integralBasis K) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem NumberField.mem_span_integralBasis_exists' {K : Type*} [Field K] [NumberField K] {x : K} :\n    (\u2203 y : \ud835\udcde K, algebraMap (\ud835\udcde K) K y = x) \u2192\n      x \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Nat.isField_iff_seven_eq_eight : IsField \u2115 \u2194 (7 : \u2115) = 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable (K L : Type*) [Field K] [Field L]\nvariable {K} {L} in\nvariable {K}\nvariable (K)\nvariable [NumberField K]\nvariable {K} {M : Type*}\nvariable (K L : Type*) [Field K] [Field L] [Algebra K L]\n\nopen nonZeroDivisors NumberField Function Polynomial scoped Module\ntheorem Int.isField_iff_eight_eq_nine : IsField \u2124 \u2194 (8 : \u2124) = 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\n\ntheorem pdf_eq_indicator' {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] fun x => if x \u2208 s then (\u03bc s)\u207b\u00b9 else 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\n\ntheorem pdf_pos_on_set {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hns : \u03bc s \u2260 0) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    (pdf X \u2119 \u03bc) \u207b\u00b9' {0}\u1d9c \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_indicator_alt {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] s.indicator (fun _ => (\u03bc s)\u207b\u00b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_zero_outside_set {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    s\u1d9c \u2286 (pdf X \u2119 \u03bc) \u207b\u00b9' {0} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem mass_inside_uniformOfFinset {\u03b1 : Type*} {s : Finset \u03b1} (hs : s.Nonempty) :\n    (\u2211' a, if a \u2208 s then PMF.uniformOfFinset s hs a else 0) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem mass_inside_ofMultiset {\u03b1 : Type*} {s : Multiset \u03b1} (hs : s \u2260 0) :\n    (\u2211' a, if a \u2208 s.toFinset then PMF.ofMultiset s hs a else 0) = 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_piecewise {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] fun x => (\u03bc s)\u207b\u00b9 * (if x \u2208 s then 1 else 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_subset_set {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | pdf X \u2119 \u03bc x \u2260 0} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_indicator_scaled {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] (\u03bc s)\u207b\u00b9 \u2022 s.indicator 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_restrict_indicator {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc.restrict s] fun _ => (\u03bc s)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {t : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X t \u2119 \u03bc) :\n    (fun x => pdf X \u2119 \u03bc x) \u207b\u00b9' {0}\u1d9c \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem uniformOfFintype_apply_lt_one {\u03b1 : Type*} [Fintype \u03b1] [Nonempty \u03b1] (a : \u03b1) :\n    PMF.uniformOfFintype \u03b1 a < 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem uniformOfFinset_nonzero_iff_mem {\u03b1 : Type*} {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1} :\n    (PMF.uniformOfFinset s hs a \u2260 0) \u2194 a \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem ofMultiset_nonzero_iff_mem {\u03b1 : Type*} {s : Multiset \u03b1} (hs : s \u2260 0) {a : \u03b1} :\n    (PMF.ofMultiset s hs a \u2260 0) \u2194 a \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {t : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X t \u2119 \u03bc) :\n    (fun x => pdf X \u2119 \u03bc x) \u207b\u00b9' {0}\u1d9c \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_piecewise_const {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] Set.piecewise s (fun _ => (\u03bc s)\u207b\u00b9) (fun _ => 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_equal_set {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hns : \u03bc s \u2260 0) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    (fun x => pdf X \u2119 \u03bc x) \u207b\u00b9' {0}\u1d9c = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_positive_set_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hns : \u03bc s \u2260 0) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | 0 < pdf X \u2119 \u03bc x} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem uniformOfFintype_apply_bounds {\u03b1 : Type*} [Fintype \u03b1] [Nonempty \u03b1] (a : \u03b1) :\n    0 < PMF.uniformOfFintype \u03b1 a \u2227 PMF.uniformOfFintype \u03b1 a < 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | pdf X \u2119 \u03bc x \u2260 0} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_equal_set_variant {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hns : \u03bc s \u2260 0) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | pdf X \u2119 \u03bc x \u2260 0} = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem uniformOfFintype_bounds {\u03b1 : Type*} [Fintype \u03b1] [Nonempty \u03b1] (a : \u03b1) :\n    0 < PMF.uniformOfFintype \u03b1 a \u2227 PMF.uniformOfFintype \u03b1 a \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_positive_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | 0 < pdf X \u2119 \u03bc x} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_positive_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | 0 < pdf X \u2119 \u03bc x} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_piecewise_const {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] fun x => (\u03bc s)\u207b\u00b9 * (s.indicator (fun _ => 1) x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem uniformOfFinset_apply_bounds {\u03b1 : Type*} {s : Finset \u03b1} (hs : s.Nonempty) (a : \u03b1) :\n    0 \u2264 PMF.uniformOfFinset s hs a \u2227 PMF.uniformOfFinset s hs a \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_positive_implies_mem {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    (fun x => 0 < pdf X \u2119 \u03bc x) \u207b\u00b9' {True} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem uniformOfFintype_bounds {\u03b1 : Type*} [Fintype \u03b1] [Nonempty \u03b1] (a : \u03b1) :\n    0 < PMF.uniformOfFintype \u03b1 a \u2227 PMF.uniformOfFintype \u03b1 a \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {t : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X t \u2119 \u03bc) :\n    {x | pdf X \u2119 \u03bc x \u2260 0} \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_positive_subset_eq {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hns : \u03bc s \u2260 0) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | 0 < pdf X \u2119 \u03bc x} = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {t : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X t \u2119 \u03bc) :\n    {x | pdf X \u2119 \u03bc x \u2260 0} \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem uniformOfFintype_bounds {\u03b1 : Type*} [Fintype \u03b1] [Nonempty \u03b1] (a : \u03b1) :\n    0 < PMF.uniformOfFintype \u03b1 a \u2227 PMF.uniformOfFintype \u03b1 a \u2264 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_positive_implies_mem {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    (fun x => 0 < pdf X \u2119 \u03bc x) \u207b\u00b9' {True} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_piecewise_const {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] Set.piecewise s (fun _ => (\u03bc s)\u207b\u00b9) (fun _ => 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_positive_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    {x | 0 < pdf X \u2119 \u03bc x} \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem ofMultiset_positive_implies_mem {\u03b1 : Type*} {s : Multiset \u03b1}\n    (hs : s \u2260 0) {a : \u03b1} :\n    0 < PMF.ofMultiset s hs a \u2192 a \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_indicator_toReal {\u03a9 : Type*} {E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    (fun x => (pdf X \u2119 \u03bc x).toReal) =\u1d50[\u03bc] fun x => if x \u2208 s then (\u03bc s)\u207b\u00b9.toReal else 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_pos_inside {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hns : \u03bc s \u2260 0) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    s \u2286 (fun x \u21a6 pdf X \u2119 \u03bc x) \u207b\u00b9' {0}\u1d9c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_support_subset {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {t : Set E}\n    (hU : MeasureTheory.pdf.IsUniform X t \u2119 \u03bc) :\n    {x | pdf X \u2119 \u03bc x \u2260 0} \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_indicator_toReal_eq {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    (fun x \u21a6 (pdf X \u2119 \u03bc x).toReal) =\u1d50[\u03bc] fun x \u21a6 (\u03bc s)\u207b\u00b9.toReal * s.indicator (fun _ \u21a6 1) x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {E : Type*} [MeasurableSpace E] {\u03bc : Measure E}\nvariable {\u03a9 : Type*}\nvariable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\nvariable {X : \u03a9 \u2192 \u211d} {s : Set \u211d}\nvariable {X : \u03a9 \u2192 E}\nvariable {\u03b1 : Type*}\nvariable {s : Finset \u03b1} (hs : s.Nonempty) {a : \u03b1}\nvariable (t : Set \u03b1)\nvariable [Fintype \u03b1] [Nonempty \u03b1]\nvariable (s : Set \u03b1)\nvariable {s : Multiset \u03b1} (hs : s \u2260 0)\n\nopen Classical MeasureTheory MeasureTheory.Measure NNReal scoped TopologicalSpace ENNReal in PMF\ntheorem pdf_eq_indicator_rev {\u03a9 E : Type*} [MeasurableSpace \u03a9] [MeasurableSpace E]\n    {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E} {s : Set E}\n    (hs : MeasurableSet s) (hU : MeasureTheory.pdf.IsUniform X s \u2119 \u03bc) :\n    pdf X \u2119 \u03bc =\u1d50[\u03bc] fun x => if x \u2209 s then 0 else (\u03bc s)\u207b\u00b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem mul_eq_self_succ {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 1) = c + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem one_add_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : 1 + a = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem add_eq_left_of_lt {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < a) : a + b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem mul_eq_left_of_lt {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < a) : a * b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem mk_vector_eq_mk (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 1 \u2264 n) : #(Vector \u03b1 n) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem mul_le_right_of_aleph0 {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a * b \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem add_le_right_of_aleph0 {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a + b \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem aleph_mul_eq_max' (o : Ordinal) {c : Cardinal} (h : \u2135\u2080 \u2264 c) : \u2135_ o * c = max (\u2135_ o) c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\n\ntheorem prod_le_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, 2 \u2264 c i) : prod c \u2264 2 ^ lift #\u03b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_two {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + (2 : Cardinal)) = c + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_right_of_lt' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (h : a < b) : a + b = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_right_of_lt' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (h : a < b) : a * b = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph0_mul_succ_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 * (a + 2) = a + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk' (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 2 \u2264 n) : #(Vector \u03b1 n) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_left_of_aleph0 {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : b * a \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_left_of_aleph0 {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : b + a \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_three_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (3 : Cardinal) \u2264 c i) : prod c \u2264 3 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq' {c : Cardinal} (h : \u2135\u2080 \u2264 c) {n : \u2115} (hn : 3 \u2264 n) : (n : Cardinal) ^ c = 3 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_self_of_aleph0 {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < \u2135\u2080) : a + b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_of_aleph0 {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < \u2135\u2080) : a * b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_aleph_reverse (o\u2081 o\u2082 : Ordinal) : \u2135_ (max o\u2081 o\u2082) = \u2135_ o\u2082 * \u2135_ o\u2081 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_aleph0_add_two_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : a * (\u2135\u2080 + 2) = \u2135\u2080 + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_three {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 3) = c + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph0_mul_succ_eq' {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 * (a + 3) = a + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_succ (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 0 < n) : #(Vector \u03b1 (n + 1)) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_right_of_aleph0' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a * (b + 1) \u2264 b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_right_of_aleph0' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a + (b + 1) \u2264 b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_four {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 4) = c + 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_right_of_lt'' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (h : a < b) : a + (b + 1) = b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_right_of_lt'' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (h : a < b) : a * (b + 1) = b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph0_mul_succ_two_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 * (a + 4) = a + 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_ge_two (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 2 \u2264 n) : #(Vector \u03b1 (n + 2)) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_left_of_aleph0' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : (b + 1) * a \u2264 b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_left_of_aleph0' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : (b + 1) + a \u2264 b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_four_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (4 : Cardinal) \u2264 c i) : prod c \u2264 4 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq'' {c : Cardinal} (h : \u2135\u2080 \u2264 c) {n : \u2115} (hn : 4 \u2264 n) : (n : Cardinal) ^ c = 4 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_self_of_aleph0' {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < \u2135\u2080) : (a + (b + 1)) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_succ_left_eq_self {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : (c + 1) * c = c + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_left_of_aleph0' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) : b * a \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_left_of_aleph0' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) : b + a \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_left (o : Ordinal) {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : c * \u2135_ o = max c (\u2135_ o) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_self_of_le_aleph0 {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 \u2135\u2080) : a + b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_of_le_aleph0 {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 \u2135\u2080) : a * b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_ge_two_succ (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 2 \u2264 n) : #(Vector \u03b1 (n + 1)) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_left_of_aleph0 {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : b * a \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_left_of_aleph0 {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : b + a \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_left (o : Ordinal) {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * \u2135_ o = max c (\u2135_ o) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_two {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 2) = c + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_three {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 3) = c + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_three_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, 3 \u2264 c i) : prod c \u2264 3 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_four {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 4) = c + 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_right_of_le {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 a) : a * b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_le_mk (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 1 \u2264 n) : #(Vector \u03b1 n) \u2264 #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_right_of_aleph0' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a * (b + 1) \u2264 b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_right_of_aleph0' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a + (b + 1) \u2264 b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_two (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 2) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_twice {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + c) = c + c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem one_add_le {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : 1 + a \u2264 a + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_left_of_aleph0'' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : b * a \u2264 max a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_left_of_aleph0'' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : b + a \u2264 b + b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_left' (o : Ordinal) {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * \u2135_ o = max (\u2135_ o) c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_with_aleph0_add {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : a * (\u2135\u2080 + 1) = \u2135\u2080 + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_three (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 3) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_self_of_aleph0 {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) : a + b \u2264 max a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_right (o : Ordinal) {c : Cardinal} (h : \u2135\u2080 \u2264 c) : \u2135_ o * c = max c (\u2135_ o) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_four (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 4) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_le_right_of_aleph0'' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a * b \u2264 b * 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_right_of_aleph0'' {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a + b \u2264 b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_succ_left_eq_self {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : (c + 1) + c = c + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_succ_self_eq {c : Cardinal} (h : \u2135\u2080 \u2264 c) : (c + 1) * (c + 1) = c + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem succ_mul_aleph0_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : (a + 2) * \u2135\u2080 = a + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_three_or_more (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 3 \u2264 n) : #(Vector \u03b1 n) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_right_of_aleph0_swap {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a + b \u2264 max a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_five_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (5 : Cardinal) \u2264 c i) : prod c \u2264 5 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq_five {c : Cardinal} (h : \u2135\u2080 \u2264 c) {n : \u2115} (hn : 5 \u2264 n) : (n : Cardinal) ^ c = 5 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_self (o : Ordinal) : \u2135_ o * \u2135_ o = \u2135_ o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_le_mk_three (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 3 \u2264 n) : #(Vector \u03b1 n) \u2264 #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_six_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (6 : Cardinal) \u2264 c i) : prod c \u2264 6 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_twice' {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (2 * c) = 2 * c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem one_add_le_succ {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : 1 + a \u2264 a + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph0_mul_succ_right_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 * (a + 1) = a + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_left' (o : Ordinal) {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : c * \u2135_ o = max c (\u2135_ o) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph0_mul_succ_eq' {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 * (a + 2) = a + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_self_of_le_aleph0 {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 \u2135\u2080) : a + b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_of_le_aleph0 {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 \u2135\u2080) : a * b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_succ_right_eq_self {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : c + (c + 1) = c + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_three_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, 3 \u2264 c i) : prod c \u2264 3 ^ lift #\u03b9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_max_of_lt {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < a) : a * b = max a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph0_mul_succ_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 * (1 + a) = a + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_five {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 5) = c + 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_two_alt {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (2 + c) = c + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq_six {c : Cardinal} (h : \u2135\u2080 \u2264 c) {n : \u2115} (hn : 6 \u2264 n) : (n : Cardinal) ^ c = 6 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_right_of_le {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (h : a \u2264 b) : a * b = max a b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_left' (o : Ordinal) {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * \u2135_ o = max c (\u2135_ o) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_three (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 3) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq_five {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : (5 : Cardinal) ^ c = 5 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq_six {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : (6 : Cardinal) ^ c = 6 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_aleph0_succ {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 + (a + 1) = a + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_five {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 5) = c + 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_five {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 5) = c + 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem two_add_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : 2 + a = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_left_of_succ_lt {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < a) : a + (b + 1) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_five (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 5) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_left' (o : Ordinal) {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * \u2135_ o = max c (\u2135_ o) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_five_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (5 : Cardinal) \u2264 c i) : prod c \u2264 5 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq_seven {c : Cardinal} (h : \u2135\u2080 \u2264 c) {n : \u2115} (hn : 7 \u2264 n) : (n : Cardinal) ^ c = 7 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_self_of_aleph0_le {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < \u2135\u2080) : a + (b + 2) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_of_aleph0_le {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < \u2135\u2080) : a * (b + 1) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_aleph0_add_three_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : a * (\u2135\u2080 + 3) = \u2135\u2080 + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem one_add_le_succ' {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : 1 + a \u2264 a + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_le_mk_four (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 4 \u2264 n) : #(Vector \u03b1 n) \u2264 #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_six_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (6 : Cardinal) \u2264 c i) : prod c \u2264 6 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_succ_left_eq_self' {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : (c + 2) + c = c + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_six {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 6) = c + 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_six (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 6) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem nat_power_eq_eight {c : Cardinal} (h : \u2135\u2080 \u2264 c) {n : \u2115} (hn : 8 \u2264 n) : (n : Cardinal) ^ c = 8 ^ c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_self_succ_eq {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (1 + c) = 1 + c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem succ_mul_self_eq {c : Cardinal} (h : \u2135\u2080 \u2264 c) : (1 + c) * c = 1 + c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_of_lt' {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b < a) : a * (b + 1) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem aleph_mul_eq_max_left {o : Ordinal} {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : c * \u2135_ o = max c (\u2135_ o) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_right_of_lt'' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (h : a < b) : a + (b + 1) = b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_right_of_lt'' {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (h : a < b) : a * (b + 1) = b + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_nat_eq_succ {a : Cardinal} {n : \u2115} (ha : \u2135\u2080 \u2264 a) (hn : 1 \u2264 n) : a + (n + 1) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_eq_self_of_countable {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 \u2135\u2080) : a + (b + 1) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_of_countable {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 \u2135\u2080) : a * (b + 1) = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_le_mk_five (\u03b1 : Type*) [Infinite \u03b1] {n : \u2115} (hn : 5 \u2264 n) : #(Vector \u03b1 n) \u2264 #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_seven_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (7 : Cardinal) \u2264 c i) : prod c \u2264 7 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_succ_left_eq_self'' {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : (c + 3) + c = c + 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_add_seven {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + 7) = c + 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_eq_self_twice_succ {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (c + c + 1) = c + c + 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_le_self_of_aleph0' {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) : a + b \u2264 max a (b + 1) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_seven (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 7) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mul_self_add_four' {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * (4 + c) = c + 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem add_aleph0_two {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 + (a + 2) = a + 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem prod_le_eight_power {\u03b9 : Type*} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal} (h : \u2200 i, (8 : Cardinal) \u2264 c i) : prod c \u2264 8 ^ lift (#\u03b9) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b9 : Type u} {\u03b9' : Type w} (f : \u03b9 \u2192 Cardinal.{v})\nvariable [Nonempty \u03b9] [Nonempty \u03b9']\nvariable {\u03b1 \u03b2 : Type u} {\u03b2' : Type v}\nvariable (\u03b1 \u03b2')\nvariable [Infinite \u03b1] {\u03b1 \u03b2'}\n\nopen Function Cardinal Order Ordinal Equiv Set\ntheorem mk_vector_eq_mk_eight (\u03b1 : Type*) [Infinite \u03b1] : #(Vector \u03b1 8) = #\u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\n\ntheorem add_lt_add_nat_right {a b : Ordinal} {n : \u2115} : a < b \u2192 a + n < b + n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\n\ntheorem add_eq_self_iff_right_eq_zero {a b : Ordinal} : a + b = a \u2194 b = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\n\ntheorem natCast_mul_comm (m n : \u2115) : ((m * n : \u2115) : Ordinal) = n * m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\n\ntheorem nat_lt_omega {n : \u2115} : (n : Ordinal) < \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\n\ntheorem omega_le_iff_nat_le {o : Ordinal} : \u03c9 \u2264 o \u2194 \u2200 n : \u2115, (n : Ordinal) \u2264 o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_eq_self_iff_left_eq_zero {a b : Ordinal} : a + b = b \u2194 a = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_assoc (l m n : \u2115) : (((l * m) * n : \u2115) : Ordinal) = l * (m * n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_lt_iff_nat_lt {o : Ordinal} : \u03c9 < o \u2194 \u2200 n : \u2115, (n : Ordinal) < o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_eq_self_iff_left_eq_zero_alt {a b : Ordinal} : a = b + a \u2194 b = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem nat_le_omega (n : \u2115) : (n : Ordinal) \u2264 \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_eq_self_iff_addend_eq_zero {a b : Ordinal} : a = a + b \u2194 b = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_assoc' (l m n : \u2115) : ((l * (m * n) : \u2115) : Ordinal) = (l * m) * n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_le_nat {n : \u2115} : \u00ac \u03c9 \u2264 (n : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_le_add_nat_right {a b : Ordinal} {n : \u2115} : a \u2264 b \u2192 a + n \u2264 b + n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_ne_zero_iff {a b : Ordinal} : a + b \u2260 0 \u2194 a \u2260 0 \u2228 b \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_lt_nat {n : \u2115} : \u00ac \u03c9 < (n : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_one_right (n : \u2115) : (1 : Ordinal) * n = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_positive : (0 : Ordinal) < \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_add_comm (m n : \u2115) : ((m + n : \u2115) : Ordinal) = (n : Ordinal) + m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_pow_two (n : \u2115) : ((n ^ 2 : \u2115) : Ordinal) = (n : Ordinal) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_eq_one : (\u03c9 : Ordinal) \u2260 1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_comm_left (m n : \u2115) : (m : Ordinal) * n = n * (m : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_le_iff_nat_succ_le {o : Ordinal} : \u03c9 \u2264 o \u2194 \u2200 n : \u2115, ((n.succ) : Ordinal) \u2264 o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_lt_iff_nat_succ_lt {o : Ordinal} : \u03c9 < o \u2194 \u2200 n : \u2115, ((n.succ) : Ordinal) < o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_eq_zero_imp_both_zero {a b : Ordinal} : a + b = 0 \u2192 a = 0 \u2227 b = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_comm_left (m n : \u2115) : (m : Ordinal) * n = n * (m : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_eq_self_iff_left_eq_zero {a b : Ordinal} : a + b = a \u2192 b = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_eq_self_iff_right_eq_zero_alt {a b : Ordinal} : a + b = b \u2192 a = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_eq_self_iff_addend_eq_zero_alt {a b : Ordinal} : a = b + a \u2192 b = 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_pow_two' (n : \u2115) : ((n ^ 2 : \u2115) : Ordinal) = (n : Ordinal) * n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_eq_zero : (\u03c9 : Ordinal) \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_le_iff_nat_le' {o : Ordinal} : (\u2200 n : \u2115, (n : Ordinal) \u2264 o) \u2192 \u03c9 \u2264 o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_lt_iff_nat_lt' {o : Ordinal} : (\u2200 n : \u2115, (n : Ordinal) < o) \u2192 \u03c9 < o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_ne_zero_iff' {a b : Ordinal} : a \u2260 0 \u2228 b \u2260 0 \u2192 a + b \u2260 0 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_left_right_comm' (l m n : \u2115) : ((l * m + n : \u2115) : Ordinal) = n + l * m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_add_natCast (n : \u2115) : \u03c9 + n = \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_eq_two : (\u03c9 : Ordinal) \u2260 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_add_omega_eq (n : \u2115) :\n    (n : Ordinal) + \u03c9 = \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_left_comm (l m n : \u2115) : ((l * (m * n) : \u2115) : Ordinal) = m * (l * n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_add_natCast_right (n : \u2115) : \u03c9 + (n : Ordinal) = \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_pow_two (n : \u2115) : ((n ^ 2 : \u2115) : Ordinal) = (n : Ordinal) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem nat_le_omega (n : \u2115) : (n : Ordinal) \u2264 \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_le_nat {n : \u2115} : \u00ac \u03c9 \u2264 (n : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_lt_nat {n : \u2115} : \u00ac \u03c9 < (n : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_assoc_left (l m n : \u2115) : ((l * (m * n) : \u2115) : Ordinal) = (l * m) * n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_comm_left (m n : \u2115) : (m : Ordinal) * n = n * (m : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_comm_natCast (m n : \u2115) : (m : Ordinal) + n = n + (m : Ordinal) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_add_natCast (n : \u2115) : \u03c9 + (n : Ordinal) = \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_assoc_right (l m n : \u2115) : ((l : Ordinal) * m) * n = l * (m * n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_pow_three (n : \u2115) : ((n ^ 3 : \u2115) : Ordinal) = (n : Ordinal) ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_not_eq_three : (\u03c9 : Ordinal) \u2260 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_le_of_nat_le' {o : Ordinal} : (\u2200 n : \u2115, (n : Ordinal) \u2264 o) \u2192 \u03c9 \u2264 o := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_add_assoc' (l m n : \u2115) : ((l : Ordinal) + m) + n = l + (m + n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem lt_omega_iff_exists_nat {o : Ordinal} : o < \u03c9 \u2194 \u2203 n : \u2115, o = n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_comm_three (l m n : \u2115) : ((l * m * n : \u2115) : Ordinal) = (n : Ordinal) * ((l : Ordinal) * m) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_lt_add_nat_both {a b : Ordinal} {n m : \u2115} : a < b \u2192 a + n < b + n + m := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_pow_two (m : \u2115) : ((m * m : \u2115) : Ordinal) = (m : Ordinal) ^ 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_lt_add_nat_right_iff {a b : Ordinal} {n : \u2115} :\n    a + n < b + n \u2194 a < b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_mul_left_comm (l m n : \u2115) :\n    ((l * m : \u2115) : Ordinal) * n = l * (m * n) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem omega_add_natCast (n : \u2115) :\n    \u03c9 + (n : Ordinal) = \u03c9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem add_le_add_nat_left_iff {a b : Ordinal} {n : \u2115} :\n    n + a \u2264 n + b \u2194 a \u2264 b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\nopen Classical Function Cardinal scoped in Order Ordinal Equiv Set\ntheorem natCast_pow_three (n : \u2115) :\n    ((n ^ 3 : \u2115) : Ordinal) = (n : Ordinal) ^ 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\n\ntheorem IsTransitive.insert (hx : x.IsTransitive) (hxy : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\n\ntheorem isTransitive_iff_transmem : z.IsTransitive \u2194 \u2200 {a b : ZFSet}, b \u2208 z \u2192 a \u2208 b \u2192 a \u2208 z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\n\ntheorem subset_iff_mem_or_eq (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x \u2286 y \u2194 x \u2208 y \u2228 x = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\n\ntheorem mem_total (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x \u2208 y \u2228 y \u2208 x \u2228 x = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\n\ntheorem isTransitive_iff_sUnion_eq : x.IsTransitive \u2194 (\u22c3\u2080 x : ZFSet) = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.union_left {x y : ZFSet} (hx : x.IsTransitive) : (x \u222a y).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isOrdinal_iff_isTotal (x : ZFSet) : x.IsOrdinal \u2194 x.IsTransitive \u2227 IsTotal _ (Subrel (\u00b7 \u2208 \u00b7) (\u00b7 \u2208 x)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem {x y : ZFSet} (hx : x.IsTransitive) (hyx : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem subset_iff_mem_or_eq' {x y : ZFSet} (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x \u2286 y \u2194 x \u2208 y \u2228 y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.inter_left {x y : ZFSet} (hx : x.IsTransitive) : (x \u2229 y).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.pair {x y : ZFSet} (hx : x.IsTransitive) (hy : y.IsTransitive) : ({x, y} : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.sInter {x : ZFSet} (hx : x.IsTransitive) : (\u22c2\u2080 x : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_insert {x y z : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem mem_total' (hx : x.IsOrdinal) (hy : y.IsOrdinal) : y \u2208 x \u2228 x \u2208 y \u2228 x = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.union_right {x y : ZFSet} (hy : y.IsTransitive) : (x \u222a y).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isOrdinal_iff_isTotal' (x : ZFSet) : x.IsOrdinal \u2194 IsTotal _ (Subrel (\u00b7 \u2208 \u00b7) (\u00b7 \u2208 x)) \u2227 x.IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_if_subset {x y : ZFSet} (h : x.IsTransitive) (hsub : y \u2286 x) : ({y} \u222a x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.inter_right {x y : ZFSet} (hy : y.IsTransitive) : (x \u2229 y).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_insert_swap {x y z : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_transitive (hx : x.IsTransitive) (hy : y.IsTransitive) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self (hx : x.IsTransitive) :\n    (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert (hx : x.IsTransitive) (hyx : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_subset_of_sUnion : x.IsTransitive \u2194 x \u2286 \u22c3\u2080 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsOrdinal.isTotal (hx : x.IsOrdinal) :\n    IsTotal _ (Subrel (\u00b7 \u2208 \u00b7) (\u00b7 \u2208 x)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) :\n    (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_pair_subset : z.IsTransitive \u2194 \u2200 a \u2208 z, insert a a \u2286 z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem_and_trans (hx : x.IsTransitive) (hy : y.IsTransitive) (hyx : y \u2208 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset_left {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_trans_and_subset {x y : ZFSet} (hx : x.IsTransitive) (hy : y.IsTransitive) (hsub : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_trans {x y : ZFSet} (hx : x.IsTransitive) (hsub : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_sUnion_subset_eq {x : ZFSet} :\n    x.IsTransitive \u2194 (\u22c3\u2080 x : ZFSet) \u2286 x \u2227 x \u2286 \u22c3\u2080 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_if_mem_trans {x y : ZFSet} (hx : x.IsTransitive) (hyx : y \u2208 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_trans {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) :\n    (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_swap_trans {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) :\n    (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self_trans {x : ZFSet} (hx : x.IsTransitive) :\n    (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert_trans {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) :\n    (insert y (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_insert_subset {x : ZFSet} :\n    x.IsTransitive \u2194 \u2200 y, insert y y \u2286 x \u2192 y \u2208 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_pair_subset {z : ZFSet} :\n    z.IsTransitive \u2194 \u2200 a \u2208 z, {a} \u2286 z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset' (hx : x.IsTransitive) (hsub : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_mem {x y : ZFSet} (hx : x.IsTransitive) (hy : y \u2208 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem subset_iff_mem_or_eq_left' {x y : ZFSet} (hx : x.IsOrdinal) (hy : y.IsOrdinal) :\n    x \u2286 y \u2194 y \u2208 x \u2228 x = y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_left {x y z : ZFSet} (hx : x.IsTransitive)\n    (hyx : y \u2286 x) (hzx : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_insert_comm {x y z : ZFSet} (hx : x.IsTransitive)\n    (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_both_transitive {x y : ZFSet}\n    (hx : x.IsTransitive) (hy : y.IsTransitive) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_id {x : ZFSet} (hx : x.IsTransitive) :\n    (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_duplicate {x y : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem_and_trans' {x y : ZFSet} (hx : x.IsTransitive)\n    (hy : y.IsTransitive) (hmem : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset_left' {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_trans_and_subset' {x y : ZFSet} (hx : x.IsTransitive)\n    (hy : y.IsTransitive) (hsub : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_trans' {x y : ZFSet} (hx : x.IsTransitive)\n    (hsub : y \u2286 x) : (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_if_mem_trans' {x y : ZFSet} (hx : x.IsTransitive) (hmem : y \u2208 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_trans' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_swap_trans' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self_trans' {x : ZFSet} (hx : x.IsTransitive) :\n    (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert_trans' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_subset {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_two {x y z : ZFSet} (hx : x.IsTransitive)\n    (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_insert_flip {x y z : ZFSet} (hx : x.IsTransitive)\n    (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_both {x y : ZFSet} (hx : x.IsTransitive)\n    (hy : y.IsTransitive) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self' {x : ZFSet} (hx : x.IsTransitive) :\n    (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert' {x y : ZFSet} (hx : x.IsTransitive)\n    (hyx : y \u2286 x) : (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem_trans' {x y : ZFSet} (hx : x.IsTransitive)\n    (hyx : y \u2208 x) (hy : y.IsTransitive) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_subset_alt {x y : ZFSet} (hx : x.IsTransitive) (hsub : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self_alt {x : ZFSet} (hx : x.IsTransitive) : (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_subset_left {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_mem_of_member {z : ZFSet} : z.IsTransitive \u2194 \u2200 {a b : ZFSet}, a \u2208 z \u2192 b \u2208 a \u2192 b \u2208 z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_left_variant {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) : (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self_variant {x : ZFSet} (hx : x.IsTransitive) : (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_variant {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert_variant {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem_variant {x y : ZFSet} (hx : x.IsTransitive) (hy : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_two_variant {x y z : ZFSet} (hx : x.IsTransitive) (hyx : y \u2286 x) (hzx : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_duplicate_variant {x y : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) : (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset_right {x y : ZFSet} (hxy : y \u2286 x) (hx : x.IsTransitive) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_memTrans {z : ZFSet} : z.IsTransitive \u2194 \u2200 {b a : ZFSet}, a \u2208 b \u2192 b \u2208 z \u2192 a \u2208 z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_mem_alt {x y : ZFSet} (hyx : y \u2208 x) (hx : x.IsTransitive) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem subset_iff_mem_or_eq_swap {x y : ZFSet} (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x \u2286 y \u2194 y = x \u2228 x \u2208 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_comm {x y z : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) (hzx : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_alt {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_pair_subset_alt {z : ZFSet} : z.IsTransitive \u2194 \u2200 a, a \u2208 z \u2192 {a, a} \u2286 z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_and_mem (hx : x.IsTransitive) (hy : y.IsTransitive) (hyx : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_duplicate_alt {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) : (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self_alt2 {x : ZFSet} (hx : x.IsTransitive) : (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert_alt {x y z : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) (hzx : z \u2286 x) : (insert y (insert y (insert z x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset_alt2 {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem subset_iff_mem_or_eq_left_alt {x y : ZFSet} (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x \u2286 y \u2194 y \u2208 x \u2228 y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_left_alt {x y z : ZFSet} (hx : x.IsTransitive) (hyx : y \u2286 x) (hzx : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_trans_and_subset_alt {x y : ZFSet} (hx : x.IsTransitive) (hy : y.IsTransitive) (hsub : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self_trans_alt {x : ZFSet} (hx : x.IsTransitive) : (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert_symm {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) : (insert z (insert y (insert z x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem_trans_alt {x y : ZFSet} (hx : x.IsTransitive) (hyx : y \u2208 x) (hy : y.IsTransitive) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_variant2 {x y z : ZFSet} (hx : x.IsTransitive) (hz : z \u2286 x) (hy : y \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_mem_member {z : ZFSet} : z.IsTransitive \u2194 \u2200 {a b : ZFSet}, b \u2208 a \u2192 a \u2208 z \u2192 b \u2208 z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset_left_alt {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem'' {x y : ZFSet} (hx : x.IsTransitive) (hyx : y \u2208 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self' {x : ZFSet} (hx : x.IsTransitive) :\n    (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert'' {x y : ZFSet} (hx : x.IsTransitive) (hyx : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm'' {x y z : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) :\n    (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert'' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hxy : y \u2286 x) (hzx : z \u2286 x) : (insert y (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_two' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hxy : y \u2286 x) (hzx : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_swap' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_duplicate'' {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_id' {x : ZFSet} (hx : x.IsTransitive) :\n    (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_and_mem' {x y : ZFSet} (hx : x.IsTransitive) (hy : y.IsTransitive) (hyx : y \u2208 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert_variant' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset_alt3 {x y : ZFSet} (hx : x.IsTransitive) (hsub : y \u2286 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_left' {x y z : ZFSet} (hx : x.IsTransitive)\n    (hyx : y \u2286 x) (hzx : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_swap_comm {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_duplicate_alt' {x y : ZFSet} (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.triple_insert_symm {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert z (insert y (insert z x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_both' {x y : ZFSet} (hx : x.IsTransitive) (hy : y.IsTransitive) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_trans'' {x y : ZFSet} (hx : x.IsTransitive) (hsub : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_variant {x y z : ZFSet} (hx : x.IsTransitive)\n    (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_left (hx : x.IsTransitive) (hxy : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_mem' {x y : ZFSet} (hx : x.IsTransitive) (hyx : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_insert_right {x y z : ZFSet} (hx : x.IsTransitive) (hzx : z \u2286 x) (hxy : y \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.pair_left (hx : x.IsTransitive) : ({x, y} : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.sUnion_of_subset (hx : x.IsTransitive) (hxy : y \u2286 x) : (\u22c3\u2080 y : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.sInter_of_subset (hx : x.IsTransitive) (hxy : y \u2286 x) : (\u22c2\u2080 y : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_pair (hx : x.IsTransitive) (hyx : y \u2286 x) : (insert y (insert x x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_subset_of_union : x.IsTransitive \u2194 x \u2286 x \u222a \u22c3\u2080 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_three (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert y (insert z (insert x x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsOrdinal.subset_or_mem (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x \u2286 y \u2228 x \u2208 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsOrdinal.mem_or_subset (hx : x.IsOrdinal) (hy : y.IsOrdinal) : y \u2208 x \u2228 y \u2286 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsOrdinal.mem_total_alt (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x \u2208 y \u2228 y \u2208 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.singleton (hx : x.IsTransitive) : ({x} : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_four (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) (hwx : w \u2286 x) :\n    (insert w (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_mem_left (hx : x.IsTransitive) (hy : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_mem_right {x y : ZFSet} (hx : x.IsTransitive) (hyx : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_twice (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_of_subset_left {x y : ZFSet} (hx : x.IsTransitive) (hsub : y \u2286 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_swap {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) : (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_transitive (hx : x.IsTransitive) (hy : y.IsTransitive) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_self_alt (hx : x.IsTransitive) : (insert x x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.double_insert_alt (hx : x.IsTransitive) (hxy : y \u2286 x) : (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_alt {x y z : ZFSet} (hx : x.IsTransitive) (hy : y \u2286 x) (hz : z \u2286 x) : (insert z (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_mem_and_trans {x y : ZFSet} (hx : x.IsTransitive) (hy : y.IsTransitive) (hmem : y \u2208 x) : (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.pair_left (hx : x.IsTransitive) : ({x, y} : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.swap_insert (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert x y).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_subset_mem (hx : x.IsTransitive) (hsub : y \u2286 x) (hmem : z \u2208 x) :\n    (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_comm_two (hx : x.IsTransitive) (hxy : y \u2286 x) (hyz : z \u2286 x) :\n    (insert y (insert z x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem isTransitive_iff_sUnion_superset : x.IsTransitive \u2194 x \u2286 \u22c3\u2080 x \u2227 (\u22c3\u2080 x : ZFSet).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsOrdinal.mem_or_eq_or_subset (hx : x.IsOrdinal) (hy : y.IsOrdinal) :\n    x \u2208 y \u2228 x = y \u2228 y \u2286 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsOrdinal.eq_or_mem_or_subset (hx : x.IsOrdinal) (hy : y.IsOrdinal) :\n    x = y \u2228 x \u2208 y \u2228 y \u2286 x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_triple (hx : x.IsTransitive) (hxy : y \u2286 x) (hxz : z \u2286 x) :\n    (insert y (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.big_insert (hx : x.IsTransitive) (hxy : y \u2286 x) (hzx : z \u2286 x) (hwx : w \u2286 x) :\n    (insert w (insert z (insert y x))).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_and_union (hx : x.IsTransitive) (hy : y.IsTransitive) :\n    (insert y (x \u222a y)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsOrdinal.total_or_subset (hx : x.IsOrdinal) (hy : y.IsOrdinal) :\n    IsTotal _ (Subrel (\u00b7 \u2208 \u00b7) (\u00b7 \u2208 x \u222a y)) \u2228 x \u2286 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_if_mem (hx : x.IsTransitive) (hyx : y \u2208 x) :\n    (insert y x).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_pair_swap (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert x (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {x y z w : ZFSet.{u}}\n\n\ntheorem IsTransitive.insert_duplicate_mem (hx : x.IsTransitive) (hxy : y \u2286 x) :\n    (insert y (insert y x)).IsTransitive := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem Metric.complete_of_convergent_decay_sequences (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N) \u2192\n      \u2203 x, Tendsto u atTop (\ud835\udcdd x)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem Metric.cauchySeq_iff_le {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, \u2200 m \u2265 N, dist (u n) (u m) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem Metric.cauchySeq_iff_with_fixed_index {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u n) (u N) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem Metric.uniformCauchySeqOn_iff_le {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 n \u2265 N, \u2200 m \u2265 N, \u2200 x \u2208 s, dist (F n x) (F m x) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem cauchySeq_of_lt_tendsto_0' {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m : \u03b2, n \u2264 m \u2192 dist (s n) (s m) < b n) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem cauchySeq_of_le_tendsto_0_next {s : \u2115 \u2192 \u03b1} (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m N : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) \u2264 b (N + 1)) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem cauchySeq_bounded' {u : \u2115 \u2192 \u03b1} (hu : CauchySeq u) :\n    \u2203 R : \u211d, 0 < R \u2227 \u2200 n, dist (u n) (u 0) < R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem cauchySeq_iff_nonneg_bound_tendsto_0 {s : \u2115 \u2192 \u03b1} :\n    CauchySeq s \u2194 \u2203 b : \u2115 \u2192 \u211d, (\u2200 n, 0 \u2264 b n) \u2227\n      (\u2200 n m N : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) < b N) \u2227 Tendsto b atTop (\ud835\udcdd 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\n\ntheorem Metric.exists_subseq_dist_lt_of_cauchySeq (u : \u2115 \u2192 \u03b1) (hu : CauchySeq u) (b : \u2115 \u2192 \u211d)\n    (hb : \u2200 n, 0 < b n) :\n    \u2203 f : \u2115 \u2192 \u2115, StrictMono f \u2227 \u2200 n, \u2200 m \u2265 f n, dist (u m) (u (f n)) \u2264 b n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_small' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 dist (u n) (u m) < \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_fixed_point {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) < \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_le_dist {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 dist (u n) (u m) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_bounded_around_zero {u : \u2115 \u2192 \u03b1} (hu : CauchySeq u) :\n    \u2203 R, 0 < R \u2227 \u2200 n, dist (u n) (u 0) \u2264 R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_single_limit {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u n) (u N) < \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 \u2200 x \u2208 s, dist (F n x) (F m x) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_iff_nonneg_tendsto_0 {s : \u2115 \u2192 \u03b1} :\n    CauchySeq s \u2194 \u2203 b : \u2115 \u2192 \u211d, (\u2200 n, 0 \u2264 b n) \u2227\n      (\u2200 n m, dist (s n) (s m) \u2264 b (min n m)) \u2227 Tendsto b atTop (\ud835\udcdd 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_with_base_index {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_le {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 \u2200 x \u2208 s, dist (F n x) (F m x) < \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_lt_tendsto_0'' {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s m) (s n) < b m) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_le_tendsto_0_succ {s : \u2115 \u2192 \u03b1} (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m N, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) < b (N + 2)) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_iff_bound_tendsto_zero {s : \u2115 \u2192 \u03b1} :\n    CauchySeq s \u2194\n      \u2203 b : \u2115 \u2192 \u211d, (\u2200 n, 0 \u2264 b n) \u2227 (\u2200 n m, dist (s n) (s m) < b (min n m)) \u2227\n        Tendsto b atTop (\ud835\udcdd 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_tiny {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 dist (u n) (u m) < \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_anchor_point {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_strongly_controlled_sequences\n    (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) < B (N) / 2) \u2192\n      \u2203 x, Tendsto u atTop (\ud835\udcdd x)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_cauchySeq_has_limit\n    (h : \u2200 u : \u2115 \u2192 \u03b1, CauchySeq u \u2192 \u2203! a, Tendsto u atTop (\ud835\udcdd a)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff'' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) < \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_le {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m \u2265 N, \u2200 n \u2265 N, \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_lt_tendsto_0'' {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) < b (m)) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_le_tendsto_0_next' {s : \u2115 \u2192 \u03b1} (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m N, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) \u2264 b (N + 2)) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_bounded'' {u : \u2115 \u2192 \u03b1} (hu : CauchySeq u) :\n    \u2203 R : \u211d, 0 < R \u2227 \u2200 n, dist (u n) (u 1) < R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_small'' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 dist (u n) (u m) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_fixed_point' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_le_dist' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 dist (u n) (u m) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_le' {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 \u2200 x \u2208 s, dist (F n x) (F m x) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_lt_tendsto_0''' {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s m) (s n) < b n) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_le_tendsto_0_succ' {s : \u2115 \u2192 \u03b1} (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m N, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) \u2264 b (N + 3)) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_tiny' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n m, n \u2265 N \u2192 m \u2265 N \u2192 dist (u n) (u m) < \u03b5 / 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_anchor_point' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_eventually_small {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, N \u2264 m \u2192 N \u2264 n \u2192 dist (u m) (u n) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_with_anchor {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_iff_exists_nonneg_bound {\u03b1 : Type*} [PseudoMetricSpace \u03b1]\n    {s : \u2115 \u2192 \u03b1} :\n    CauchySeq s \u2194 \u2203 b : \u2115 \u2192 \u211d,\n      (\u2200 n, 0 \u2264 b n) \u2227 (\u2200 n m, dist (s n) (s m) \u2264 b (max n m)) \u2227 Tendsto b atTop (\ud835\udcdd 0) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_halved {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, N \u2264 m \u2192 N \u2264 n \u2192 dist (u m) (u n) < \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_single_anchor {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) < \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_strongly_controlled_sequences {\u03b1 : Type u} [PseudoMetricSpace \u03b1]\n    (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 3) \u2192\n      \u2203 a, Tendsto u atTop (\ud835\udcdd a)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_quarter_bound {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_controlled_succ {\u03b1 : Type*} [PseudoMetricSpace \u03b1]\n    {s : \u2115 \u2192 \u03b1} (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) < b (n.succ))\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_bound_from_base {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_bounded_about_point {\u03b1 : Type*} [PseudoMetricSpace \u03b1]\n    {u : \u2115 \u2192 \u03b1} (hu : CauchySeq u) (k : \u2115) :\n    \u2203 R > 0, \u2200 n, dist (u n) (u k) < R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_lt {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, N \u2264 m \u2192 N \u2264 n \u2192 dist (u m) (u n) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_le' {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_lt_tendsto_zero {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1]\n    {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) < b m)\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_single_anchor' {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u n) (u N) < \u03b5 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_le_dist'' {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_lt {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_quarter_sequences {\u03b1 : Type u}\n    [PseudoMetricSpace \u03b1] (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 4) \u2192\n        \u2203 l, Tendsto u atTop (\ud835\udcdd l)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventual_small {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) < \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_anchor_le {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_controlled_pred {s : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b (n.pred))\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_bounded_about_index {u : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (hu : CauchySeq u) (k : \u2115) :\n    \u2203 R > 0, \u2200 n, dist (u n) (u k) \u2264 R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_tiny {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_ge_tendsto_zero {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {s : \u03b2 \u2192 \u03b1}\n    (b : \u03b2 \u2192 \u211d) (h : \u2200 n m, m \u2265 n \u2192 dist (s n) (s m) < b n)\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.exists_subseq_dist_strict_lt {u : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (hu : CauchySeq u) : \u2203 f : \u2115 \u2192 \u2115, StrictMono f \u2227\n      \u2200 n m, m \u2265 f n \u2192 dist (u m) (u (f n)) \u2264 (1 : \u211d) / (n.succ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eighth_bound {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) < \u03b5 / 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_bounded_global {u : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (hu : CauchySeq u) : \u2203 R : \u211d, 0 < R \u2227 \u2200 m n, dist (u m) (u n) \u2264 R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventually_half {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 (\u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_eventual {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 (\u2200 \u03b5 > 0,\n      (\u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_controlled_ge {s : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b (m))\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_third_bound {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) < \u03b5 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_eighth_sequences {\u03b1 : Type u}\n    [PseudoMetricSpace \u03b1] (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 8) \u2192\n        \u2203 a, Tendsto u atTop (\ud835\udcdd a)) : CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_smallest {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 (\u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 8) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_half {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventual_quarter {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 (\u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_anchor_eventual {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 (\u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 4) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_sixth_sequences {\u03b1 : Type u} [PseudoMetricSpace \u03b1]\n    (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 6) \u2192\n        \u2203 l, Tendsto u atTop (\ud835\udcdd l)) : CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_controlled_succ' {s : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b (n.succ.succ))\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_third {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_lt_tendsto_zero {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s m) (s n) < b m)\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_controlled_gap {s : \u2115 \u2192 \u03b1} (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b (n.succ))\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_ge_tendsto_zero (s : \u03b2 \u2192 \u03b1) (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b n)\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_sixth_sequences (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N m n, N \u2264 m \u2192 N \u2264 n \u2192 dist (u m) (u n) \u2264 B N / 6) \u2192 \u2203 a, Tendsto u atTop (\ud835\udcdd a)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_quarter {\u03b2 \u03b3 \u03b1 : Type*}\n    [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1]\n    {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_le_tendsto_zero {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1]\n    {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b n)\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_half' {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1]\n    {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 n \u2265 N, \u2200 m \u2265 N, \u2200 x \u2208 s, dist (F n x) (F m x) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventual_small' {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1]\n    {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_fast_sequences {\u03b1 : Type*} [PseudoMetricSpace \u03b1]\n    (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n        (\u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 2) \u2192\n          \u2203 x, Tendsto u atTop (\ud835\udcdd x)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_le_tendsto_zero {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1]\n    {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b n) (hb : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_single_anchor'' {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) < \u03b5 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_quarter {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) < \u03b5 / 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_quarter {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 / 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_controlled_le {s : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1] (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m, n \u2264 m \u2192 dist (s n) (s m) \u2264 b (min n m))\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_bounded_from_index {u : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (hu : CauchySeq u) : \u2203 R > 0, \u2200 n, dist (u n) (u n.succ) \u2264 R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_eighth {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_tenth {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) < \u03b5 / 10 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_le_half {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, \u2200 m \u2265 N, dist (u n) (u m) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_with_anchor_le {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_small_half {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m \u2265 N, \u2200 n \u2265 N, dist (u m) (u n) < \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventually_small_half {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_eighth {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventual_third {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 (\u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 3) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_sixth {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 / 6 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.exists_subseq_dist_halved_of_cauchySeq (u : \u2115 \u2192 \u03b1) (hu : CauchySeq u) :\n    \u2203 f : \u2115 \u2192 \u2115, StrictMono f \u2227\n      \u2200 n m, m \u2265 f n \u2192 dist (u m) (u (f n)) \u2264 (1 : \u211d) / 2^(n.succ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_tenth {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 10 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_anchor_point_le {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 4 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_power_sequences (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 (B N) ^ 2) \u2192\n        \u2203 z, Tendsto u atTop (\ud835\udcdd z)) : CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_fifth {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) < \u03b5 / 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_fifth {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 / 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_quint_sequences {\u03b1 : Type u} [PseudoMetricSpace \u03b1]\n    (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 5) \u2192\n      \u2203 l, Tendsto u atTop (\ud835\udcdd l)) : CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem cauchySeq_of_le_tendsto_0_quad {s : \u2115 \u2192 \u03b1} [PseudoMetricSpace \u03b1]\n    (b : \u2115 \u2192 \u211d)\n    (h : \u2200 n m N, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) \u2264 b (N + 4))\n    (hb : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.exists_subseq_dist_le_inv_succ_sq (u : \u2115 \u2192 \u03b1) [PseudoMetricSpace \u03b1]\n    (hu : CauchySeq u) : \u2203 f : \u2115 \u2192 \u2115, StrictMono f \u2227\n      \u2200 n m, m \u2265 f n \u2192 dist (u m) (u (f n)) \u2264 (1 : \u211d) / (n.succ)^2 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventual_small_fifth {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 (\u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 5) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_le_three {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, \u2200 m \u2265 N, dist (u n) (u m) \u2264 \u03b5 / 3 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_twelvth {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2]\n    [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 12 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_le_fifth {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 5 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_eventually_tenth {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 (\u2200 \u03b5 > 0, \u2200\u1da0 N in atTop, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 10) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_bounded_from_two_indices {\u03b1 : Type*} [PseudoMetricSpace \u03b1] {u : \u2115 \u2192 \u03b1} (hu : CauchySeq u) :\n    \u2203 R > 0, \u2200 n, dist (u n) (u (2 * n)) \u2264 R := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_twelfth {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 / 12 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_seventh {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) < \u03b5 / 7 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_tenth_sequences {\u03b1 : Type u} [PseudoMetricSpace \u03b1] (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 10) \u2192\n        \u2203 a, Tendsto u atTop (\ud835\udcdd a)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_twentieth {\u03b2 \u03b3 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1] {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 20 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_with_anchor_eighth {\u03b2 \u03b1 : Type*} [SemilatticeSup \u03b2] [PseudoMetricSpace \u03b1] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.exists_subseq_dist_le_geom (u : \u2115 \u2192 \u03b1) (hu : CauchySeq u) :\n    \u2203 f : \u2115 \u2192 \u2115, StrictMono f \u2227 \u2200 n m, m \u2265 f n \u2192 dist (u m) (u (f n)) \u2264 (1 : \u211d) / 2 ^ n := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_cube_sequences (B : \u2115 \u2192 \u211d)\n    (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 (B N) ^ 3) \u2192\n        \u2203 l, Tendsto u atTop (\ud835\udcdd l)) : CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_with_anchor_eighth {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u N) (u n) \u2264 \u03b5 / 8 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_quarter_decay (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) < B N / 4) \u2192\n        \u2203 z, Tendsto u atTop (\ud835\udcdd z)) : CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_twelfth {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 12 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.complete_of_convergent_exponential_sequences\n    (B : \u2115 \u2192 \u211d) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1,\n      (\u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) \u2264 B N / 2 ^ N) \u2192\n        \u2203 l, Tendsto u atTop (\ud835\udcdd l)) :\n    CompleteSpace \u03b1 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_sixteenth {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0,\n      \u2203 N : \u03b2, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) \u2264 \u03b5 / 16 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.cauchySeq_iff_dist_ninth {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 dist (u m) (u n) \u2264 \u03b5 / 9 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {X \u03b9 : Type*}\nvariable [PseudoMetricSpace \u03b1]\nvariable [Nonempty \u03b2] [SemilatticeSup \u03b2]\n\nopen Filter Topology scoped Uniformity\ntheorem Metric.uniformCauchySeqOn_iff_dist_twentyfourth {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > 0, \u2203 N : \u03b2,\n      \u2200 m n, m \u2265 N \u2192 n \u2265 N \u2192 \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5 / 24 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\n\ntheorem open_xor_mem_of_ne [T0Space X] {x y : X} (h : x \u2260 y) :\n    \u2203 U : Set X, IsOpen U \u2227 (x \u2208 U) \u2260 (y \u2208 U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\n\ntheorem specializationOrder_isAntisymm (X) [TopologicalSpace X] [T0Space X] :\n    Antisymm (specializationOrder X).le := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\n\ntheorem isOpen_compl_singleton_iff [T1Space X] {x : X} :\n    IsOpen ({x}\u1d9c : Set X) \u2194 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_open_mem_not_mem_of_ne [T0Space X] {x y : X} (h : x \u2260 y) : \u2203 U : Set X, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem specializationOrder_is_transitive (X) [TopologicalSpace X] [T0Space X] : Transitive (specializationOrder X).le := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_open_singleton_of_fintype [T0Space X] [Fintype X] : \u2203 x : X, IsOpen ({x} : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_open_mem_symm_diff_of_ne [T0Space X] {x y : X} (h : x \u2260 y) :\n    \u2203 U : Set X, IsOpen U \u2227 (x \u2208 U) \u2227 (y \u2209 U) \u2228 (y \u2208 U) \u2227 (x \u2209 U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem isClosed_singleton_iff [T1Space X] {x : X} : IsClosed ({x} : Set X) \u2194 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem inseparable_eq_singleton_inter [T0Space X] {x y : X} :\n    Inseparable x y \u2194 closure ({x} : Set X) \u2229 closure ({y} : Set X) \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_open_mem_diff_of_ne {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (hxy : x \u2260 y) : \u2203 U : Set X, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_iff_eq_of_t0 {X : Type*} [TopologicalSpace X] [T0Space X] {a b : X} :\n    (\ud835\udcdd a \u2264 \ud835\udcdd b) \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_isClosed_mem_not_mem_of_ne {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (h : x \u2260 y) : \u2203 C : Set X, IsClosed C \u2227 x \u2208 C \u2227 y \u2209 C := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem isClosed_singleton_iff_true {X : Type*} [TopologicalSpace X] [T1Space X] {x : X} :\n    IsClosed ({x} : Set X) \u2194 True := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_isOpen_superset_and_not_mem_of_ne {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (h : x \u2260 y) : \u2203 U : Set X, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 closure U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem specializationOrder_preorder (X : Type*) [TopologicalSpace X] [T0Space X] :\n    Reflexive (specializationOrder X).le \u2227 Transitive (specializationOrder X).le := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem eq_of_le_nhds_of_t0 {X : Type*} [TopologicalSpace X] [T0Space X] {a b : X}\n    (h : \ud835\udcdd a \u2264 \ud835\udcdd b) : a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_open_partition_of_two_points_ne {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (h : x \u2260 y) : \u2203 U V : Set X, IsOpen U \u2227 IsOpen V \u2227 x \u2208 U \u2227 y \u2208 V \u2227 Disjoint U V := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem inseparable_iff_closure_inter_ne_empty {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} : Inseparable x y \u2194 closure ({x} : Set X) \u2229 closure ({y} : Set X) \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_isOpen_singleton_of_fintype' {X : Type*} [TopologicalSpace X] [T0Space X]\n    [Fintype X] : \u2203 x : X, IsOpen ({x} : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_isClosed_mem_diff_of_ne {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (h : x \u2260 y) : \u2203 C : Set X, IsClosed C \u2227 x \u2208 C \u2227 y \u2209 C := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem not_specializes_iff_ne_of_t1' {X : Type*} [TopologicalSpace X] [T1Space X] {x y : X} :\n    (\u00ac x \u2933 y) \u2194 x \u2260 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem specializationOrder_isAntisymm_alt (X) [TopologicalSpace X] [T0Space X] :\n    AntiSymmetric (specializationOrder X).le := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_imp_eq_of_t0_alt [T0Space X] {a b : X} :\n    \ud835\udcdd a \u2264 \ud835\udcdd b \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_iff_eq_of_t0_alt {X : Type*} [TopologicalSpace X] [T0Space X] {a b : X} :\n    \ud835\udcdd a \u2264 \ud835\udcdd b \u2194 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_open_partition_of_two_points_ne_alt {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (h : x \u2260 y) : \u2203 U V : Set X, IsOpen U \u2227 IsOpen V \u2227 x \u2208 V \u2227 y \u2208 U \u2227 Disjoint U V := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem inseparable_iff_closure_inter_nonempty_alt {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} : Inseparable x y \u2194 (closure ({x} : Set X) \u2229 closure ({y} : Set X)).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem eq_of_le_nhds_of_t0_alt {X : Type*} [TopologicalSpace X] [T0Space X] {a b : X}\n    (h : \ud835\udcdd a \u2264 \ud835\udcdd b) : a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_open_partition_swapped_of_ne_alt {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (h : x \u2260 y) : \u2203 U V : Set X, IsOpen U \u2227 IsOpen V \u2227 x \u2208 U \u2227 y \u2208 V \u2227 Disjoint V U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_isOpen_mem_not_mem_closure_of_ne_alt {X : Type*} [TopologicalSpace X] [T0Space X]\n    {x y : X} (h : x \u2260 y) : \u2203 U : Set X, IsOpen U \u2227 y \u2208 U\u1d9c \u2227 x \u2208 closure U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_inclusion_eq_of_t0 [T0Space X] {a b : X} :\n    \ud835\udcdd a \u2264 \ud835\udcdd b \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_imp_eq [T0Space X] {a b : X} (h : \ud835\udcdd a \u2264 \ud835\udcdd b) (h' : \ud835\udcdd b \u2264 \ud835\udcdd a) : a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_imp_eq_of_t0 {\u03b1 : Type*} [TopologicalSpace \u03b1] [T0Space \u03b1] {a b : \u03b1} :\n    \ud835\udcdd a \u2264 \ud835\udcdd b \u2192 \ud835\udcdd b \u2264 \ud835\udcdd a \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_eq_of_t0 {\u03b1 : Type*} [TopologicalSpace \u03b1] [T0Space \u03b1] {a b : \u03b1} :\n    (\ud835\udcdd a \u2264 \ud835\udcdd b) \u2192 (\ud835\udcdd b \u2264 \ud835\udcdd a) \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_antisymm_eq_t0 [T0Space X] {a b : X} (h1 : \ud835\udcdd a \u2264 \ud835\udcdd b) (h2 : \ud835\udcdd b \u2264 \ud835\udcdd a) : a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_imp_eq_t0' [T0Space X] {a b : X} (h : \ud835\udcdd a \u2264 \ud835\udcdd b) (h' : \ud835\udcdd b \u2264 \ud835\udcdd a) : a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_iff_eq_of_t0 [T0Space X] {a b : X} :\n    \ud835\udcdd a \u2264 \ud835\udcdd b \u2194 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_imp_eq_of_t0' [T0Space X] {a b : X} :\n    (\ud835\udcdd a \u2264 \ud835\udcdd b) \u2192 (\ud835\udcdd b \u2264 \ud835\udcdd a) \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem eq_of_le_nhds_of_t0_alt' [T0Space X] {a b : X} :\n    \ud835\udcdd a \u2264 \ud835\udcdd b \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_iff_eq_of_t0_left [T0Space X] {a b : X} :\n    (\ud835\udcdd b \u2264 \ud835\udcdd a) \u2192 b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem disjoint_pure_nhds_iff_ne_of_t1 [T1Space X] {x y : X} :\n    Disjoint (pure x) (\ud835\udcdd y) \u2194 x \u2260 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem disjoint_nhds_pure_iff_ne_of_t1 [T1Space X] {x y : X} :\n    Disjoint (\ud835\udcdd x) (pure y) \u2194 x \u2260 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem open_singleton_of_finite_t0 [T0Space X] [Finite X] :\n    \u2203 x : X, IsOpen ({x} : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem closed_singleton_of_finite_t1 [T1Space X] [Finite X] :\n    \u2203 x : X, IsClosed ({x} : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_and_ge_iff_eq_of_t0 [T0Space X] {a b : X} :\n    (\ud835\udcdd a \u2264 \ud835\udcdd b) \u2227 (\ud835\udcdd b \u2264 \ud835\udcdd a) \u2194 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem eq_of_le_nhds_t0_left [T0Space X] {a b : X} (h : \ud835\udcdd b \u2264 \ud835\udcdd a) :\n    b = a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_closed_subset_of_ne_t0 [T0Space X] {x y : X} (h : x \u2260 y) :\n    \u2203 C : Set X, IsClosed C \u2227 x \u2208 C \u2227 y \u2209 closure C := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem open_subset_exists_of_ne [T0Space X] {x y : X} (h : x \u2260 y) :\n    \u2203 U : Set X, IsOpen U \u2227 y \u2209 U \u2227 x \u2208 U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem disjoint_pure_nhds_of_eq [T1Space X] {x : X} :\n    Disjoint (pure x) (\ud835\udcdd x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem specializes_or_ne_of_t1 [T1Space X] {x y : X} :\n    x \u2933 y \u2228 x \u2260 y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem exists_closed_neighborhood_of_point [T1Space X] {x : X} :\n    \u2203 C : Set X, IsClosed C \u2227 x \u2208 interior C := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem open_union_singleton_of_ne [T0Space X] {x y : X} (h : x \u2260 y) :\n    \u2203 U : Set X, IsOpen (U \u222a {x}) \u2227 y \u2209 U \u222a {x} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_le_principal_singleton_iff [T1Space X] {x y : X} :\n    \ud835\udcdd y \u2264 pure x \u2194 y = x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem nhds_antisymm_implies_eq [T0Space X] {a b : X} :\n    (\ud835\udcdd a \u2264 \ud835\udcdd b) \u2192 (\ud835\udcdd b \u2264 \ud835\udcdd a) \u2192 a = b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X]\nvariable [R0Space X] {x y : X}\nvariable (X) in\nvariable [R1Space X] {x y : X}\nvariable [WeaklyLocallyCompactSpace X]\n\nopen Function Filter TopologicalSpace Topology Set\ntheorem inseparable_of_closure_inter_nonempty [T0Space X] {x y : X} :\n    (closure ({x} : Set X) \u2229 closure ({y} : Set X)).Nonempty \u2192 Inseparable x y := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.isClosed_union {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.isOpen_inter {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \u2229 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.closed_diff {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \\ t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.open_diff {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \\ t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.closed_compl {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClosed s\u1d9c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.open_compl {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsOpen s\u1d9c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem ContinuousOn.clopen_preimage_diff {X : Type*} {Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {f : X \u2192 Y} {U : Set X} {t : Set Y}\n    (hcont : ContinuousOn f U) (hU : IsClopen U) (ht : IsClopen t) :\n    IsClopen (U \\ f \u207b\u00b9' t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem isClopen_inter_of_disjoint_cover_clopen_rev {X : Type*} [TopologicalSpace X]\n    {s a b : Set X} (h : IsClopen s) (cover : s \u2286 a \u222a b)\n    (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (s \u2229 b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem isClopen_of_disjoint_cover_closed {X : Type*} [TopologicalSpace X]\n    {a b : Set X} (cover : (Set.univ : Set X) \u2286 a \u222a b)\n    (ha : IsClosed a) (hb : IsClosed b) (hab : Disjoint a b) : IsClopen a := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem Topology.IsQuotientMap.isClopen_preimage_left {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} (hf : IsQuotientMap f)\n    {s : Set Y} : IsClopen (f \u207b\u00b9' s) \u2192 IsClopen s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem continuous_boolIndicator_iff_isClopen_compl {X : Type*} [TopologicalSpace X]\n    (U : Set X) : Continuous (U\u1d9c).boolIndicator \u2194 IsClopen U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem continuousOn_boolIndicator_iff_isClopen_compl {X : Type*} [TopologicalSpace X]\n    {s U : Set X} : ContinuousOn (U\u1d9c).boolIndicator s \u2194 IsClopen (((\u2191) : s \u2192 X) \u207b\u00b9' U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.symm_diff {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClopen ((s \\ t) \u222a (t \\ s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.preimage_comp {X : Type*} {Y : Type*} {Z : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\n    {f : X \u2192 Y} {g : Y \u2192 Z} {s : Set Z}\n    (hs : IsClopen s) (hg : Continuous g) (hf : Continuous f) :\n    IsClopen ((g \u2218 f) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.prod_left {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsClopen s) : IsClopen (s \u00d7\u02e2 (Set.univ : Set Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem IsClopen.prod_right {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {t : Set Y} (ht : IsClopen t) : IsClopen ((Set.univ : Set X) \u00d7\u02e2 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\n\ntheorem isClopen_range_sum_swap {X : Type*} {Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] : IsClopen (Set.range (Sum.swap : X \u2295 Y \u2192 Y \u2295 X)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isClosed_union_three {X : Type*} [TopologicalSpace X] {s t u : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) (hu : IsClopen u) :\n    IsClosed (s \u222a t \u222a u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isOpen_union {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem ContinuousOn.clopen_preimage_union {X : Type*} {Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {f : X \u2192 Y} {U : Set X} {t : Set Y}\n    (hcont : ContinuousOn f U) (hU : IsClopen U) (ht : IsClopen t) :\n    IsClopen (U \u222a f \u207b\u00b9' t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_union_of_disjoint_cover_clopen {X : Type*} [TopologicalSpace X]\n    {s a b : Set X} (h : IsClopen s) (cover : s \u2286 a \u222a b)\n    (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (s \u222a a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_of_disjoint_cover_open' {X : Type*} [TopologicalSpace X]\n    {a b : Set X} (cover : (Set.univ : Set X) \u2286 a \u222a b)\n    (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem Topology.IsQuotientMap.isClopen_image {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} (hf : IsQuotientMap f)\n    {s : Set X} : IsClopen (f '' s) \u2194 IsClopen s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_symm_diff {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed ((s \\ t) \u222a (t \\ s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_comp\u2082 {X : Type*} {Y : Type*} {Z : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\n    {f : X \u2192 Y} {g : Y \u2192 Z} {s : Set Z}\n    (hs : IsClopen s) (hg : Continuous g) (hf : Continuous f) :\n    IsClopen (f \u207b\u00b9' (g \u207b\u00b9' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_compl {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClopen (s \u00d7\u02e2 s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_range_sum_inl_inr_union {X : Type*} {Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] : IsClopen (Set.range (Sum.inl : X \u2192 X \u2295 Y) \u222a Set.range (Sum.inr : Y \u2192 X \u2295 Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isClosed_inter {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \u2229 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closure_eq_self {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : closure s = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.interior_eq_self {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : interior s = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.clopen_inter_self_compl {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : IsClopen (s \u2229 s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_compl_left {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} (hs : IsClopen s) : IsClopen (s \u00d7\u02e2 (Set.univ : Set Y)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_compl_right {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {t : Set Y} (ht : IsClopen t) : IsClopen (((Set.univ : Set X)\u1d9c) \u00d7\u02e2 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_range_sum_inr_inl_union {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] : IsClopen (Set.range (Sum.inr : Y \u2192 X \u2295 Y) \u222a Set.range (Sum.inl : X \u2192 X \u2295 Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closure_subset {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : closure s \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.interior_subset {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : s \u2286 interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isOpen_union_three {X : Type*} [TopologicalSpace X] {s t u : Set X} (hs : IsClopen s) (ht : IsClopen t) (hu : IsClopen u) : IsOpen (s \u222a t \u222a u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_comp\u2083 {W X Y Z : Type*} [TopologicalSpace W] [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] {h : W \u2192 X} {f : X \u2192 Y} {g : Y \u2192 Z} {s : Set Z} (hs : IsClopen s) (hh : Continuous h) (hf : Continuous f) (hg : Continuous g) : IsClopen ((g \u2218 f \u2218 h) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.compl_prod {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} (hs : IsClopen s) : IsClopen (s\u1d9c \u00d7\u02e2 (Set.univ : Set Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_prod_closed {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} {t : Set Y} (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \u00d7\u02e2 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_prod_open {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} {t : Set Y} (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \u00d7\u02e2 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_four {X : Type*} [TopologicalSpace X] {s t u v : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) (hu : IsClopen u) (hv : IsClopen v) :\n    IsClosed (s \u222a t \u222a u \u222a v) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_iUnion_of_finite {X : Type*} {\u03b9 : Type*} [TopologicalSpace X] [Finite \u03b9]\n    {f : \u03b9 \u2192 Set X} (h : \u2200 i, IsClopen (f i)) : IsClosed (\u22c3 i, f i) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_iInter_of_finite {X : Type*} {\u03b9 : Type*} [TopologicalSpace X] [Finite \u03b9]\n    {f : \u03b9 \u2192 Set X} (h : \u2200 i, IsClopen (f i)) : IsOpen (\u22c2 i, f i) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_comp\u2084 {A B C D E : Type*}\n    [TopologicalSpace A] [TopologicalSpace B] [TopologicalSpace C]\n    [TopologicalSpace D] [TopologicalSpace E]\n    {h : A \u2192 B} {g : B \u2192 C} {f : C \u2192 D} {k : D \u2192 E} {s : Set E}\n    (hs : IsClopen s) (hh : Continuous h) (hg : Continuous g)\n    (hf : Continuous f) (hk : Continuous k) :\n    IsClopen ((k \u2218 f \u2218 g \u2218 h) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_diff_of_disjoint_cover_clopen {X : Type*} [TopologicalSpace X] {s a b : Set X} (h : IsClopen s) (cover : s \u2286 a \u222a b) (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (s \\ a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_of_disjoint_cover_closed_right {X : Type*} [TopologicalSpace X] {a b : Set X} (cover : (Set.univ : Set X) \u2286 a \u222a b) (ha : IsClosed a) (hb : IsClosed b) (hab : Disjoint a b) : IsClopen b := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem Topology.IsQuotientMap.clopen_preimage_of {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} (hf : IsQuotientMap f) {s : Set Y} : IsClopen s \u2192 IsClopen (f \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_left_closed {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} (hs : IsClopen s) : IsClosed (s \u00d7\u02e2 (Set.univ : Set Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_right_closed {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {t : Set Y} (ht : IsClopen t) : IsClosed ((Set.univ : Set X) \u00d7\u02e2 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_union_of_disjoint_cover_clopen_left {X : Type*} [TopologicalSpace X] {s a b : Set X} (h : IsClopen s) (cover : s \u2286 a \u222a b) (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (s \u222a b) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem Topology.IsQuotientMap.clopen_image_of {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} (hf : IsQuotientMap f) {s : Set X} : IsClopen s \u2192 IsClopen (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_compl_alt {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : IsClopen (s\u1d9c \u00d7\u02e2 s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isClosed_union_left {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \u222a t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isOpen_inter_right {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \u2229 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_preimage {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {s : Set Y} (hf : Continuous f) (hs : IsClopen s) : IsClosed (f \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_preimage {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {s : Set Y} (hf : Continuous f) (hs : IsClopen s) : IsOpen (f \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.union_iUnion_finset {X : Type*} {\u03b9 : Type*} [TopologicalSpace X] {s : Finset \u03b9} {f : \u03b9 \u2192 Set X} (h : \u2200 i \u2208 s, IsClopen (f i)) : IsClopen (\u22c3 i \u2208 s, f i \u222a (f i)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.inter_iInter_finset {X : Type*} {\u03b9 : Type*} [TopologicalSpace X] {s : Finset \u03b9} {f : \u03b9 \u2192 Set X} (h : \u2200 i \u2208 s, IsClopen (f i)) : IsClopen (\u22c2 i \u2208 s, f i \u2229 (f i)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem isClopen_inter_of_cover {X : Type*} [TopologicalSpace X] {s a b : Set X} (hs : IsClopen s) (ha : IsOpen a) (hb : IsOpen b) (cover : s = a \u222a b) : IsClopen (s \u2229 a) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_univ_prod {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {t : Set Y} (ht : IsClopen t) : IsOpen ((Set.univ : Set X) \u00d7\u02e2 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_comp_three {W X Y Z : Type*} [TopologicalSpace W] [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] {h : W \u2192 X} {f : X \u2192 Y} {g : Y \u2192 Z} {s : Set Z} (hs : IsClopen s) (hh : Continuous h) (hf : Continuous f) (hg : Continuous g) : IsClopen (((g \u2218 f) \u2218 h) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_comp_four {A B C D E : Type*} [TopologicalSpace A] [TopologicalSpace B] [TopologicalSpace C] [TopologicalSpace D] [TopologicalSpace E] {h : A \u2192 B} {g : B \u2192 C} {f : C \u2192 D} {k : D \u2192 E} {s : Set E} (hs : IsClopen s) (hh : Continuous h) (hg : Continuous g) (hf : Continuous f) (hk : Continuous k) : IsClopen (((k \u2218 f \u2218 g) \u2218 h) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.union_compl_isClopen {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : IsClopen (s \u222a s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isClosed_union_right {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s\u1d9c \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_three_left {X : Type*} [TopologicalSpace X] {s t u : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) (hu : IsClopen u) : IsClosed (s \u222a t\u1d9c \u222a u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_inter_three {X : Type*} [TopologicalSpace X] {s t u : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) (hu : IsClopen u) : IsOpen (s \u2229 t \u2229 u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_comp\u2085 {A B C D E F : Type*}\n    [TopologicalSpace A] [TopologicalSpace B] [TopologicalSpace C]\n    [TopologicalSpace D] [TopologicalSpace E] [TopologicalSpace F]\n    {h : A \u2192 B} {g : B \u2192 C} {f : C \u2192 D} {k : D \u2192 E} {\u2113 : E \u2192 F} {s : Set F}\n    (hs : IsClopen s) (hh : Continuous h) (hg : Continuous g)\n    (hf : Continuous f) (hk : Continuous k) (h\u2113 : Continuous \u2113) :\n    IsClopen ((\u2113 \u2218 k \u2218 f \u2218 g \u2218 h) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_univ_right {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {t : Set Y}\n    (ht : IsClopen t) : IsClopen ((Set.univ : Set X) \u00d7\u02e2 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_iInter_of_finite' {X : Type*} {\u03b9 : Type*}\n    [TopologicalSpace X] [Finite \u03b9] {f : \u03b9 \u2192 Set X}\n    (h : \u2200 i, IsClopen (f i)) : IsClosed (\u22c2 i, f i) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_iUnion_of_finite' {X : Type*} {\u03b9 : Type*}\n    [TopologicalSpace X] [Finite \u03b9] {f : \u03b9 \u2192 Set X}\n    (h : \u2200 i, IsClopen (f i)) : IsOpen (\u22c3 i, f i) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closure_inter_eq_self {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : closure (s \u2229 s) = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.interior_union_eq_self {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : interior (s \u222a s) = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.compl_prod_right' {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {t : Set Y}\n    (ht : IsClopen t) : IsClopen ((Set.univ : Set X)\u1d9c \u00d7\u02e2 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.compl_prod_left' {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {s : Set X}\n    (hs : IsClopen s) : IsClopen (s\u1d9c \u00d7\u02e2 (Set.univ : Set Y)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_symm_union {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsClosed ((s \u222a t) \u222a (s\u1d9c \u2229 t\u1d9c)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_prod_univ {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} (hs : IsClopen s) : IsOpen (s \u00d7\u02e2 (Set.univ : Set Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_comp\u2085 {A B C D E F : Type*} [TopologicalSpace A] [TopologicalSpace B] [TopologicalSpace C] [TopologicalSpace D] [TopologicalSpace E] [TopologicalSpace F] {h : A \u2192 B} {g : B \u2192 C} {f : C \u2192 D} {k : D \u2192 E} {\u2113 : E \u2192 F} {s : Set F} (hs : IsClopen s) (hh : Continuous h) (hg : Continuous g) (hf : Continuous f) (hk : Continuous k) (h\u2113 : Continuous \u2113) : IsClopen ((\u2113 \u2218 k \u2218 f \u2218 g \u2218 h) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_boolIndicator {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {t : Set Y} (hf : Continuous f) (ht : IsClopen t) : Continuous ((f \u207b\u00b9' t).boolIndicator) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_iUnion_finset {X : Type*} {\u03b9 : Type*} [TopologicalSpace X] {s : Finset \u03b9} {f : \u03b9 \u2192 Set X} (h : \u2200 i \u2208 s, IsClopen (f i)) : IsOpen (\u22c3 i \u2208 s, f i) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_iInter_finset {X : Type*} {\u03b9 : Type*} [TopologicalSpace X] {s : Finset \u03b9} {f : \u03b9 \u2192 Set X} (h : \u2200 i \u2208 s, IsClopen (f i)) : IsClosed (\u22c2 i \u2208 s, f i) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_four {X : Type*} [TopologicalSpace X] {s t u v : Set X} (hs : IsClopen s) (ht : IsClopen t) (hu : IsClopen u) (hv : IsClopen v) : IsClosed (s \u222a t \u222a u \u222a v) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isClosed_inter_left {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \u2229 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isOpen_union_right {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \u222a t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_symmetric_union {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed ((s \u222a t) \\ (s \u2229 t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem ContinuousOn.clopen_preimage_union {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {f : X \u2192 Y} {U : Set X} {V : Set Y}\n    (hcont : ContinuousOn f U) (hU : IsClopen U) (hV : IsClopen V) :\n    IsClopen (U \u222a f \u207b\u00b9' V) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_diff_univ {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClosed ((Set.univ : Set X) \\ s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isOpen_union_three {X : Type*} [TopologicalSpace X] {s t u : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) (hu : IsClopen u) :\n    IsOpen (s \u222a t \u222a u) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_compl_left {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClosed (s\u1d9c \u222a s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_inter_compl_right {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsOpen (s\u1d9c \u2229 s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_univ_prod_compl {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {t : Set Y} (ht : IsClopen t) :\n    IsOpen ((Set.univ : Set X) \u00d7\u02e2 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_symm_union {X : Type*} [TopologicalSpace X]\n    {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) :\n    IsClosed ((s \u222a t) \u222a (s\u1d9c \u2229 t\u1d9c)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_symm_inter {X : Type*} [TopologicalSpace X]\n    {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) :\n    IsOpen ((s \u2229 t) \u2229 (s\u1d9c \u222a t\u1d9c)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.compl_prod_self {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} {t : Set Y}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s\u1d9c \u00d7\u02e2 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_diff_compl {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsOpen (s\u1d9c \\ s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_symm {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed ((s \u222a t) \u222a (t \u222a s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_inter_symm {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen ((s \u2229 t) \u2229 (t \u2229 s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_union_inter {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen ((s \u222a t) \u2229 (s \u222a t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_diff_left {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \\ t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_diff_right {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s\u1d9c \\ t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_compl_self {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClosed (s\u1d9c\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_compl_self {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsOpen (s\u1d9c\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem ContinuousOn.clopen_preimage_union_diff {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {U : Set X} {V : Set Y}\n    (hcont : ContinuousOn f U) (hU : IsClopen U) (hV : IsClopen V) :\n    IsClopen (U \u222a (f \u207b\u00b9' V) \\ U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_preimage_compl {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {s : Set Y}\n    (hf : Continuous f) (hs : IsClopen s) : IsClosed (f \u207b\u00b9' s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_preimage_compl {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {s : Set Y}\n    (hf : Continuous f) (hs : IsClopen s) : IsOpen (f \u207b\u00b9' s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_triple {X : Type*} [TopologicalSpace X] {a b c : Set X}\n    (ha : IsClopen a) (hb : IsClopen b) (hc : IsClopen c) :\n    IsClosed (a \u222a b \u222a c\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.inter_eq_union_diff {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) :\n    s \u2229 t = (s \u222a t) \\ ((s \u2229 t)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closure_subset_interior {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : closure s \u2286 interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.interior_superset_closure {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : interior s \u2287 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_quadriple {X : Type*} [TopologicalSpace X]\n    {w x y z : Set X}\n    (hw : IsClopen w) (hx : IsClopen x) (hy : IsClopen y) (hz : IsClopen z) :\n    IsClosed (w \u222a x \u222a y \u222a z\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_inter_quadriple {X : Type*} [TopologicalSpace X]\n    {w x y z : Set X}\n    (hw : IsClopen w) (hx : IsClopen x) (hy : IsClopen y) (hz : IsClopen z) :\n    IsOpen (w \u2229 x \u2229 y \u2229 z) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_union_finite {X : Type*} {\u03b9 : Type*}\n    [TopologicalSpace X] [Finite \u03b9] {f : \u03b9 \u2192 Set X}\n    (hf : \u2200 i, IsClopen (f i)) : IsClosed (\u22c3 i, f i \u222a (f i)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_inter_finite {X : Type*} {\u03b9 : Type*}\n    [TopologicalSpace X] [Finite \u03b9] {f : \u03b9 \u2192 Set X}\n    (hf : \u2200 i, IsClopen (f i)) : IsOpen (\u22c2 i, f i \u2229 (f i)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closure_eq_interior {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : closure s = interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_symm_diff_open {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen ((s \\ t) \u222a (t \\ s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_clopen_pair {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} {t : Set Y}\n    (hs : IsClopen s) (ht : IsClopen t) :\n    IsClopen (s \u00d7\u02e2 t \u222a s\u1d9c \u00d7\u02e2 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.range_sum_inl_inr {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] :\n    IsClopen (Set.range (Sum.inl : X \u2192 X \u2295 Y) \u2229 Set.range (Sum.inr : Y \u2192 X \u2295 Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.range_sum_swap_union {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] :\n    IsClopen (Set.range (Sum.swap : X \u2295 Y \u2192 Y \u2295 X) \u222a Set.range (Sum.swap \u2218 Sum.swap)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_compl_prod {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {s : Set X}\n    (hs : IsClopen s) : IsClosed ((s\u1d9c) \u00d7\u02e2 (Set.univ : Set Y)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_boolIndicator {X : Type*}\n    [TopologicalSpace X] {U : Set X} (hU : IsClopen U) :\n    ClosedEmbedding U.boolIndicator := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_boolIndicator_compl {X : Type*}\n    [TopologicalSpace X] {U : Set X} (hU : IsClopen U) :\n    OpenEmbedding (U\u1d9c).boolIndicator := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_superset {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (hsub : s \u2286 t) : IsOpen t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.union_isClopen {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \u222a t \u222a s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.inter_isClopen {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \u2229 t \u2229 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_closed {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {s : Set Y} (hf : Continuous f) (hs : IsClopen s) : IsClosed (f \u207b\u00b9' s\u1d9c\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.preimage_open {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y} {s : Set Y} (hf : Continuous f) (hs : IsClopen s) : IsOpen (f \u207b\u00b9' s\u1d9c\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_range_subtype {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsClopen s) : IsClosed (Set.range (Subtype.val : s \u2192 X)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.symm_diff_closed' {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsClosed ((s \\ t) \u222a (t \\ s)\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.symm_diff_open' {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsOpen ((s \\ t\u1d9c) \u222a (t \\ s\u1d9c)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.prod_isClopen_right {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {t : Set Y} (ht : IsClopen t) : IsClopen ((Set.univ : Set X) \u00d7\u02e2 t \u2229 (Set.univ : Set X) \u00d7\u02e2 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isClosed_iUnion_pair {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsClosed (s \u222a t \u222a (s \u2229 t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.isOpen_iInter_pair {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \u2229 t \u2229 (s \u222a t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_boolIndicator {X : Type*} [TopologicalSpace X] {U : Set X} (hU : IsClopen U) : IsClosed (Set.range U.boolIndicator) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_preimage_comp {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 Y} {g : Y \u2192 Z} {s : Set Z} (hs : IsClopen s) (hf : Continuous f) (hg : Continuous g) : IsClosed ((g \u2218 f) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_union_right' {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s\u1d9c \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_prod_right' {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {t : Set Y} (ht : IsClopen t) : IsClosed ((Set.univ : Set X) \u00d7\u02e2 t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem Continuous.clopen_preimage' {X : Type*} {Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {f : X \u2192 Y} (hf : Continuous f) {s : Set Y}\n    (hs : IsClopen s) : IsClopen (f \u207b\u00b9' s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_boolIndicator {X : Type*} [TopologicalSpace X] {U : Set X}\n    (hU : IsClopen U) : OpenEmbedding U.boolIndicator := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.union_univ {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClopen (s \u222a Set.univ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.inter_empty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClopen (s \u2229 \u2205) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_prod_compl {X : Type*} {Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {s : Set X}\n    (hs : IsClopen s) : IsClosed (s \u00d7\u02e2 s\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_union_closure {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsOpen (s \u222a closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_inter_interior {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClosed (s \u2229 interior s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_prod_right' {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {t : Set Y} (ht : IsClopen t) : IsClosed ((Set.univ : Set X) \u00d7\u02e2 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_range_subtype' {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsClopen s) : IsClosed (Subtype.val '' (Set.univ : Set s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_diff_left {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsClopen s) (ht : IsClopen t) : IsOpen (s \\ t\u1d9c) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_iUnion_pair {X : Type*} [TopologicalSpace X]\n    {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) :\n    IsClosed (\u22c3 i : Bool, cond i s t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_iInter_pair {X : Type*} [TopologicalSpace X]\n    {s t : Set X} (hs : IsClopen s) (ht : IsClopen t) :\n    IsOpen (\u22c2 i : Bool, cond i s t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closure_eq_interior {X : Type*} [TopologicalSpace X]\n    {s : Set X} (hs : IsClopen s) : closure s = interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.closed_preimage_comp {X : Type*} {Y : Type*} {Z : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\n    {f : X \u2192 Y} {g : Y \u2192 Z} {s : Set Z}\n    (hs : IsClopen s) (hf : Continuous f) (hg : Continuous g) :\n    IsClosed ((g \u2218 f) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type u} {Y : Type v} {\u03b9 : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Filter TopologicalSpace Topology Set\ntheorem IsClopen.open_preimage_comp {X : Type*} {Y : Type*} {Z : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\n    {f : X \u2192 Y} {g : Y \u2192 Z} {s : Set Z}\n    (hs : IsClopen s) (hf : Continuous f) (hg : Continuous g) :\n    IsOpen ((g \u2218 f) \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem eventually_mapsTo_closed {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem nhds_compactOpen_subset {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | g \u207b\u00b9' (Set.univ) \u2286 K} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem tendsto_nhds_compactOpen_closed {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem continuous_compactOpen_closed {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 IsClosed {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem compactOpen_eq_iInf_induced_closed {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K), .induced (.restrict K) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem tendsto_compactOpen_iff_forall_closed {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 Tendsto (fun i => (F i).restrict K) l (\ud835\udcdd (f.restrict K)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem exists_tendsto_compactOpen_iff_forall_closed {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T2Space Y] {l : Filter \u03b9} [Filter.NeBot l]\n    (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsClosed s \u2192 \u2203 f, Tendsto (fun i => (F i).restrict s) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\n\ntheorem continuous_uncurry_of_continuous_closed {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] [LocallyCompactSpace Y]\n    (f : C(X, C(Y, Z))) :\n    Continuous (fun p : X \u00d7 Y => f p.1 p.2) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_frontier {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsOpen U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_closed {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsClosed K), \ud835\udcdf {g : C(X, Y) | MapsTo g K univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsClosed U \u2192 IsOpen {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_open {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsOpen K), .induced (.restrict K) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_compactOpen_iff_forall_open {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 Tendsto (fun i => (F i).restrict K) l (\ud835\udcdd (f.restrict K)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem exists_tendsto_compactOpen_iff_forall_open {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T1Space Y] {l : Filter \u03b9}\n    [Filter.NeBot l] (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsOpen s \u2192 \u2203 f, Tendsto (fun i => (F i).restrict s) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_compact {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f = \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | g \u207b\u00b9' univ \u2286 K} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200\u1da0 a in l, \u2200 x \u2208 K, F a x = f x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_inter {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_compact_closed {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsCompact K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_compact {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | MapsTo g K Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact_closed {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_compact_closed {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsCompact K \u2192 \u2200 U, IsClosed U \u2192 IsClosed {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_compact {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), TopologicalSpace.induced (ContinuousMap.restrict K) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_compact' {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f = \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | MapsTo g K Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_closed {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200\u1da0 a in l, \u2200 x \u2208 K, F a x = f x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_compact_closed {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsCompact K \u2192 \u2200 U, IsClosed U \u2192 IsClosed {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_open {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsOpen K), .induced (.restrict K) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_compact {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), .induced (.restrict K) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_compactOpen_iff_forall_open {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 Tendsto (fun i => (F i).restrict K) l (\ud835\udcdd (f.restrict K)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem exists_tendsto_compactOpen_iff_forall_open {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T1Space Y] {l : Filter \u03b9}\n    [Filter.NeBot l] (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsOpen s \u2192 \u2203 f, Tendsto (fun i => (F i).restrict s) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_inter {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 interior (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_compact {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f = \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | g \u207b\u00b9' Set.univ \u2286 K} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_closed_open {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsClosed K \u2192 \u2200 U, IsOpen U \u2192 IsClosed {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closed_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_subset {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_closed_predicate {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 IsClosed {x | MapsTo (f x) (closure K) U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_compactOpen_iff_forall_closed_subset {\u03b9 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194 \u2200 K, IsClosed K \u2192 Tendsto (fun i \u21a6 (F i).restrict (closure K)) l (\ud835\udcdd (f.restrict (closure K))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_frontier_interior {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsOpen U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (frontier K) (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open_maps {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_pred {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) K (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_compact_closed_closureU {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsCompact K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact_closed_subset {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_compact_closed_pred {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsCompact K \u2192 \u2200 U, IsClosed U \u2192 IsClosed {x | MapsTo (f x) K (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_predicate {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) (closure K) U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_closed_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open_subset {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194 \u2200 K, IsOpen K \u2192 \u2200\u1da0 a in l, \u2200 x \u2208 K, F a x = f x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_alt {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) K (interior U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_interior_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 interior (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closed_subset {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsClosed U)\n    (h : MapsTo f (closure K) U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open_subset {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K (interior U) \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_open_subset {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsOpen K), .induced (ContinuousMap.restrict (closure K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_open {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsOpen K), \ud835\udcdf {g : C(X, Y) | MapsTo g K univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_compact_subset {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsCompact K \u2192 IsClosed {x | MapsTo (f x) K univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_compact_subset {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), TopologicalSpace.induced (ContinuousMap.restrict (interior K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_compact_superset {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f = \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | g \u207b\u00b9' Set.univ \u2286 closure K} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem exists_tendsto_compactOpen_iff_forall_open_subset {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T1Space Y] {l : Filter \u03b9}\n    [Filter.NeBot l] (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsOpen s \u2192 \u2203 f, Tendsto (fun i \u21a6 (F i).restrict (closure s)) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_frontier {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 frontier s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_closed_sets_subset {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 IsClosed {x | MapsTo (f x) (closure K) (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open_maps_subset {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) (interior K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem exists_tendsto_compactOpen_iff_forall_closed_subset {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T2Space Y] {l : Filter \u03b9}\n    [Filter.NeBot l] (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsClosed s \u2192 \u2203 f, Tendsto (fun i \u21a6 (F i).restrict (closure s)) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_compact_closed_predicate {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsCompact K \u2192 \u2200 U, IsClosed U \u2192 IsClosed {x | MapsTo (f x) (closure K) (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_compact_double {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f = \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | MapsTo g (closure K) univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_interior {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_predicate {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) K (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_maps {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200\u1da0 a in l, MapsTo (F a) (closure K) (closure (range f)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_predicate_alt {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) (interior K) U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closed_of_subset {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K K' : Set X} {U : Set Y} {f : C(X, Y)}\n    (hK'K : K' \u2286 K) (hK : IsClosed K) (hU : IsClosed U) (hf : MapsTo f K U) :\n    \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K' U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | MapsTo g (closure K) Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_closure {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_compact_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), .induced (ContinuousMap.restrict (closure K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_inter {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsOpen U)\n    (hf : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (interior K) (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_interior {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) (interior K) (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_interior {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) (interior K) (interior U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_frontier {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K), .induced (ContinuousMap.restrict (frontier K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_compactOpen_iff_forall_frontier {\u03b9 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 Tendsto (fun i \u21a6 (F i).restrict (frontier K)) l (\ud835\udcdd (f.restrict (frontier K))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem exists_tendsto_compactOpen_iff_forall_interior {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T1Space Y] {l : Filter \u03b9}\n    [Filter.NeBot l] (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsOpen s \u2192 \u2203 f, Tendsto (fun i \u21a6 (F i).restrict (interior s)) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_frontier {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 frontier s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_compact_interior {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsCompact K) (hU : IsOpen U)\n    (hf : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_frontier {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsOpen U)\n    (hf : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (frontier K) (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_frontier {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192\n      IsOpen {x | MapsTo (f x) (frontier K) (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), .induced (ContinuousMap.restrict (closure K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_interior {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 interior s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open_eq {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K (interior U) \u2192 \u2200\u1da0 a in l, MapsTo (F a) K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_predicate {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsClosed U \u2192 IsOpen {x | MapsTo (f x) (closure K) U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_compact_frontierU {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsCompact K) (hU : IsOpen U)\n    (hf : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K (frontier U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact_maps {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_compact_pred {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsCompact K \u2192 \u2200 U, IsOpen U \u2192 IsClosed {x | MapsTo (f x) K (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_maps {\u03b1 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (closure (range f)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_frontier_pred {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsClosed K \u2192 \u2200 U, IsOpen U \u2192 IsClosed {x | MapsTo (f x) (frontier K) (interior U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_compactOpen_iff_forall_open_closure {\u03b9 X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 Tendsto (fun i \u21a6 (F i).restrict (closure K)) l (\ud835\udcdd (f.restrict (closure K))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_interior_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 interior (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_alt {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) (interior K) U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closed_variant {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_variant {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f (closure K) U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_closed_variant {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K), .induced (ContinuousMap.restrict (interior K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem exists_tendsto_compactOpen_iff_forall_closed_variant {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T2Space Y] {l : Filter \u03b9} [Filter.NeBot l]\n    (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsClosed s \u2192 \u2203 f, Tendsto (fun i => (F i).restrict (interior s)) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_variant {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 closure (interior s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_frontier_variant {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsOpen U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (frontier K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_closed_variant {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsClosed K), \ud835\udcdf {g : C(X, Y) | MapsTo g (closure K) univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open_variant {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f (interior K) U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_variant {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) (closure K) (interior U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_compactOpen_iff_forall_open_variant {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 Tendsto (fun i => (F i).restrict (interior K)) l (\ud835\udcdd (f.restrict (interior K))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact_variant {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200\u1da0 a in l, \u2200 x \u2208 closure K, F a x = f x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_compact_closed_variant {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsCompact K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_variant {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsOpen U \u2192 IsOpen {x | MapsTo (f x) (interior K) (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_compact_variant {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), TopologicalSpace.induced (ContinuousMap.restrict (frontier K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_le_principal {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 K : Set X, \ud835\udcdf {g : C(X, Y) | g \u207b\u00b9' Set.univ \u2286 closure K} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_closure {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f K U \u2192\n        \u2200\u1da0 a in l, MapsTo (F a) (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_frontiers {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K),\n        TopologicalSpace.induced (ContinuousMap.restrict (frontier K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem exists_tendsto_compactOpen_iff_forall_frontier {\u03b9 X Y : Type*} [TopologicalSpace X]\n    [WeaklyLocallyCompactSpace X] [TopologicalSpace Y] [T2Space Y] {l : Filter \u03b9}\n    [Filter.NeBot l] (F : \u03b9 \u2192 C(X, Y)) :\n    (\u2203 f, Tendsto F l (\ud835\udcdd f)) \u2194\n      \u2200 s : Set X, IsClosed s \u2192 \u2203 f, Tendsto (fun i \u21a6 (F i).restrict (frontier s)) l (\ud835\udcdd f) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsClosed U)\n    (h : MapsTo f (closure K) (closure U)) :\n    \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_closure {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f (closure K) U \u2192 \u2200\u1da0 a in l, MapsTo (F a) (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_closure {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K),\n        TopologicalSpace.induced (ContinuousMap.restrict (closure K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_closed_subset {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {K : Set X} {U : Set Y} {f : C(X, Y)}\n    (hK : IsOpen K) (hU : IsClosed U) (h : MapsTo f (closure K) U) :\n    \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_frontier {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K),\n        TopologicalSpace.induced (ContinuousMap.restrict (frontier K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_frontier_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 frontier (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_closed_open_pred {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsClosed K \u2192 \u2200 U, IsOpen U \u2192\n      IsClosed {x | MapsTo (f x) K (interior U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_maps {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (closure (range f)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsOpen U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_le_principal_closed {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) : \ud835\udcdd f \u2264 \u2a05 K : Set X, \ud835\udcdf {g : C(X, Y) | MapsTo g (closure K) Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_inter {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200\u1da0 a in l, \u2200 x \u2208 K, (F a) x = f x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_interior {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsOpen K), TopologicalSpace.induced (ContinuousMap.restrict (interior K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_to_closureU {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_open_closureU {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsOpen K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_frontier_sets {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K), TopologicalSpace.induced (ContinuousMap.restrict (frontier K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closure_frontier {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsOpen U)\n    (h : MapsTo f (closure K) U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (frontier K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_frontier_principal {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) : \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsClosed K), \ud835\udcdf {g : C(X, Y) | MapsTo g (frontier K) Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_compact_frontier_pred {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsCompact K \u2192 \u2200 U, IsOpen U \u2192 IsClosed {x | MapsTo (f x) (frontier K) (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closure_compactU {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsCompact K) (hU : IsClosed U)\n    (h : MapsTo f (closure K) U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact_frontierU {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200 U, IsOpen U \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (frontier U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_interior_frontier {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {y : Y} (s : Set X) : (coev X Y y) '' s \u2286 {y} \u00d7\u02e2 interior (frontier s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_eq_iInf_frontier_principal {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) : \ud835\udcdd f = \u2a05 (K : Set X) (_ : IsClosed K), \ud835\udcdf {g : C(X, Y) | MapsTo g (frontier K) Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_inter_openU {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsOpen U)\n    (h : MapsTo f (interior K) U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (interior K) (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_interiors {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsOpen K), TopologicalSpace.induced (ContinuousMap.restrict (closure (interior K))) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closed_closure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_interior {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | MapsTo g (interior K) Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_closure {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192 MapsTo f (closure K) U \u2192 \u2200\u1da0 a in l, MapsTo (F a) (closure K) U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_closed_closure {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K), .induced (.restrict (closure K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_compact_closed_closureU {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsCompact K) (hU : IsClosed U)\n    (h : MapsTo f K U) : \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (closure K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_closureU {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsOpen K \u2192 \u2200 U, IsClosed U \u2192 IsOpen {x | MapsTo (f x) K (closure U)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_compact_frontier {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), .induced (.restrict (frontier K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_maps_range {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsClosed K \u2192 \u2200\u1da0 a in l, MapsTo (F a) K (closure (range f)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_subset_univ {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 (K : Set X) (_ : IsCompact K), \ud835\udcdf {g : C(X, Y) | g \u207b\u00b9' Set.univ \u2286 closure K} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_rev {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 U, IsClosed U \u2192 \u2200 K, IsClosed K \u2192 MapsTo f K U \u2192 \u2200\u1da0 a in l, MapsTo (F a) K U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_closed_rev {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 U, IsClosed U \u2192 \u2200 K, IsClosed K \u2192 IsClosed {x | MapsTo (f x) K U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_closed_rev {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (U : Set X) (_ : IsClosed U), TopologicalSpace.induced (ContinuousMap.restrict U) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_open_alt {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (U : Set X) (_ : IsOpen U), TopologicalSpace.induced (ContinuousMap.restrict U) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_open_sets_alt {X Y Z : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 U, IsOpen U \u2192 \u2200 V, IsOpen V \u2192 IsOpen {x | MapsTo (f x) U (interior V)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_open_subset_alt {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (U : Set X) (_ : IsOpen U), TopologicalSpace.induced (ContinuousMap.restrict (closure U)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closed_subset {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K\u2081 K\u2082 : Set X} {U : Set Y} {f : C(X, Y)} (hK\u2082 : IsClosed K\u2082) (hK\u2081 : IsClosed K\u2081)\n    (hU : IsClosed U) (hsub : K\u2082 \u2286 K\u2081) (h : MapsTo f K\u2081 U) :\n    \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g K\u2082 U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_le_principal_univ {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : C(X, Y)) :\n    \ud835\udcdd f \u2264 \u2a05 K : Set X, \ud835\udcdf {g : C(X, Y) | MapsTo g K Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_compact' {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsCompact K), TopologicalSpace.induced (ContinuousMap.restrict (closure K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_interior {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsOpen U)\n    (h : MapsTo f (interior K) (interior U)) :\n    \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (interior K) (interior U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_open_frontier {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsOpen K),\n        TopologicalSpace.induced (ContinuousMap.restrict (frontier K)) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_frontier_closure' {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {y : Y} (s : Set X) :\n    (coev X Y y) '' frontier s \u2286 {y} \u00d7\u02e2 frontier (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_compact_eq {\u03b1 X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {l : Filter \u03b1}\n    {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194\n      \u2200 K, IsCompact K \u2192 \u2200\u1da0 i in l, (F i).restrict K = f.restrict K := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem compactOpen_eq_iInf_induced_closed_frontier {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] :\n    (ContinuousMap.compactOpen : TopologicalSpace C(X, Y)) =\n      \u2a05 (K : Set X) (_ : IsClosed K),\n        TopologicalSpace.induced (ContinuousMap.restrict (closure (frontier K))) ContinuousMap.compactOpen := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_compactOpen_iff_forall_open_closure {\u03b9 X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y]\n    {l : Filter \u03b9} (F : \u03b9 \u2192 C(X, Y)) (f : C(X, Y)) :\n    Tendsto F l (\ud835\udcdd f) \u2194 \u2200 K, IsOpen K \u2192\n      Tendsto (fun i => (F i).restrict (closure K)) l (\ud835\udcdd (f.restrict (closure K))) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem nhds_compactOpen_eq_iInf_closure_principal {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] (f : C(X, Y)) :\n    \ud835\udcdd f = \u2a05 (K : Set X) (_ : IsClosed K),\n      \ud835\udcdf {g : C(X, Y) | MapsTo g (closure K) Set.univ} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_closed_frontierU {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsClosed K) (hU : IsClosed U)\n    (h : MapsTo f (closure K) U) :\n    \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (frontier K) (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem tendsto_nhds_compactOpen_closed_equal {\u03b1 X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {l : Filter \u03b1} {F : \u03b1 \u2192 C(X, Y)} {f : C(X, Y)} :\n    Tendsto F l (\ud835\udcdd f) \u2194 \u2200 K, IsClosed K \u2192\n      \u2200\u1da0 i in l, (F i).restrict K = f.restrict K := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem continuous_compactOpen_closed_inter_pred {X Y Z : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] {f : X \u2192 C(Y, Z)} :\n    Continuous f \u2194 \u2200 K, IsClosed K \u2192 \u2200 U, IsClosed U \u2192\n      IsClosed {x | MapsTo (f x) (closure K \u2229 K) U} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem eventually_mapsTo_open_frontierU {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y]\n    {K : Set X} {U : Set Y} {f : C(X, Y)} (hK : IsOpen K) (hU : IsOpen U)\n    (h : MapsTo f K U) :\n    \u2200\u1da0 g : C(X, Y) in \ud835\udcdd f, MapsTo g (frontier K) (frontier U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {\u03b1 X Y Z T : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]\nvariable {K : Set X} {U : Set Y}\nvariable (Z) in\nvariable [LocallyCompactPair Y Z]\nvariable {X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}\nvariable (X Y)\nvariable {X Y}\nvariable {X : Type*} {Y : Type*} {Z : Type*}\nvariable [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]\nvariable {X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]\n\nopen ContinuousMap Filter TopologicalSpace Topology Set\ntheorem image_coev_subset_interior_frontier' {X Y : Type*}\n    [TopologicalSpace X] [TopologicalSpace Y] {y : Y} (s : Set X) :\n    (coev X Y y) '' interior s \u2286 {y} \u00d7\u02e2 frontier s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem IsIrreducible.exists_mem {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : \u2203 x : X, x \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem not_isIrreducible_empty {X : Type*} [TopologicalSpace X] :\n    \u00ac IsIrreducible (\u2205 : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem Set.Subsingleton.isIrreducible {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : s.Subsingleton) (hne : s.Nonempty) : IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem isPreirreducible_iff_interior {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible (interior s) \u2194 IsPreirreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem isIrreducible_iff_interior {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible (interior s) \u2194 IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem exists_irreducible {X : Type*} [TopologicalSpace X] (s : Set X) (h : IsIrreducible s) :\n    \u2203 t : Set X, IsIrreducible t \u2227 s \u2286 t \u2227 \u2200 u, IsIrreducible u \u2192 t \u2286 u \u2192 u = t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem isIrreducible_of_mem_irreducibleComponents {X : Type*} [TopologicalSpace X]\n    {s : Set X} (H : s \u2208 irreducibleComponents X) : IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem irreducibleComponents_subset_closed (X : Type*) [TopologicalSpace X] :\n    irreducibleComponents X \u2286 {s | IsClosed s} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem irreducibleComponent_subset {X : Type*} [TopologicalSpace X] {x : X} :\n    ({x} : Set X) \u2286 irreducibleComponent x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem subset_closure_irreducibleComponent {X : Type*} [TopologicalSpace X] {x : X} :\n    irreducibleComponent x \u2286 closure ({x} : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem isPreirreducible_irreducibleComponent {X : Type*} [TopologicalSpace X] {x : X} :\n    IsPreirreducible (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem IsIrreducible.eq_irreducibleComponent {X : Type*} [TopologicalSpace X] {s : Set X}\n    {x : X} (hs : IsIrreducible s) (hx : x \u2208 s) : s = irreducibleComponent x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem irreducibleComponent_subset_irreducibleComponents {X : Type*} [TopologicalSpace X]\n    {x : X} {t : Set X} (ht : t \u2208 irreducibleComponents X) (hx : x \u2208 t) :\n    irreducibleComponent x \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem closure_irreducibleComponent {X : Type*} [TopologicalSpace X] {x : X} :\n    closure (irreducibleComponent x) = irreducibleComponent x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem preirreducibleSpace_def (X : Type*) [TopologicalSpace X] :\n    PreirreducibleSpace X \u2194 IsPreirreducible (\u22a4 : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem IsOpen.closure_eq_univ {X : Type*} [TopologicalSpace X] [PreirreducibleSpace X]\n    {s : Set X} (ho : IsOpen s) (hne : s.Nonempty) : closure s = (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem IsPreirreducible.preimage_continuous {X : Type*} [TopologicalSpace X] {Y : Type*}\n    [TopologicalSpace Y] {s : Set X} (H : IsPreirreducible s) {f : Y \u2192 X}\n    (hf : Continuous f) : IsPreirreducible (f \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem IsIrreducible.preimage_continuous {X : Type*} [TopologicalSpace X] {Y : Type*}\n    [TopologicalSpace Y] {s : Set X} (H : IsIrreducible s) {f : Y \u2192 X}\n    (hf : Continuous f) : IsIrreducible (f \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem Subtype.irreducibleSpace_iff {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IrreducibleSpace s \u2194 IsIrreducible (univ : Set s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem irreducibleComponents_nonempty {X : Type*} [TopologicalSpace X]\n    [IrreducibleSpace X] : (irreducibleComponents X).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem isPreirreducible_iff_sInter {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible s \u2194\n      \u2200 U : Finset (Set X), (\u2200 u \u2208 U, IsOpen u) \u2192\n        (\u2200 u \u2208 U, (s \u2229 u).Nonempty) \u2192 (s \u2229 \u22c2\u2080 \u2191U).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem isPreirreducible_iff_isOpen_union_isOpen {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible s \u2194\n      \u2200 u v : Set X, IsOpen u \u2192 IsOpen v \u2192 s \u2286 u \u222a v \u2192 (s \u2286 u \u2228 s \u2286 v) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem isIrreducible_iff_sUnion_isOpen {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible s \u2194\n      \u2200 t : Finset (Set X), (\u2200 u \u2208 t, IsOpen u) \u2192 (s \u2286 \u22c3\u2080 \u2191t) \u2192 \u2203 u \u2208 t, s \u2286 u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem subset_closure_union_of_isPreirreducible_of_isOpen {X : Type*}\n    [TopologicalSpace X] {S U : Set X} (hS : IsPreirreducible S)\n    (hU : IsOpen U) (h : S.Nonempty) : S \u2286 closure (S \u222a U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\n\ntheorem IsPreirreducible.closed_subset {X : Type*} [TopologicalSpace X] {t U : Set X}\n    (ht : IsPreirreducible t) (hU : IsClosed U) (hU' : U \u2286 t) : IsPreirreducible U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.ne_empty {X : Type*} [TopologicalSpace X] {s : Set X} (h : IsIrreducible s) : s \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.isPreirreducible_closure {X : Type*} [TopologicalSpace X] {s : Set X} (h : IsIrreducible s) : IsPreirreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_empty_iff {X : Type*} [TopologicalSpace X] : IsIrreducible (\u2205 : Set X) \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_interior {X : Type*} [TopologicalSpace X] {s : Set X} : IsPreirreducible (interior s) \u2194 IsPreirreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_interior {X : Type*} [TopologicalSpace X] {s : Set X} : IsIrreducible (interior s) \u2194 IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_preirreducible_closure {X : Type*} [TopologicalSpace X] (s : Set X) (H : IsPreirreducible s) : \u2203 t : Set X, IsPreirreducible t \u2227 closure s \u2286 t \u2227 \u2200 u, IsPreirreducible u \u2192 t \u2286 u \u2192 u = t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem open_of_mem_irreducibleComponents_compl {X : Type*} [TopologicalSpace X] {s : Set X} (H : s \u2208 irreducibleComponents X) : IsOpen s\u1d9c := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponent_maximal {X : Type*} [TopologicalSpace X] (x : X) : Maximal IsPreirreducible (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem mem_closure_irreducibleComponent {X : Type*} [TopologicalSpace X] (x : X) : x \u2208 closure (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem subset_irreducibleComponent_of_preirreducible {X : Type*} [TopologicalSpace X] {s : Set X} {x : X} (hs : IsPreirreducible s) (hx : x \u2208 s) : s \u2286 irreducibleComponent x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem nonempty_preirreducible_interior {X : Type*} [TopologicalSpace X] {s : Set X} [PreirreducibleSpace X] (ho : IsOpen s) (hne : s.Nonempty) : Dense (interior s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.closure_subset_univ {X : Type*} [TopologicalSpace X] [PreirreducibleSpace X] {s : Set X} (ho : IsOpen s) (hne : s.Nonempty) : (univ : Set X) \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_preclosure {X : Type*} [TopologicalSpace X] {Y : Type*} [TopologicalSpace Y] {s : Set X} (H : IsPreirreducible s) (f : X \u2192 Y) (hf : ContinuousOn f s) : IsPreirreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_preclosure {X : Type*} [TopologicalSpace X] {Y : Type*} [TopologicalSpace Y] {s : Set X} (H : IsIrreducible s) (f : X \u2192 Y) (hf : ContinuousOn f s) : IsIrreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_unique {X : Type*} [TopologicalSpace X] [IrreducibleSpace X] {s : Set X} (h : s \u2208 irreducibleComponents X) : s = (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_sInter_closed {X : Type*} [TopologicalSpace X] {s : Set X} : IsIrreducible s \u2194 \u2200 U : Finset (Set X), (\u2200 u \u2208 U, IsClosed u) \u2192 (\u2200 u \u2208 U, s \u2286 u) \u2192 \u2203 u \u2208 U, s \u2286 u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_closure_subset {X : Type*} [TopologicalSpace X] {s : Set X} : IsPreirreducible s \u2194 \u2200 z\u2081 z\u2082 : Set X, IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 (s \u2229 z\u2081).Nonempty \u2228 (s \u2229 z\u2082).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_union_closed_pair {X : Type*} [TopologicalSpace X] {s : Set X} : IsIrreducible s \u2194 \u2200 z\u2081 z\u2082 : Set X, IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 (s \u2286 z\u2081) \u2228 (s \u2286 z\u2082) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem subset_closure_of_isPreirreducible_of_isOpen {X : Type*} [TopologicalSpace X] {S U : Set X} (hS : IsPreirreducible S) (hU : IsOpen U) (h : S.Nonempty) : S \u2286 closure U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.open_irreducible {X : Type*} [TopologicalSpace X] {t U : Set X} (ht : IsPreirreducible t) (hU : IsOpen U) (hne : U.Nonempty) (hU_t : U \u2286 t) : IsIrreducible U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.preimage_closed {X : Type*} [TopologicalSpace X] {Y : Type*} [TopologicalSpace Y] {t : Set X} (ht : IsPreirreducible t) {f : Y \u2192 X} (hf : ClosedEmbedding f) : IsPreirreducible (f \u207b\u00b9' t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.has_point {X : Type*} [TopologicalSpace X] {s : Set X} (h : IsIrreducible s) : \u2203 x, x \u2208 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset {X : Type*} [TopologicalSpace X] (s : Set X) (H : IsPreirreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 s \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_of_mem_irreducibleComponents {X : Type*} [TopologicalSpace X] {s : Set X} (H : s \u2208 irreducibleComponents X) : IsPreirreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_subset_closedProper {X : Type*} [TopologicalSpace X] : irreducibleComponents X \u2286 {s : Set X | closure s = s} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem preirreducibleSpace_def' {X : Type*} [TopologicalSpace X] : PreirreducibleSpace X \u2194 IsPreirreducible (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.preimage_continuous_closure {X : Type*} [TopologicalSpace X] {Y : Type*} [TopologicalSpace Y] {s : Set X} (H : IsPreirreducible s) {f : Y \u2192 X} (hf : Continuous f) : IsPreirreducible (closure (f \u207b\u00b9' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.preimage_continuous_closure {X : Type*} [TopologicalSpace X] {Y : Type*} [TopologicalSpace Y] {s : Set X} (H : IsIrreducible s) {f : Y \u2192 X} (hf : Continuous f) : IsIrreducible (closure (f \u207b\u00b9' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem Subtype.preirreducibleSpace_iff {X : Type*} [TopologicalSpace X] {s : Set X} : PreirreducibleSpace s \u2194 IsPreirreducible (univ : Set s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_exists_component {X : Type*} [TopologicalSpace X] [IrreducibleSpace X] : \u2203 s : Set X, s \u2208 irreducibleComponents X := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_finite_open_inter {X : Type*} [TopologicalSpace X] {s : Set X} : IsPreirreducible s \u2194 \u2200 U : Finset (Set X), (\u2200 u \u2208 U, IsOpen u) \u2192 (s \u2229 \u22c2\u2080 \u2191U).Nonempty \u2192 \u2200 u \u2208 U, (s \u2229 u).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_isOpen_union {X : Type*} [TopologicalSpace X] {s : Set X} : IsPreirreducible s \u2194 \u2200 u v : Set X, IsOpen u \u2192 IsOpen v \u2192 s \u2286 u \u222a v \u2192 (s.Nonempty \u2192 (s \u2286 u) \u2228 (s \u2286 v)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem subset_closure_open_of_isPreirreducible {X : Type*} [TopologicalSpace X] {S U : Set X} (hS : IsPreirreducible S) (hU : IsOpen U) (h : S.Nonempty) : S \u2286 closure U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.closed_subset' {X : Type*} [TopologicalSpace X] {t U : Set X} (ht : IsPreirreducible t) (hU : IsClosed U) (hUt : U \u2286 t) : IsPreirreducible (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.exists_open_subset {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : \u2200 u : Set X, IsOpen u \u2192 s \u2286 u \u2192 (s = \u2205) \u2228 (u = univ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.union_cover {X : Type*} [TopologicalSpace X] {s u v : Set X}\n    (hs : IsPreirreducible s) (hu : IsOpen u) (hv : IsOpen v)\n    (hcov : s \u2286 u \u222a v) : (s \u2286 u) \u2228 (s \u2286 v) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_pair {X : Type*} [TopologicalSpace X] {x y : X} (hxy : x = y) :\n    IsIrreducible ({x, y} : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_closed_eq {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : s \u2208 irreducibleComponents X) : closure s = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_closed {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Continuous f)\n    (hcl : IsClosed (f '' s)) : IsIrreducible (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.open_or_compl_nonempty {X : Type*} [TopologicalSpace X] {s u : Set X}\n    (hs : IsPreirreducible s) (hu : IsOpen u) :\n    (s \u2229 u).Nonempty \u2228 (s \u2229 u\u1d9c).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.preimage_openEmbedding {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : Y \u2192 X}\n    (hf : IsOpenEmbedding f) : IsIrreducible (f \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_denseRange {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Continuous f)\n    (hd : DenseRange f) : IsIrreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.union_closed_inter {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsClosed t) (hne : (s \u2229 t).Nonempty) :\n    IsIrreducible (s \u2229 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.union_nonempty {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsPreirreducible s) (ht : IsPreirreducible t) (h : (s \u2229 t).Nonempty) :\n    IsPreirreducible (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.cover_by_two_open {X : Type*} [TopologicalSpace X] {s u v : Set X}\n    (hs : IsIrreducible s) (hu : IsOpen u) (hv : IsOpen v) (hcov : s \u2286 u \u222a v) :\n    (s \u2286 u) \u2228 (s \u2286 v) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Embedding f) :\n    IsIrreducible (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.compact_implies_irreducible {X : Type*} [TopologicalSpace X]\n    {s : Set X} (hs : IsPreirreducible s) (hc : IsCompact s) : IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.irreducible_or_empty {X : Type*} [TopologicalSpace X]\n    [PreirreducibleSpace X] {s : Set X} (ho : IsOpen s) : s = \u2205 \u2228 closure s = univ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_embedding {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsPreirreducible s) {f : X \u2192 Y} (hf : IsOpenEmbedding f) :\n    IsPreirreducible (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_of_closed_subset {X : Type*} [TopologicalSpace X] {s z : Set X} (hs : IsIrreducible s) (hz : IsClosed z) (hsub : s \u2286 z) : IsIrreducible z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem not_preirreducible_empty {X : Type*} [TopologicalSpace X] : \u00ac IsPreirreducible (\u2205 : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem image_of_irreducible_is_irreducible {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Continuous f) : IsIrreducible (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_of_dense_subset {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsIrreducible s) (hst : s \u2286 closure t) (htne : t.Nonempty) : IsIrreducible t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem PreirreducibleSpace.interior_irreducible {X : Type*} [TopologicalSpace X] [PreirreducibleSpace X] : IsPreirreducible (interior (univ : Set X)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_union_closed {X : Type*} [TopologicalSpace X] {s t : Set X} (hs : IsIrreducible s) (hcl : IsClosed t) : IsIrreducible (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Embedding f) : IsIrreducible (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem nonempty_preirreducible_closure {X : Type*} [TopologicalSpace X] {s : Set X} (hs : IsPreirreducible s) : (closure s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_preclosure {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s : Set X} (hs : IsPreirreducible s) {f : X \u2192 Y} (hf : ContinuousOn f s) : IsPreirreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.nonempty_union_self {X : Type*} [TopologicalSpace X] {s : Set X}\n     (h : IsIrreducible s) : (s \u222a s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_univ_of_preirreducible (X : Type*) [TopologicalSpace X]\n     [PreirreducibleSpace X] [Nonempty X] : IsIrreducible (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_closure_interior_swap {X : Type*} [TopologicalSpace X] {s : Set X} :\n     IsPreirreducible (closure (interior s)) \u2194 IsPreirreducible (interior (closure s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_closure_interior_swap {X : Type*} [TopologicalSpace X] {s : Set X} :\n     IsIrreducible (closure (interior s)) \u2194 IsIrreducible (interior (closure s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset_closure {X : Type*} [TopologicalSpace X] {s : Set X}\n     (h : IsIrreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 closure s \u2286 t \u2227 t \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_closure_of_component {X : Type*} [TopologicalSpace X] {s : Set X}\n     (h : s \u2208 irreducibleComponents X) : IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem singleton_in_closure_irreducibleComponent {X : Type*} [TopologicalSpace X] {x : X} :\n     ({x} : Set X) \u2286 closure (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem closure_subset_irreducibleComponent {X : Type*} [TopologicalSpace X] {x : X} :\n     closure (irreducibleComponent x) \u2286 irreducibleComponent x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_closure_irreducibleComponent {X : Type*} [TopologicalSpace X] {x : X} :\n     IsPreirreducible (closure (irreducibleComponent x)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.irreducibleComponent_subset {X : Type*} [TopologicalSpace X] {s : Set X}\n     {x : X} (hs : IsIrreducible s) (hx : x \u2208 s) : irreducibleComponent x \u2286 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_continuous {X : Type*} [TopologicalSpace X]\n     {Y : Type*} [TopologicalSpace Y] {s : Set X} (H : IsPreirreducible s)\n     {f : X \u2192 Y} (hf : Continuous f) : IsPreirreducible (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_preirreducible_closure_eq {X : Type*} [TopologicalSpace X] {s : Set X}\n     (H : IsPreirreducible s) : \u2203 t : Set X, IsPreirreducible t \u2227 closure s \u2286 t \u2227 t = closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.nontrivial {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : \u2203 x y : X, x \u2208 s \u2227 y \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem interior_irreducible_of_preirreducible {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsPreirreducible s) (hne : s.Nonempty) : IsIrreducible (interior s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.open_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) (ho : IsOpen s) (hne : s.Nonempty) : Dense s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.inter_closure_eq {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsPreirreducible s) (ht : IsClosed t) (hsub : s \u2286 t) : closure s = t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponent_dense {X : Type*} [TopologicalSpace X] (x : X) :\n    Dense (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem union_of_irreducibles {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsIrreducible t) (hne : (s \u2229 t).Nonempty) :\n    IsIrreducible (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem interior_of_irreducible_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsIrreducible s) : Dense (interior s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 s \u2286 closure t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding_dense {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Embedding f) (hd : DenseRange f) :\n    IsIrreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.inter_closed_irreducible {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsClosed t) (hne : (s \u2229 t).Nonempty) :\n    IsIrreducible (closure (s \u2229 t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem not_isIrreducible_univ {X : Type*} [TopologicalSpace X] [IsEmpty X] :\n    \u00ac IsIrreducible (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem Set.Subsingleton.irreducible_or_empty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : s.Subsingleton) : IsIrreducible s \u2228 s = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_closure_interior {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible (closure (interior s)) \u2194 IsPreirreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset' {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 s \u2286 t \u2227 closure s \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.subset_of_irreducibleComponent {X : Type*} [TopologicalSpace X]\n    {s : Set X} {x : X} (hs : IsIrreducible s) (hx : x \u2208 s) : irreducibleComponent x \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_continuous' {X Y : Type*} [TopologicalSpace X]\n     [TopologicalSpace Y] {s : Set X} (H : IsPreirreducible s) {f : X \u2192 Y}\n     (hf : Continuous f) : IsPreirreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_preirreducible_eq_closure {X : Type*} [TopologicalSpace X] {s : Set X}\n     (H : IsPreirreducible s) : \u2203 t : Set X, IsPreirreducible t \u2227 t = closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.two_points {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : \u2203 x y, x \u2260 y \u2192 x \u2208 s \u2227 y \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.open_dense' {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) (ho : IsOpen s) : Dense s \u2228 s = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponent_dense' {X : Type*} [TopologicalSpace X] {x : X} :\n    Dense (closure (irreducibleComponent x)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem union_of_irreducibles_nonempty {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsIrreducible t) (h : (s \u2229 t).Nonempty) :\n    (s \u222a t).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem interior_dense_of_irreducible {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsIrreducible s) : Dense (closure (interior s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_closure_superset {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : \u2203 t, IsIrreducible t \u2227 closure s \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding_dense' {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y}\n    (hf : Embedding f) (hd : DenseRange f) :\n    IsIrreducible (closure (f '' closure s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.union_of_nonempty {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsPreirreducible s) (ht : IsPreirreducible t) (hne : (s \u2229 t).Nonempty) :\n    IsPreirreducible (closure (s \u222a t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.cover_by_open_pair {X : Type*} [TopologicalSpace X] {s u v : Set X}\n    (hs : IsIrreducible s) (hu : IsOpen u) (hv : IsOpen v) :\n    s \u2286 u \u222a v \u2192 (s \u2286 closure u) \u2228 (s \u2286 closure v) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.compact_irreducible' {X : Type*} [TopologicalSpace X]\n    {s : Set X} (hs : IsPreirreducible s) (hc : IsCompact (closure s)) : IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.irreducible_or_dense {X : Type*} [TopologicalSpace X]\n    [PreirreducibleSpace X] {s : Set X} (ho : IsOpen s) : s = \u2205 \u2228 Dense s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_union_closed_left {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsClosed t) : IsIrreducible (closure (s \u222a t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.double_union_nonempty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsIrreducible s) : (s \u222a closure s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.component_subset {X : Type*} [TopologicalSpace X] {s : Set X} {x : X}\n     (hs : IsIrreducible s) (hx : x \u2208 s) : irreducibleComponent x \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.continuous_image {X Y : Type*} [TopologicalSpace X]\n     [TopologicalSpace Y] {s : Set X} (hs : IsPreirreducible s)\n     {f : X \u2192 Y} (hf : Continuous f) : IsPreirreducible (closure (f '' closure s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_preirreducible_equal_closure {X : Type*} [TopologicalSpace X] {s : Set X}\n     (hs : IsPreirreducible s) : \u2203 t, IsPreirreducible t \u2227 closure s = t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.nonempty_union {X : Type*} [TopologicalSpace X] {s : Set X}\n     (h : IsIrreducible s) : (s \u222a closure s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem interior_irreducible_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n     (hs : IsIrreducible s) : Dense (interior (closure s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem union_irreducibles_irreducible {X : Type*} [TopologicalSpace X] {s t : Set X}\n     (hs : IsIrreducible s) (ht : IsIrreducible t) (hne : (s \u2229 t).Nonempty) :\n     IsIrreducible (closure (s \u222a t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.cover_by_open_or_dense {X : Type*} [TopologicalSpace X] {s u v : Set X}\n    (hs : IsIrreducible s) (hu : IsOpen u) (hv : IsOpen v) (hcov : s \u2286 u \u222a v) :\n    Dense u \u2228 Dense v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.irreducible_or_closure_univ {X : Type*} [TopologicalSpace X]\n    [PreirreducibleSpace X] {s : Set X} (ho : IsOpen s) : IsIrreducible (closure s) \u2228 closure s = univ := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_embedding_dense {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsPreirreducible s) {f : X \u2192 Y}\n    (hf : IsOpenEmbedding f) : Dense (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_of_compact_subset {X : Type*} [TopologicalSpace X] {s z : Set X}\n    (hs : IsIrreducible s) (hz : IsCompact z) (hsub : s \u2286 z) : IsIrreducible z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem dense_of_preirreducible_open {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) (ho : IsOpen s) : Dense (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_of_dense {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (hd : Dense t) (hsub : s \u2286 t) : IsIrreducible t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem PreirreducibleSpace.univ_irreducible {X : Type*} [TopologicalSpace X]\n    [PreirreducibleSpace X] [Nonempty X] : IsIrreducible (closure (univ : Set X)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.compact_closure_irreducible {X : Type*} [TopologicalSpace X]\n    {s : Set X} (hs : IsPreirreducible s) : IsCompact (closure s) \u2192 IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem nonempty_closure_component {X : Type*} [TopologicalSpace X] {x : X} :\n    (closure (irreducibleComponent x)).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding_dense' {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y}\n    (hf : Embedding f) : Dense (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.closed_inter_dense {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsClosed t) (h : (s \u2229 t).Nonempty) :\n    Dense (s \u2229 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem not_irreducible_singleton_empty {X : Type*} [TopologicalSpace X] :\n    \u00ac IsIrreducible ({()} : Set (PUnit)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem Set.Finite.isIrreducible {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : s.Finite) (hne : s.Nonempty) : IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem preirreducible_iff_inter_closure {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible (s \u2229 closure s) \u2194 IsPreirreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducible_iff_inter_closure {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible (s \u2229 closure s) \u2194 IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_maximal_irreducible {X : Type*} [TopologicalSpace X] (s : Set X)\n    (h : IsIrreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 s \u2286 t \u2227 closure t = t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem components_subset_closed_closure (X : Type*) [TopologicalSpace X] :\n    irreducibleComponents X \u2286 {s | closure s = s \u2227 IsClosed s} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.unique_component {X : Type*} [TopologicalSpace X] {s : Set X}\n    {x : X} (hs : IsIrreducible s) (hx : x \u2208 s) : closure s = irreducibleComponent x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem component_in_components {X : Type*} [TopologicalSpace X] {x : X} {t : Set X}\n    (ht : t \u2208 irreducibleComponents X) (hx : x \u2208 t) :\n    irreducibleComponent x \u2286 closure t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem closure_idempotent_component {X : Type*} [TopologicalSpace X] {x : X} :\n    closure (closure (irreducibleComponent x)) = irreducibleComponent x := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem preirreducible_space_char (X : Type*) [TopologicalSpace X] :\n    PreirreducibleSpace X \u2194 IsPreirreducible (closure (univ : Set X)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.univ_closure_eq {X : Type*} [TopologicalSpace X] [PreirreducibleSpace X]\n    {s : Set X} (ho : IsOpen s) (hne : s.Nonempty) : closure s = closure (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem subtype_irreducible_space_char {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IrreducibleSpace s \u2194 IsIrreducible (closure (univ : Set s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducible_iff_finite_open_cover {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible s \u2194 \u2200 t : Finset (Set X), (\u2200 u \u2208 t, IsOpen u) \u2192\n      s \u2286 \u22c3\u2080 \u2191t \u2192 \u2203 u \u2208 t, closure s \u2286 closure u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem subset_closure_union_preirreducible {X : Type*} [TopologicalSpace X]\n    {S U : Set X} (hS : IsPreirreducible S) (hU : IsOpen U) (h : S.Nonempty) :\n    S \u2286 closure (U \u222a S) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem preirreducible_of_open_subset {X : Type*} [TopologicalSpace X]\n    {t U : Set X} (ht : IsPreirreducible t) (hU : IsOpen U) (hUt : U \u2286 t) :\n    IsPreirreducible (closure U) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding' {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y}\n    (hf : Embedding f) : IsIrreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.empty_or_dense {X : Type*} [TopologicalSpace X] [PreirreducibleSpace X]\n    {s : Set X} (ho : IsOpen s) : s = \u2205 \u2228 Dense (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem dense_of_irreducible_image {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Continuous f) :\n    Dense (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset_closure' {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsIrreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 closure s \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.closed_inter_dense' {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsClosed t) (hne : (s \u2229 t).Nonempty) :\n    Dense (closure (s \u2229 t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_closure_interior {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible (closure (interior s)) \u2194 IsPreirreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_closure_interior {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible (closure (interior s)) \u2194 IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponent_dense {X : Type*} [TopologicalSpace X] (x : X) :\n    Dense (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding_dense {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Embedding f)\n    (hd : DenseRange f) : IsIrreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem not_preirreducible_empty {X : Type*} [TopologicalSpace X] :\n    \u00ac IsPreirreducible (\u2205 : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.ne_empty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : s \u2260 \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.open_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) (ho : IsOpen s) (hne : s.Nonempty) : Dense s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_union_closed {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsClosed t) : IsIrreducible (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 s \u2286 closure t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem component_subset_closure {X : Type*} [TopologicalSpace X] {x : X} {s : Set X}\n    (hs : x \u2208 s) : irreducibleComponent x \u2286 closure s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem dense_of_irreducible_image {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Continuous f) :\n    Dense (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.exists_open_subset {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : \u2200 u : Set X, IsOpen u \u2192 s \u2286 u \u2192 (s = \u2205) \u2228 (u = univ) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.union_nonempty {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsPreirreducible s) (ht : IsPreirreducible t) (h : (s \u2229 t).Nonempty) :\n    IsPreirreducible (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem PreirreducibleSpace.closure_univ_irreducible (X : Type*) [TopologicalSpace X]\n    [PreirreducibleSpace X] : IsIrreducible (closure (univ : Set X)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.inter_closed_irreducible {X : Type*} [TopologicalSpace X]\n    {s t : Set X} (hs : IsIrreducible s) (ht : IsClosed t) (hne : (s \u2229 t).Nonempty) :\n    IsIrreducible (closure (s \u2229 t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.exists_subset_mem {X : Type*} [TopologicalSpace X] {s u : Set X}\n    (h : IsIrreducible s) (hsu : s \u2286 u) : \u2203 x : X, x \u2208 u := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_frontier {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible (frontier s) \u2194 IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset_closed {X : Type*} [TopologicalSpace X]\n    {s : Set X} (h : IsIrreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 s \u2286 t \u2227 IsClosed t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_subset_compact {X : Type*} [TopologicalSpace X] :\n    irreducibleComponents X \u2286 {s | IsCompact s} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.subset_irreducibleComponent {X : Type*} [TopologicalSpace X]\n    {s : Set X} {x : X} (hs : IsIrreducible s) (hx : x \u2208 s) : s \u2286 closure (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem preirreducibleSpace_iff_univ_dense (X : Type*) [TopologicalSpace X] :\n    PreirreducibleSpace X \u2194 Dense (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.closure_eq_space_of_preirreducible {X : Type*} [TopologicalSpace X]\n    [PreirreducibleSpace X] {s : Set X} (ho : IsOpen s) (hne : s.Nonempty) :\n    closure s = (\u22a4 : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.preimage_closedEmbedding {X : Type*} [TopologicalSpace X]\n    {Y : Type*} [TopologicalSpace Y] {s : Set X} (H : IsPreirreducible s)\n    {f : Y \u2192 X} (hf : ClosedEmbedding f) : IsPreirreducible (closure (f \u207b\u00b9' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_finite_inter {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible s \u2194\n      \u2200 U : Finset (Set X), (\u2200 u \u2208 U, IsOpen u) \u2192 (s \u2229 \u22c2\u2080 \u2191U).Nonempty \u2192\n        \u2200 u \u2208 U, (s \u2229 closure u).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem subset_closure_open_of_irreducible {X : Type*} [TopologicalSpace X]\n    {S U : Set X} (hS : IsIrreducible S) (hU : IsOpen U) (hSU : S \u2286 U) :\n    S \u2286 closure U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.closed_subset_closure {X : Type*} [TopologicalSpace X]\n    {t U : Set X} (ht : IsPreirreducible t) (hU : IsClosed U) (hUt : U \u2286 t) :\n    IsPreirreducible (closure (U \u2229 t)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.nonempty_frontier {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : (frontier s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem not_isIrreducible_singleton {X : Type*} [TopologicalSpace X] {x : X} :\n    \u00ac IsIrreducible ({x} : Set X) \u2192 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem finite_irreducible_of_nonempty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : s.Finite) (hne : s.Nonempty) : IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.unique_irreducibleComponent {X : Type*} [TopologicalSpace X]\n    {s : Set X} {x : X} (hs : IsIrreducible s) (hx : x \u2208 s) :\n    closure s = closure (irreducibleComponent x) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.compact_closure_irreducible {X : Type*} [TopologicalSpace X]\n    {s : Set X} (hs : IsPreirreducible s) (hc : IsCompact (closure s)) :\n    IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_iff_closure_subset_univ {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible s \u2194 closure s \u2286 (univ : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_dense {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible s \u2194 Dense s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_irreducible_superset_closed {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsPreirreducible s) : \u2203 t : Set X, IsIrreducible t \u2227 IsClosed t \u2227 s \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_closed {X : Type*} [TopologicalSpace X] :\n    (irreducibleComponents X).Subset IsClosed := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponent_nonempty {X : Type*} [TopologicalSpace X] (x : X) :\n    (irreducibleComponent x).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.closure_eq {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : closure s = s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_dense {X : Type*} [TopologicalSpace X] {Y : Type*}\n    [TopologicalSpace Y] {s : Set X} (hs : IsPreirreducible s) {f : X \u2192 Y}\n    (hf : Continuous f) : Dense (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_embedding_dense {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y}\n    (hf : Embedding f) : Dense (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_union {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsIrreducible s) (ht : IsIrreducible t) : IsIrreducible (s \u222a t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isPreirreducible_inter {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hs : IsPreirreducible s) (ht : IsPreirreducible t) :\n    IsPreirreducible (s \u2229 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.compact_closure {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : IsCompact (closure s) \u2192 IsPreirreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.open_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsIrreducible s) (ho : IsOpen s) : Dense s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_interior {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible s \u2192 IsIrreducible (interior s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_preclosure_dense {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsPreirreducible s) {f : X \u2192 Y}\n    (hf : ContinuousOn f s) : Dense (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.exists_distinct_mem {X : Type*} [TopologicalSpace X] {s : Set X}\n    (h : IsIrreducible s) : \u2203 x y : X, x \u2260 y \u2227 x \u2208 s \u2227 y \u2208 s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem not_isIrreducible_singleton {X : Type*} [TopologicalSpace X] {x : X} :\n    \u00ac IsIrreducible ({x} : Set X) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_iff_dense_closure {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsIrreducible s \u2194 Dense (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.open_or_closed_cover {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) {u v : Set X} (hu : IsOpen u) (hv : IsClosed v)\n    (hcov : s \u2286 u \u222a v) : s \u2286 u \u2228 s \u2286 v := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_closed {X : Type*} [TopologicalSpace X] :\n    irreducibleComponents X \u2286 {s | IsClosed (closure s)} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_preirreducible_containing_open {X : Type*} [TopologicalSpace X]\n    {s : Set X} (hs : IsOpen s) (hne : s.Nonempty) :\n    \u2203 t : Set X, IsPreirreducible t \u2227 s \u2286 t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.compact_subset_irreducible {X : Type*} [TopologicalSpace X]\n    {s z : Set X} (hs : IsPreirreducible s) (hz : IsCompact z) (hsub : s \u2286 z) :\n    IsIrreducible z := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsOpen.dense_or_empty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (ho : IsOpen s) : Dense s \u2228 s = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.frontier_nonempty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : (frontier s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem isIrreducible_of_dense {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hd : Dense t) (hst : s \u2286 t) : IsIrreducible s \u2192 IsIrreducible t := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.subset_irreducibleClosure {X : Type*} [TopologicalSpace X]\n    {s : Set X} (hs : IsPreirreducible s) : IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_closure_dense {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Continuous f) :\n    Dense (closure (f '' closure s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem preirreducible_empty_false {X : Type*} [TopologicalSpace X] :\n    (IsPreirreducible (\u2205 : Set X)) \u2194 False := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem exists_maximal_irreducible_subset {X : Type*} [TopologicalSpace X] (s : Set X)\n    (hs : IsIrreducible s) : \u2203 t, IsIrreducible t \u2227 t \u2286 s \u2227 (\u2200 u, IsIrreducible u \u2192 t \u2286 u \u2192 u \u2286 t) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem irreducibleComponents_subset_compact {X : Type*} [TopologicalSpace X] :\n    irreducibleComponents X \u2286 {s | IsCompact s} := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.open_dense_subset {X : Type*} [TopologicalSpace X] {s U : Set X}\n    (hs : IsPreirreducible s) (hU : IsOpen U) (hsub : s \u2286 U) (hne : s.Nonempty) : Dense U := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_dense {X : Type*} [TopologicalSpace X] {Y : Type*}\n    [TopologicalSpace Y] {s : Set X} (hs : IsPreirreducible s) {f : X \u2192 Y}\n    (hf : Continuous f) : Dense (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.compact_of_closed {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsIrreducible s) (hcl : IsClosed s) : IsCompact s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.of_dense {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (hst : s \u2286 closure t) (ht : IsIrreducible t) : IsIrreducible s := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.image_embedding {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsPreirreducible s) {f : X \u2192 Y}\n    (hf : IsOpenEmbedding f) : IsPreirreducible (f '' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.preimage_embedding {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] {s : Set X} (hs : IsIrreducible s) {f : Y \u2192 X}\n    (hf : Embedding f) : IsIrreducible (f \u207b\u00b9' s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.closure_nonempty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsIrreducible s) : (closure s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.image_dense {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {s : Set X} (hs : IsIrreducible s) {f : X \u2192 Y} (hf : Continuous f) :\n    IsIrreducible (closure (f '' s)) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem preirreducible_interior {X : Type*} [TopologicalSpace X] {s : Set X} :\n    IsPreirreducible s \u2192 IsPreirreducible (interior s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.compact_closure {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : IsCompact (closure s) \u2192 IsIrreducible (closure s) := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.frontier_nonempty {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : (frontier s).Nonempty := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsIrreducible.exists_open_or_dense {X : Type*} [TopologicalSpace X] {s u : Set X}\n    (hs : IsIrreducible s) (hu : IsOpen u) (hcov : s \u2286 u) : Dense u \u2228 s = \u2205 := by\n"}
{"problem": "import Mathlib\nimport Aesop\n\nvariable {X : Type*} {Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}\n\nopen Topology Set\ntheorem IsPreirreducible.subset_dense {X : Type*} [TopologicalSpace X] {s : Set X}\n    (hs : IsPreirreducible s) : Dense (closure s) := by\n"}
